Description: Upstream changes introduced in version 0.1.6-0ubuntu1
 This patch has been created by dpkg-source during the package build.
 Here's the last changelog entry, hopefully it gives details on why
 those changes were made:
 .
 beagletomb (0.1.6-0ubuntu1) natty; urgency=low
 .
   * Update: changed sql cache to be more elegant and efficient (Closes: #nnnn)
 .
 The person named in the Author field signed this changelog entry.
Author: Grant Hutchinson <h.g.utchinson@gmail.com>

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: http://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: <YYYY-MM-DD>

--- /dev/null
+++ beagletomb-0.1.6/beagletomb.pro.THIS
@@ -0,0 +1,72 @@
+#-------------------------------------------------
+#
+# Project created by QtCreator 2012-01-24T14:56:37
+#
+#-------------------------------------------------
+
+QT       += core gui sql
+
+TARGET = beagletomb
+TEMPLATE = app
+QT += network \
+        opengl
+
+
+SOURCES += src/main.cpp\
+    src/beaglemain.cpp \
+    src/sync.cpp \
+    src/songObj.cpp \
+    src/readDB.cpp \
+    src/qmpwidget.cpp \
+    src/preferences.cpp \
+    src/prefdialog.cpp \
+    src/mysqlconn.cpp \
+    src/mplaycon.cpp \
+    src/about.cpp \
+    src/newplaylist.cpp \
+    src/playlistobj.cpp \
+    src/openplaylist.cpp \
+    src/radioObj.cpp \
+    src/fileobj.cpp \
+    src/localsync.cpp
+
+HEADERS  += src/beaglemain.h \
+    src/sync.h \
+    src/songObj.h \
+    src/readDB.h \
+    src/qmpyuvreader.h \
+    src/qmpwidget.h \
+    src/preferences.h \
+    src/prefdialog.h \
+    src/mysqlconn.h \
+    src/mplaycon.h \
+    src/about.h \
+    src/newplaylist.h \
+    src/playlistobj.h \
+    src/sync.h \
+    src/songObj.h \
+    src/readDB.h \
+    src/qmpyuvreader.h \
+    src/qmpwidget.h \
+    src/preferences.h \
+    src/prefdialog.h \
+    src/playlistobj.h \
+    src/newplaylist.h \
+    src/mysqlconn.h \
+    src/mplaycon.h \
+    src/beaglemain.h \
+    src/about.h \
+    src/openplaylist.h \
+    src/radioObj.h \
+    src/fileobj.h \
+    src/localsync.h
+
+FORMS    += \
+    src/prefdialog.ui \
+    src/about.ui \
+    src/newplaylist.ui \
+    src/beaglemain.ui \
+    src/openplaylist.ui
+
+RESOURCES += \
+    images/BTres.qrc
--- /dev/null
+++ beagletomb-0.1.6/beagletomb.pro.BASE
@@ -0,0 +1,69 @@
+#-------------------------------------------------
+#
+# Project created by QtCreator 2012-01-24T14:56:37
+#
+#-------------------------------------------------
+
+QT       += core gui
+QT       += sql
+
+TARGET = beagletomb
+TEMPLATE = app
+QT += network \
+        opengl
+
+
+SOURCES += src/main.cpp\
+    src/beaglemain.cpp \
+    src/sync.cpp \
+    src/songObj.cpp \
+    src/readDB.cpp \
+    src/qmpwidget.cpp \
+    src/preferences.cpp \
+    src/prefdialog.cpp \
+    src/mysqlconn.cpp \
+    src/mplaycon.cpp \
+    src/about.cpp \
+    src/newplaylist.cpp \
+    src/playlistobj.cpp \
+    src/openplaylist.cpp \
+    src/radioObj.cpp
+
+HEADERS  += src/beaglemain.h \
+    src/sync.h \
+    src/songObj.h \
+    src/readDB.h \
+    src/qmpyuvreader.h \
+    src/qmpwidget.h \
+    src/preferences.h \
+    src/prefdialog.h \
+    src/mysqlconn.h \
+    src/mplaycon.h \
+    src/about.h \
+    src/newplaylist.h \
+    src/playlistobj.h \
+    src/sync.h \
+    src/songObj.h \
+    src/readDB.h \
+    src/qmpyuvreader.h \
+    src/qmpwidget.h \
+    src/preferences.h \
+    src/prefdialog.h \
+    src/playlistobj.h \
+    src/newplaylist.h \
+    src/mysqlconn.h \
+    src/mplaycon.h \
+    src/beaglemain.h \
+    src/about.h \
+    src/openplaylist.h \
+    src/radioObj.h
+
+FORMS    += \
+    src/prefdialog.ui \
+    src/about.ui \
+    src/newplaylist.ui \
+    src/beaglemain.ui \
+    src/openplaylist.ui
+
+RESOURCES += \
+    images/BTres.qrc
--- beagletomb-0.1.6.orig/beagletomb.pro
+++ beagletomb-0.1.6/beagletomb.pro
@@ -4,8 +4,7 @@
 #
 #-------------------------------------------------
 
-QT       += core gui
-QT       += sql
+QT       += core gui sql
 
 TARGET = beagletomb
 TEMPLATE = app
@@ -28,7 +27,12 @@ SOURCES += src/main.cpp\
     src/playlistobj.cpp \
     src/openplaylist.cpp \
     src/radioObj.cpp \
+<<<<<<< TREE
+    src/fileobj.cpp \
+    src/localsync.cpp
+=======
     src/fileobj.cpp
+>>>>>>> MERGE-SOURCE
 
 HEADERS  += src/beaglemain.h \
     src/sync.h \
@@ -58,7 +62,12 @@ HEADERS  += src/beaglemain.h \
     src/about.h \
     src/openplaylist.h \
     src/radioObj.h \
+<<<<<<< TREE
+    src/fileobj.h \
+    src/localsync.h
+=======
     src/fileobj.h
+>>>>>>> MERGE-SOURCE
 
 FORMS    += \
     src/prefdialog.ui \
--- /dev/null
+++ beagletomb-0.1.6/changelog.BASE
@@ -0,0 +1,5 @@
+beagletomb (0.1.5-0ubuntu1) natty; urgency=low
+
+  * Initial release (Closes: #nnnn)  <nnnn is the bug number of your ITP>
+
+ -- Grant Hutchinson <h.g.utchinson@gmail.com>  Wed, 22 Feb 2012 18:59:22 -0500
--- /dev/null
+++ beagletomb-0.1.6/changelog.OTHER
@@ -0,0 +1,37 @@
+beagletomb (0.1.6-0ubuntu1~9) natty; urgency=low
+
+  * Update: Fixed database read dynamic memory allocation. Now handles larger, more dynamic, data set (Closes: #nnnn)
+
+ -- Grant Hutchinson <h.g.utchinson@gmail.com>  Tues, 28 Mar 2012 05:59:22 -0500
+
+beagletomb (0.1.6-0ubuntu1~8) natty; urgency=low
+
+  * Update: Fixed dynamic memory allocation, sync improved (Closes: #nnnn)
+
+ -- Grant Hutchinson <h.g.utchinson@gmail.com>  Mon, 27 Mar 2012 18:59:22 -0500
+
+beagletomb (0.1.6-0ubuntu1~7) natty; urgency=low
+
+  * Update: Fixed dynamic memory allocation, sync improved (Closes: #nnnn)
+
+ -- Grant Hutchinson <h.g.utchinson@gmail.com>  Mon, 27 Mar 2012 18:59:22 -0500
+
+beagletomb (0.1.6-0ubuntu1) natty; urgency=low
+
+  * Update: fixed mediatomb mysql install/configure (Closes: #nnnn)
+  * Update: Added dynamic account creation (Closes: #nnnn)
+  * Update: changed sql cache to be more elegant and efficient (Closes: #nnnn)
+
+ -- Grant Hutchinson <h.g.utchinson@gmail.com>  Wed, 21 Mar 2012 18:59:22 -0500
+
+beagletomb (0.1.6-0ubuntu1) natty; urgency=low
+
+  * Update: changed sql cache to be more elegant and efficient (Closes: #nnnn)
+
+ -- Grant Hutchinson <h.g.utchinson@gmail.com>  Wed, 22 Feb 2012 18:59:22 -0500
+
+beagletomb (0.1.5-0ubuntu1) natty; urgency=low
+
+  * Initial release (Closes: #nnnn)
+
+ -- Grant Hutchinson <h.g.utchinson@gmail.com>  Wed, 22 Feb 2012 18:59:22 -0500
--- /dev/null
+++ beagletomb-0.1.6/changelog.THIS
@@ -0,0 +1,23 @@
+beagletomb (0.1.7-0ubuntu1~1) natty; urgency=low
+
+  * Added: New Local audio/video library sync, local features (Closes: #nnnn)
+
+ -- Grant Hutchinson <h.g.utchinson@gmail.com>  Sun, 1 Apr 2012 2:02:22 -0500
+
+beagletomb (0.1.6-0ubuntu1~7) natty; urgency=low
+
+  * Update: Fixed dynamic memory allocation, sync improved (Closes: #nnnn)
+
+ -- Grant Hutchinson <h.g.utchinson@gmail.com>  Mon, 27 Mar 2012 18:59:22 -0500
+
+beagletomb (0.1.6-0ubuntu1) natty; urgency=low
+
+  * Update: changed sql cache to be more elegant and efficient (Closes: #nnnn)
+
+ -- Grant Hutchinson <h.g.utchinson@gmail.com>  Wed, 22 Feb 2012 18:59:22 -0500
+
+beagletomb (0.1.5-0ubuntu1) natty; urgency=low
+
+  * Initial release (Closes: #nnnn)
+
+ -- Grant Hutchinson <h.g.utchinson@gmail.com>  Wed, 22 Feb 2012 18:59:22 -0500
--- /dev/null
+++ beagletomb-0.1.6/beagletomb.pro.OTHER
@@ -0,0 +1,71 @@
+#-------------------------------------------------
+#
+# Project created by QtCreator 2012-01-24T14:56:37
+#
+#-------------------------------------------------
+
+QT       += core gui
+QT       += sql
+
+TARGET = beagletomb
+TEMPLATE = app
+QT += network \
+        opengl
+
+
+SOURCES += src/main.cpp\
+    src/beaglemain.cpp \
+    src/sync.cpp \
+    src/songObj.cpp \
+    src/readDB.cpp \
+    src/qmpwidget.cpp \
+    src/preferences.cpp \
+    src/prefdialog.cpp \
+    src/mysqlconn.cpp \
+    src/mplaycon.cpp \
+    src/about.cpp \
+    src/newplaylist.cpp \
+    src/playlistobj.cpp \
+    src/openplaylist.cpp \
+    src/radioObj.cpp \
+    src/fileobj.cpp
+
+HEADERS  += src/beaglemain.h \
+    src/sync.h \
+    src/songObj.h \
+    src/readDB.h \
+    src/qmpyuvreader.h \
+    src/qmpwidget.h \
+    src/preferences.h \
+    src/prefdialog.h \
+    src/mysqlconn.h \
+    src/mplaycon.h \
+    src/about.h \
+    src/newplaylist.h \
+    src/playlistobj.h \
+    src/sync.h \
+    src/songObj.h \
+    src/readDB.h \
+    src/qmpyuvreader.h \
+    src/qmpwidget.h \
+    src/preferences.h \
+    src/prefdialog.h \
+    src/playlistobj.h \
+    src/newplaylist.h \
+    src/mysqlconn.h \
+    src/mplaycon.h \
+    src/beaglemain.h \
+    src/about.h \
+    src/openplaylist.h \
+    src/radioObj.h \
+    src/fileobj.h
+
+FORMS    += \
+    src/prefdialog.ui \
+    src/about.ui \
+    src/newplaylist.ui \
+    src/beaglemain.ui \
+    src/openplaylist.ui
+
+RESOURCES += \
+    images/BTres.qrc
--- beagletomb-0.1.6.orig/changelog
+++ beagletomb-0.1.6/changelog
@@ -1,8 +1,22 @@
+<<<<<<< TREE
+beagletomb (0.1.7-0ubuntu1~1) natty; urgency=low
+
+  * Added: New Local audio/video library sync, local features (Closes: #nnnn)
+
+ -- Grant Hutchinson <h.g.utchinson@gmail.com>  Sun, 1 Apr 2012 2:02:22 -0500
+=======
+beagletomb (0.1.6-0ubuntu1~9) natty; urgency=low
+
+  * Update: Fixed database read dynamic memory allocation. Now handles larger, more dynamic, data set (Closes: #nnnn)
+
+ -- Grant Hutchinson <h.g.utchinson@gmail.com>  Tues, 28 Mar 2012 05:59:22 -0500
+
 beagletomb (0.1.6-0ubuntu1~8) natty; urgency=low
 
   * Update: Fixed dynamic memory allocation, sync improved (Closes: #nnnn)
 
  -- Grant Hutchinson <h.g.utchinson@gmail.com>  Mon, 27 Mar 2012 18:59:22 -0500
+>>>>>>> MERGE-SOURCE
 
 beagletomb (0.1.6-0ubuntu1~7) natty; urgency=low
 
@@ -12,6 +26,8 @@ beagletomb (0.1.6-0ubuntu1~7) natty; urg
 
 beagletomb (0.1.6-0ubuntu1) natty; urgency=low
 
+<<<<<<< TREE
+=======
   * Update: fixed mediatomb mysql install/configure (Closes: #nnnn)
   * Update: Added dynamic account creation (Closes: #nnnn)
   * Update: changed sql cache to be more elegant and efficient (Closes: #nnnn)
@@ -20,6 +36,7 @@ beagletomb (0.1.6-0ubuntu1) natty; urgen
 
 beagletomb (0.1.6-0ubuntu1) natty; urgency=low
 
+>>>>>>> MERGE-SOURCE
   * Update: changed sql cache to be more elegant and efficient (Closes: #nnnn)
 
  -- Grant Hutchinson <h.g.utchinson@gmail.com>  Wed, 22 Feb 2012 18:59:22 -0500
--- /dev/null
+++ beagletomb-0.1.6/.pc.moved/.quilt_series
@@ -0,0 +1 @@
+series
--- /dev/null
+++ beagletomb-0.1.6/.pc.moved/.quilt_patches
@@ -0,0 +1 @@
+debian/patches
--- /dev/null
+++ beagletomb-0.1.6/.pc.moved/applied-patches
@@ -0,0 +1,2 @@
+debian-changes-0.1.6-0ubuntu1~7
+debian-changes-0.1.6-0ubuntu1~8
--- /dev/null
+++ beagletomb-0.1.6/.pc.moved/.version
@@ -0,0 +1 @@
+2
--- /dev/null
+++ beagletomb-0.1.6/.pc.moved/debian-changes-0.1.6-0ubuntu1~9/changelog
@@ -0,0 +1,31 @@
+beagletomb (0.1.6-0ubuntu1~8) natty; urgency=low
+
+  * Update: Fixed dynamic memory allocation, sync improved (Closes: #nnnn)
+
+ -- Grant Hutchinson <h.g.utchinson@gmail.com>  Mon, 27 Mar 2012 18:59:22 -0500
+
+beagletomb (0.1.6-0ubuntu1~7) natty; urgency=low
+
+  * Update: Fixed dynamic memory allocation, sync improved (Closes: #nnnn)
+
+ -- Grant Hutchinson <h.g.utchinson@gmail.com>  Mon, 27 Mar 2012 18:59:22 -0500
+
+beagletomb (0.1.6-0ubuntu1) natty; urgency=low
+
+  * Update: fixed mediatomb mysql install/configure (Closes: #nnnn)
+  * Update: Added dynamic account creation (Closes: #nnnn)
+  * Update: changed sql cache to be more elegant and efficient (Closes: #nnnn)
+
+ -- Grant Hutchinson <h.g.utchinson@gmail.com>  Wed, 21 Mar 2012 18:59:22 -0500
+
+beagletomb (0.1.6-0ubuntu1) natty; urgency=low
+
+  * Update: changed sql cache to be more elegant and efficient (Closes: #nnnn)
+
+ -- Grant Hutchinson <h.g.utchinson@gmail.com>  Wed, 22 Feb 2012 18:59:22 -0500
+
+beagletomb (0.1.5-0ubuntu1) natty; urgency=low
+
+  * Initial release (Closes: #nnnn)
+
+ -- Grant Hutchinson <h.g.utchinson@gmail.com>  Wed, 22 Feb 2012 18:59:22 -0500
--- /dev/null
+++ beagletomb-0.1.6/.pc.moved/debian-changes-0.1.6-0ubuntu1~9/src/readDB.h
@@ -0,0 +1,56 @@
+/*
+ *  Written By: Grant Hutchinson
+ *  License: GPLv3.
+ *  h.g.utchinson@gmail.com
+ *  Copyright (C) 2012 by Grant Hutchinson
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+
+
+
+#ifndef READDB_H_
+#define READDB_H_
+#define MAX 10000
+#include "songObj.h"
+#include "radioObj.h"
+#include <stdlib.h>
+#include <stdio.h>
+#include <iostream>
+#include <cstring>
+#include <QtSql>
+using namespace std;
+class readDB {
+
+        songObj *Artist, *Album, *Song, *Video, *VidDir;
+        radioObj play_list;
+        char *DBlocation2;
+
+public:
+        QSqlDatabase db2;
+        readDB(const char *dbLocation);
+	songObj* SongFill(int *songSize);
+	songObj* AlbumFill(int *albSize);
+	songObj* ArtistFill(int *artSize);
+        songObj* VidDirFill(int *vidDirSize);
+        songObj* VideoFill(int *vidSize);
+       radioObj RadioFill( int *radSize);
+       void OpenDB();
+	void display(int artSize, int albSize, int songSize);
+	virtual ~readDB();
+};
+
+#endif /* READDB_H_ */
--- /dev/null
+++ beagletomb-0.1.6/.pc.moved/debian-changes-0.1.6-0ubuntu1~9/src/beaglemain.h
@@ -0,0 +1,161 @@
+/*
+ *  Written By: Grant Hutchinson
+ *  License: GPLv3.
+ *  h.g.utchinson@gmail.com
+ *  Copyright (C) 2012 by Grant Hutchinson
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#ifndef BEAGLEMAIN_H
+#define BEAGLEMAIN_H
+
+#include <QMainWindow>
+#include <stdlib.h>
+#include <stdio.h>
+#include "sync.h"
+#include "songObj.h"
+#include "readDB.h"
+#include "mplaycon.h"
+#include "prefdialog.h"
+#include "qmpwidget.h"
+#include "preferences.h"
+#include "about.h"
+#include "playlistobj.h"
+#include "newplaylist.h"
+#include "openplaylist.h"
+#include "radioObj.h"
+namespace Ui {
+class BeagleMain;
+}
+
+class BeagleMain : public QMainWindow
+{
+    Q_OBJECT
+
+public:
+
+    int MenuMode, TitleMode;
+    int albCount, songCount, vidCount, vidDirCount, radCount; ///  count of each item in the list
+    int *curAlbID, *curSongID, *curVidID, *curVidDirID;       ///  unique identifier for current file
+    int plMode;        /// playlist mode : 1 playlist browsing and 2: browsing tracks within playlist
+    int pl_selected;  /// global playlist selection
+     int title_selected;  /// global title selection
+
+    About ab;
+    PrefDialog prefDg;
+    preferences pref, pref2;
+    playlistobj pl;
+    newplaylist newPL;
+    openplaylist openPL;
+    QMPwidget widget;
+    mplayCon mplay;
+    songObj* Artist, *Song, *Album, *VidDir, *Video;
+    radioObj Radio;
+    int artSize, albSize, songSize, vidSize, vidDirSize, radSize;
+
+    bool playlistOpen;
+
+    void RefillRadioPL();
+    QStringList RefillRadList();
+
+    explicit BeagleMain(QWidget *parent = 0);
+   ~BeagleMain();
+
+    void updateMenu(int type);
+
+    void updateTitle();
+
+    void updateAlbMenu(int select);
+    void updateTitle(int select);
+    void Sync(int type);
+
+    bool isRunning();
+
+    void setMainPref(preferences pref);
+    void RefillMainPL();
+    void RefillPLFolder();
+    void startSong(char *FinSong, int selID);
+    void PlaylistPlay(int selID);
+    void closeEvent(QCloseEvent *event);
+
+private slots:
+    void on_SYNC_but_clicked();
+
+    void on_MODE_combo_currentIndexChanged(int index);
+
+    void on_STOP_but_clicked();
+
+    void on_TitleList_doubleClicked(QModelIndex index);
+
+    void on_MenuList_clicked(QModelIndex index);
+
+    void on_VOL_dial_valueChanged(int value);
+
+    void on_SEEK_slider_sliderMoved(int position);
+
+    void on_FWD_but_pressed();
+
+    void on_FWD_but_clicked();
+
+    void on_PAUSE_but_clicked();
+
+
+    void on_actionPreferences_2_activated();
+
+    void on_actionAbout_activated();
+
+    void on_actionSync_activated();
+
+    void on_ADD_but_clicked();
+
+    void on_PlayList_doubleClicked(QModelIndex index);
+
+    void on_REMOVE_but_clicked();
+
+    void on_SAVE_but_clicked();
+
+    void on_OPEN_but_clicked();
+
+    void on_FFWD_but_clicked();
+
+    void on_RRWD_but_clicked();
+
+    void on_UP_but_clicked();
+
+    void on_DOWN_but_clicked();
+
+    void on_PlayList_clicked(QModelIndex index);
+
+    void on_actionDonate_2_triggered();
+
+    void on_ADMIN_but_clicked();
+
+    void on_but_RadAdd_clicked();
+
+    void on_but_RemRad_clicked();
+
+    void on_list_radio_clicked(QModelIndex index);
+
+    void on_list_radio_doubleClicked(QModelIndex index);
+
+private:
+    Ui::BeagleMain *ui;
+    QStringListModel *t_Model;
+    QStringListModel *m_Model;
+    QStringListModel *r_Model;
+};
+
+#endif // BEAGLEMAIN_H
--- /dev/null
+++ beagletomb-0.1.6/.pc.moved/debian-changes-0.1.6-0ubuntu1~9/src/readDB.cpp
@@ -0,0 +1,260 @@
+/*
+ *  Written By: Grant Hutchinson
+ *  License: GPLv3.
+ *  h.g.utchinson@gmail.com
+ *  Copyright (C) 2012 by Grant Hutchinson
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#include "readDB.h"
+
+readDB::readDB(const char *dbLocation) {
+    DBlocation2 = new char[strlen(dbLocation) + 1];
+    strcpy(DBlocation2, dbLocation);
+
+    Artist = new songObj[MAX];
+    for(int i = 0; i<= MAX; i++){
+        Artist[i].set("-",0,0);
+    }
+
+    Album = new songObj[MAX];
+    for(int i = 0; i<= MAX; i++){
+        Album[i].set("-",0,0);
+    }
+    Song = new songObj[MAX];
+    for(int i = 0; i<= MAX; i++){
+        Song[i].set("-", 0, 0);
+    }
+    VidDir = new songObj[MAX];
+    for(int i = 0; i<= MAX; i++){
+        VidDir[i].set("-", 0, 0);
+    }
+    Video = new songObj[MAX];
+    for(int i = 0; i<= MAX; i++){
+        Video[i].set("-", 0, 0);
+    }
+
+}
+
+void readDB::OpenDB(){
+    db2 = QSqlDatabase::addDatabase("QSQLITE");
+    db2.setDatabaseName(DBlocation2);
+
+}
+
+songObj* readDB::SongFill(int *songSize){
+    int count = 0;
+     if(db2.open()){
+       QSqlQuery query(db2);
+
+     query = QString("SELECT * FROM songs");
+
+     while (query.next()){
+         QString QVal1 = query.value(1).toString();
+         QString QVal2 = query.value(2).toString();
+         QString QVal3 = query.value(3).toString();
+
+         if(QVal2.toInt() != 0){
+             string QstrConvert = QVal1.toStdString();
+             char *QVal1Convert;
+             QVal1Convert = new char[QstrConvert.length() + 1];
+             strcpy(QVal1Convert, QstrConvert.c_str());
+             Song[count].set(QVal1Convert, QVal2.toInt(), QVal3.toInt());
+             count++;
+         }
+     }
+     *songSize = count;
+     db2.close();
+    }
+    return Song;
+}
+
+songObj* readDB::AlbumFill(int *albSize){
+
+    int count = 0;
+     if(db2.open()){
+    QSqlQuery query(db2);
+            query = QString("SELECT * FROM albums");
+
+            while (query.next()){
+                QString QVal1 = query.value(1).toString();
+                QString QVal2 = query.value(2).toString();
+                QString QVal3 = query.value(3).toString();
+
+                if(QVal2.toInt() != 0){
+                    string QstrConvert = QVal1.toStdString();
+                    char *QVal1Convert;
+                    QVal1Convert = new char[QstrConvert.length() + 1];
+                    strcpy(QVal1Convert, QstrConvert.c_str());
+                    Album[count].set(QVal1Convert, QVal2.toInt(), QVal3.toInt());
+                    count++;
+                }
+            }
+            *albSize = count;
+             db2.close();
+    }
+    return Album;
+}
+
+songObj* readDB::ArtistFill( int *artSize){
+    OpenDB();
+    int count = 0;
+    if(db2.open()){
+   QSqlQuery query(db2);
+              query = QString("SELECT * FROM artists");
+
+            while (query.next()){
+                QString QVal1 = query.value(1).toString();
+                QString QVal2 = query.value(2).toString();
+                QString QVal3 = query.value(3).toString();
+
+                if(QVal2.toInt() != 0){
+                    string QstrConvert = QVal1.toStdString();
+                    char *QVal1Convert;
+                    QVal1Convert = new char[QstrConvert.length() + 1];
+                    strcpy(QVal1Convert, QstrConvert.c_str());
+                    Artist[count].set(QVal1Convert, QVal2.toInt(), QVal3.toInt());
+                    count++;
+                }
+            }
+            *artSize = count;
+             db2.close();
+    }
+    return Artist;
+}
+songObj* readDB::VidDirFill( int *vidDirSize){
+
+    int count = 0;
+    if(db2.open()){
+   QSqlQuery query(db2);
+    query = QString("SELECT * FROM viddirs");
+
+            while (query.next()){
+                QString QVal1 = query.value(1).toString();
+                QString QVal2 = query.value(2).toString();
+                QString QVal3 = query.value(3).toString();
+
+                if(QVal2.toInt() != 0){
+                    string QstrConvert = QVal1.toStdString();
+                    char *QVal1Convert;
+                    QVal1Convert = new char[QstrConvert.length() + 1];
+                    strcpy(QVal1Convert, QstrConvert.c_str());
+                    VidDir[count].set(QVal1Convert, QVal2.toInt(), QVal3.toInt());
+                    count++;
+                }
+            }
+            *vidDirSize = count;
+             db2.close();
+    }
+    return VidDir;
+}
+songObj* readDB::VideoFill( int *vidSize){
+
+    int count = 0;
+    if(db2.open()){
+   QSqlQuery query(db2);
+             query = QString("SELECT * FROM videos");
+
+            while (query.next()){
+                QString QVal1 = query.value(1).toString();
+                QString QVal2 = query.value(2).toString();
+                QString QVal3 = query.value(3).toString();
+
+                if(QVal2.toInt() != 0){
+                    string QstrConvert = QVal1.toStdString();
+                    char *QVal1Convert;
+                    QVal1Convert = new char[QstrConvert.length() + 1];
+                    strcpy(QVal1Convert, QstrConvert.c_str());
+                    Video[count].set(QVal1Convert, QVal2.toInt(), QVal3.toInt());
+                    count++;
+                }
+            }
+            *vidSize = count;
+             db2.close();
+    }
+    return Video;
+}
+
+radioObj readDB::RadioFill(int *radSize){
+
+    int count = 0;
+    if(db2.open()){
+   QSqlQuery query(db2);
+              query = QString("SELECT * FROM radio");
+
+            while (query.next()){
+                QString QVal1 = query.value(1).toString();
+                QString QVal2 = query.value(2).toString();
+
+
+                if(QVal1.toStdString() != "" && QVal1.toStdString() != "-"){
+                    string QstrConvert = QVal1.toStdString();
+                    char *QVal1Convert;
+                    QVal1Convert = new char[QstrConvert.length() + 1];
+                    strcpy(QVal1Convert, QstrConvert.c_str());
+
+                    string QstrConvert2 = QVal2.toStdString();
+                    char *QVal2Convert;
+                    QVal2Convert = new char[QstrConvert2.length() + 1];
+                    strcpy(QVal2Convert, QstrConvert2.c_str());
+                    play_list.Add(QVal1Convert, QVal2Convert);
+                    count++;
+                }
+             }
+        *radSize = count;
+         db2.close();
+    }
+    return play_list;
+
+
+}
+
+void readDB::display(int artSize, int albSize, int songSize){
+    int choice = 0;
+    bool Exit = 0;
+    while(!Exit){
+        cout << endl;
+	cout << "Which do you want to display?" << endl;
+	cout << "1)Artists 2) Albums 3)Songs 4) exit" << endl;
+	cin >> choice;
+
+	if(choice == 1){
+            for(int i = 0; i<=artSize; i++){
+                cout << Artist[i];
+            }
+            cout << "total artists: " << artSize;
+	}
+	if(choice == 2){
+            for(int i = 0; i<=albSize; i++){
+                cout << Album[i];
+            }
+            cout << "Total Albums: " << albSize;
+	}
+	if(choice == 3){
+            for(int i = 0; i<=songSize; i++){
+                cout << Song[i];
+            }
+            cout << "Total Songs: " << songSize;
+	}
+	if(choice == 4){
+            Exit = 1;
+	}
+    }
+}
+readDB::~readDB() {
+    // TODO Auto-generated destructor stub
+    delete [] DBlocation2;
+}
--- /dev/null
+++ beagletomb-0.1.6/.pc.moved/debian-changes-0.1.6-0ubuntu1~9/src/fileobj.cpp
@@ -0,0 +1,110 @@
+#include "fileobj.h"
+
+fileObj::fileObj()
+{
+
+    objSize = 0;
+    InitSize = 0;
+    initFile(INITSIZE);
+}
+
+fileObj::fileObj(const fileObj &src){
+
+    if(src.objSize > 0){
+        objSize = 0;
+        delete [] fileName;
+        delete [] fileID;
+        delete [] filePar;
+        fileName = new string[src.objSize+1];
+        fileID = new int[src.objSize+1];
+        filePar = new int[src.objSize+1];
+        for(int i=0; i< src.objSize; i++){
+            set(i,src.fileID[i], src.filePar[i], src.fileName[i].c_str());
+        }
+        InitSize = src.InitSize;
+    }
+}
+
+void fileObj::initFile(int initSZ){
+    fileName = new string[initSZ];
+    fileID = new int[initSZ];
+    filePar = new int[initSZ];
+    InitSize = 0;
+    for(int i=0; i< initSZ; i++){
+        setInit(i, 0, 0, "-");
+    }
+}
+
+void fileObj::REinitFile(int oldsize, int newsize){
+    //set the new initialize size
+    InitSize = oldsize+newsize;
+    int tempObjSize = 0;
+    string *nameCopy;
+    int *idCopy, *parCopy;
+    nameCopy = new string[objSize+1];
+    parCopy = new int[objSize+1];
+   idCopy = new int[objSize+1];
+
+    for(int i=0; i< objSize; i++){
+        nameCopy[i] = "-";
+        parCopy[i]= 0;
+        idCopy[i] = 0;
+    }
+
+    for(int i=0; i< objSize; i++){
+        nameCopy[i] = fileName[i];
+        parCopy[i] = filePar[i];
+        idCopy[i] = fileID[i];
+    }
+    delete [] fileName;
+    delete [] fileID;
+    delete [] filePar;
+      initFile(InitSize);
+   /// refill array fileName fileID filePar array
+
+      tempObjSize = objSize;
+      objSize = 0;
+   for(int i=0; i< tempObjSize; i++){
+        set(i,idCopy[i], parCopy[i], nameCopy[i].c_str());
+    }
+
+}
+
+
+fileObj::~fileObj(){
+        delete [] fileName;
+        delete [] fileID;
+        delete [] filePar;
+}
+
+void fileObj::display(){
+    cout << "obj size is " << objSize << endl;
+    for(int i=0; i< objSize; i++){
+        cout << " Num: " << i
+             << " ID: " << getID(i)
+             << " PAR: " << getPar(i)
+             << " NAME: " << getName(i) << endl;
+    }
+}
+
+fileObj& fileObj::operator=(const fileObj& src){
+
+    if(this != &src){
+        if(src.objSize > 0){
+            objSize = 0;
+            delete [] fileName;
+            delete [] fileID;
+            delete [] filePar;
+            fileName = new string[src.objSize+1];
+            fileID = new int[src.objSize+1];
+            filePar = new int[src.objSize+1];
+            for(int i=0; i< src.objSize-1; i++){
+                set(i,src.fileID[i], src.filePar[i], src.fileName[i].c_str());
+            }
+            objSize = src.objSize;
+            InitSize = src.InitSize;
+        }
+    }
+     return *this;
+
+}
--- /dev/null
+++ beagletomb-0.1.6/.pc.moved/debian-changes-0.1.6-0ubuntu1~9/src/fileobj.h
@@ -0,0 +1,91 @@
+#ifndef FILEOBJ_H
+#define FILEOBJ_H
+
+#define INITSIZE 100
+#include <stdlib.h>
+#include <stdio.h>
+#include <iostream>
+#include <cstring>
+using namespace std;
+class fileObj
+{
+public:
+
+    string *fileName;    // Item name
+    int *fileID;         // Item Identification number
+    int *filePar;       // Item Parent number
+    int objSize;        // Number of Items
+    int InitSize;       // Number size before reallocate
+
+    fileObj();
+    fileObj(const fileObj& src);
+    fileObj& operator=(const fileObj& src);
+
+    void initFile(int initSZ);
+    void REinitFile(int oldsize, int newsize);
+    void display();
+    ~fileObj();
+
+    void setName(int item, const char *name){
+        if(item >= 0 && item <= objSize){
+            fileName[item] = name;
+        }
+    }
+    void setID(int item, int newID){
+       if(item >= 0 && item <= objSize){
+            /// fill with new entry
+            fileID[item] = newID;
+       }
+    }
+    void setPar(int item, int newPar){
+       if(item >= 0 && item <= objSize){
+
+            /// fill with new entry
+            filePar[item] = newPar;
+       }
+    }
+    void set(int item, int newid, int newpar, const char *newname){
+        if (objSize >= InitSize-1){
+            REinitFile(InitSize, 1000);
+        }
+        setID(item, newid);
+        setPar(item, newpar);
+        setName(item, newname);
+        objSize++;
+    }
+    void setInit(int item, int newid, int newpar, const char *newname){
+        setID(item, newid);
+        setPar(item, newpar);
+        setName(item, newname);
+        InitSize++;
+    }
+    int getID(int item){
+        return fileID[item];
+    }
+    int getPar(int item){
+        return filePar[item];
+    }
+    char *getName(int item){
+        char *final;
+        final = new char[fileName[item].length()+1];
+        strcpy(final, fileName[item].c_str());
+        return final;
+    }
+    int getSize(){
+        return objSize;
+    }
+    void setInit(int initItem){
+        InitSize = initItem;
+    }
+    int getInit(){
+        return InitSize;
+    }
+
+
+    void delFileName(){
+        objSize = 0;
+        delete [] fileName;
+    }
+};
+
+#endif // FILEOBJ_H
--- /dev/null
+++ beagletomb-0.1.6/.pc.moved/debian-changes-0.1.6-0ubuntu1~9/src/mysqlconn.h
@@ -0,0 +1,67 @@
+/*
+ *  Written By: Grant Hutchinson
+ *  License: GPLv3.
+ *  h.g.utchinson@gmail.com
+ *  Copyright (C) 2012 by Grant Hutchinson
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#ifndef MYSQLCONN_H_
+#define MYSQLCONN_H_
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <cstring>
+#include <iostream>
+#include <string>
+#include <string.h>
+#include "songObj.h"
+#include <QtSql>
+#include "fileobj.h"
+using namespace std;
+
+#define MAXART 1000
+#define MAXALB 1000
+#define MAXSONG 2000
+#define MAXVIDEO 1000
+#define MAXQRY 1000
+class mysqlconn {
+
+public:
+        QSqlDatabase db;
+	mysqlconn(const char *server, const char* user, const char *pass, const char *database);
+
+        fileObj& connectArtist(int artMenu, fileObj& Artist);
+        fileObj& connectAlbum(fileObj& Artist, fileObj& Album);
+        fileObj& connectSong(fileObj& Album, fileObj& Song);
+        fileObj& connectVidDir(int vidMenu, fileObj& VidDir);
+        fileObj& connectVideo(fileObj& VidDir, fileObj& Video);
+
+
+        /*
+	songObj* connectArtist(songObj* Artist, int artMenu, int *mySize);
+	songObj* connectSong(songObj* Album, int *albSize, songObj* Song, int *songSize);
+	songObj* connectAlbum(songObj* Artist, int *artSize, songObj* Album, int *albSize);
+        songObj* connectVidDir(songObj* VidDir, int vidDirMenu, int *vidDirSize);
+        songObj* connectVideo(songObj* VidDir, int *vidDirSize, songObj* Video, int *vidSize);
+        */
+        int connectVidMenu();
+        int connectArtMenu();
+        void display(ostream& os, int pos);
+         virtual ~mysqlconn();
+};
+
+#endif /* MYSQLCONN_H_ */
--- /dev/null
+++ beagletomb-0.1.6/.pc.moved/debian-changes-0.1.6-0ubuntu1~9/src/beaglemain.cpp
@@ -0,0 +1,709 @@
+/*
+ *  Written By: Grant Hutchinson
+ *  License: GPLv3.
+ *  h.g.utchinson@gmail.com
+ *  Copyright (C) 2012 by Grant Hutchinson
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#include "beaglemain.h"
+#include "ui_beaglemain.h"
+
+BeagleMain::BeagleMain(QWidget *parent) :
+    QMainWindow(parent),
+    ui(new Ui::BeagleMain)
+{
+    ui->setupUi(this);
+    Sync(0);
+    ui->MenuList->setEditTriggers(QAbstractItemView::NoEditTriggers);
+    ui->TitleList->setEditTriggers(QAbstractItemView::NoEditTriggers);
+    ui->PlayList->setEditTriggers(QAbstractItemView::NoEditTriggers);
+    ui->list_radio->setEditTriggers(QAbstractItemView::NoEditTriggers);
+    widget.setSeekSlider(ui->SEEK_slider);
+    widget.setVolumeSlider(ui->VOL_dial);
+
+}
+
+/*
+  *  SYNCHRONIZE ALL DATA
+  */
+void BeagleMain::Sync(int type){
+    artSize = 0;
+    albSize = 0;
+    songSize = 0;
+    vidDirSize = 0;
+    vidSize = 0;
+   radSize = 0;
+    if(type == 0){
+        /// init playlist
+        pl.setCount(0);
+        pl.initPL();
+
+        plMode= 0; // set playlist mode to browse
+        playlistOpen = false; // set playlist open
+        /// if SQL file doesn't exist
+        if(pref.initDB() == false){
+            prefDg.show();
+            if (prefDg.exec()==QDialog::Accepted) {
+
+                //create cache directory
+                pref.createCache();
+                pref = prefDg.getPref();
+                //create custom sql db
+                pref.createDB();
+                /// write preferences to sql db
+                pref.writeDB();
+                pref.setInitDB();
+            }
+        }
+
+        else{
+            //// read from sql and fill songObjs
+            readDB rDB(pref.getSQL().c_str());
+            Artist = rDB.ArtistFill(&artSize);
+            Album = rDB.AlbumFill(&albSize);
+            Song = rDB.SongFill(&songSize);
+            VidDir = rDB.VidDirFill(&vidDirSize);
+            Video = rDB.VideoFill(&vidSize);
+            /// read from sql and fill radio obj
+            Radio = rDB.RadioFill(&radSize);
+            Radio.setDB(pref.getSQL());
+            Radio.setSize(radSize);
+            RefillRadioPL();
+        }
+    }
+    else if(type == 1){
+
+        readDB rDB(pref.getSQL().c_str());
+        ///check database for previous radio stations
+        Radio = rDB.RadioFill(&radSize);
+        // read preferences prior to delete
+   //     pref.readDB();
+        pref.deleteDB(pref.getSQL().c_str());
+        ///
+        pref.createDB();
+
+        cout << "syncing.... " << pref.getServ() << "\t" << pref.getPort()<<  endl;
+        /// read from remote mysql write to local sqlite
+        syncMe sy(pref.getServ().c_str(), pref.getUser().c_str(), pref.getPass().c_str(), pref.getTable().c_str(), pref.getSQL().c_str());
+        /// write radio stations
+        Radio.writeDBFill();
+        /// write preferences to sql db
+        pref.writeDB();
+        pref.setInitDB();
+        cout << "reading.... " << endl;
+        /// read from sqlite to songObjs
+        Artist = rDB.ArtistFill(&artSize);
+        Album = rDB.AlbumFill(&albSize);
+        Song = rDB.SongFill(&songSize);
+        VidDir = rDB.VidDirFill(&vidDirSize);
+        Video = rDB.VideoFill(&vidSize);
+        /// read from sql and fill radio obj
+        cout << "syncing radio" << endl;
+        Radio = rDB.RadioFill(&radSize);
+        Radio.setDB(pref.getSQL());
+        Radio.setSize(radSize);
+        RefillRadioPL();
+        cout << "Database synced!" << endl;
+    }
+}
+
+/*
+  *  UPDATE MENU LIST WITH ALL ARTISTS OR ALL ALBUMS
+  */
+void BeagleMain::updateMenu(int type){
+    QStringList curMenu;
+    m_Model = new QStringListModel(this);
+    if(type == 1){
+        /// update with artist
+        for(int i=0; i<= artSize; i++){
+            curMenu << Artist[i].getFile();
+        }
+    }
+    else if(type == 2){
+        /// update with album
+        for(int i=0; i<= albSize; i++){
+            curMenu << Album[i].getFile();
+        }
+    }
+    else if(type == 3){
+        /// update with directories
+        for(int i=0; i<=vidDirSize; i++){
+            curMenu << VidDir[i].getFile();
+        }
+    }
+
+
+    m_Model->setStringList(curMenu);
+    ui->MenuList->setModel(m_Model);
+}
+
+void BeagleMain::setMainPref(preferences my_pref){
+    pref = my_pref;
+}
+
+/*
+  *  UPDATE MENU LIST WITH ALBUMS FROM SELECTED
+  */
+void BeagleMain::updateAlbMenu(int select){
+    albCount = 0;
+    int selID = 0;
+    QStringList curAlb;
+    m_Model = new QStringListModel(this);
+    curAlbID = new int[MAX];
+    selID = Artist[select].getFileID();    /// selected ID
+
+    for(int i=0; i<= albSize; i++){
+        if(Album[i].getFilePar() == selID ){
+            curAlb << Album[i].getFile();
+            curAlbID[albCount] = Album[i].getFileID();
+            albCount++;
+        }
+    }
+
+    m_Model->setStringList(curAlb);
+    ui->MenuList->setModel(m_Model);
+}
+
+/*
+  *  UPDATE TITLE LIST WITH ALL SONGS
+  */
+void BeagleMain::updateTitle(){
+    t_Model = new QStringListModel(this);
+    QStringList songList;
+
+    for(int i = 0; i<= songSize; i++){
+        songList << Song[i].getFile();
+    }
+    t_Model->setStringList(songList);
+    ui->TitleList->setModel(t_Model);
+
+}
+
+/*
+  *  UPDATE TITLE LIST WITH SONGS FROM SELECTED
+  */
+void BeagleMain::updateTitle(int selected){
+    songCount = 0;
+    vidCount = 0;
+    int selID = 0;
+    QStringList curSong;
+    t_Model = new QStringListModel(this);
+    curSongID = new int[MAX];
+    curVidID = new int[MAX];
+    if(MenuMode == 3){     ///  if ALL ALBUM
+        selID = Album[selected].getFileID();
+        for(int i = 0; i<= songSize; i++){
+            if(Song[i].getFilePar() == selID){
+                curSong << Song[i].getFile();
+                curSongID[songCount] = Song[i].getFileID();
+                songCount++;
+            }
+        }
+    }
+    else if(MenuMode == 4){    ////// if VIDEO DIR MODE
+        selID = VidDir[selected].getFileID();
+        for(int i = 0; i<= vidSize; i++){
+            if(Video[i].getFilePar() == selID){
+                curSong << Video[i].getFile();
+                curVidID[vidCount] = Video[i].getFileID();
+                vidCount++;
+            }
+        }
+    }
+    else{   /// IF ALBUM DIR MODE
+        selID = curAlbID[selected];
+        for(int i = 0; i<= songSize; i++){
+            if(Song[i].getFilePar() == selID){
+                curSong << Song[i].getFile();
+                curSongID[songCount] = Song[i].getFileID();
+                songCount++;
+            }
+        }
+    }
+
+    t_Model->setStringList(curSong);
+    ui->TitleList->setModel(t_Model);
+
+}
+void BeagleMain::startSong(char *FinSong, int selID){
+
+    char * strBuffer;
+    strBuffer= new char[100];
+    sprintf(strBuffer, "http://%s:%s/content/media/object_id/%d/res_id/0", pref.getServ().c_str(), pref.getPort().c_str(), selID);
+    ui->SONG_lbl->setText((QString)FinSong);
+    widget.show();
+    widget.start(QStringList(strBuffer));
+}
+/*
+  * refill playlist list with playlist model from playlist object
+  */
+void BeagleMain::RefillMainPL(){
+    QStringList updatedList;
+   t_Model = new QStringListModel(this);
+    updatedList = pl.RefillPlaylist();
+    t_Model->setStringList(updatedList);
+    ui->PlayList->setModel(t_Model);
+}
+
+/*
+  * refill playlist list with playlist model from playlist user Folder
+  */
+void BeagleMain::RefillPLFolder(){
+    QStringList updatedList;
+   t_Model = new QStringListModel(this);
+    updatedList = pl.listDirectories(pl.getFullLocation().c_str());
+    t_Model->setStringList(updatedList);
+    ui->PlayList->setModel(t_Model);
+}
+
+void BeagleMain::PlaylistPlay(int selID){
+        char* FinSong;
+        for(int i = 0; i<= pl.getCount(); i++){
+            if(pl.getTrackID(i) == selID){
+                FinSong = new char[strlen(pl.getTrackName(i).c_str())+1];
+                strcpy(FinSong,pl.getTrackName(i).c_str());
+            }
+        }
+        // start song
+        startSong(FinSong, selID);
+    }
+/*
+  * MEM CLEANUP
+  */
+BeagleMain::~BeagleMain()
+{
+    delete ui;
+    delete [] Artist;
+    delete [] Album;
+    delete [] Song;
+    delete [] Video;
+    delete [] VidDir;
+}
+
+/*
+  *When Sync Button is pressed
+  */
+void BeagleMain::on_SYNC_but_clicked()
+{
+    Sync(1);
+}
+
+/*
+  *When Mode combo button is changed, change the mode, update lists
+  */
+void BeagleMain::on_MODE_combo_currentIndexChanged(int index)
+{
+    if(index == 1){   //  update lists with artists
+        updateMenu(1);
+        MenuMode=1;
+    }
+    else if(index == 2){  // update lists with albums
+        updateMenu(2);
+        MenuMode=3;
+    }
+    else if(index == 3){  // update lists with songs
+        updateTitle();
+        TitleMode = 1;
+    }
+    else if(index == 4){  // update lists with vid directories
+        MenuMode = 4;
+        updateMenu(3);
+    }
+}
+
+/*
+  *When Stop Button is pressed
+  */
+void BeagleMain::on_STOP_but_clicked()
+{
+    widget.stop();
+}
+
+/*
+  *When a track is double clicked from the TitleList, depending on which mode we are in
+  */
+void BeagleMain::on_TitleList_doubleClicked(QModelIndex index)
+{
+    int selID = 0;
+    int selected = 0;
+    selected = ui->TitleList->currentIndex().row();
+    int FinParentID = 0;
+    char *FinSong;
+    char *FinParent;
+
+    FinSong = new char[100];
+    FinParent = new char[100];
+
+    if(MenuMode == 2 || MenuMode == 3){
+        selID = curSongID[selected];
+        FinSong = checkSongObjByID(selID, Song, songSize);
+        FinParentID = checkSongObjParByID(selID,Song, songSize);
+        FinParent = checkSongObjByID(FinParentID, Song, songSize);
+    }
+    else if(MenuMode == 4){
+        selID = curVidID[selected];
+        FinSong = checkSongObjByID(selID, Video, vidSize);
+        FinParentID = checkSongObjParByID(selID,Video, vidSize);
+        FinParent = checkSongObjByID(FinParentID, Video, vidSize);
+    }
+    else{
+        selID = Song[selected].getFileID();
+        FinSong = checkSongObjByID(selID, Song, songSize);
+        FinParentID = checkSongObjParByID(selID,Song, songSize);
+        FinParent = checkSongObjByID(FinParentID, Song, songSize);
+    }
+    // start song
+    startSong(FinSong, selID);
+}
+
+/*
+  *When the Main list is selected, depending on which mode we are in
+  */
+void BeagleMain::on_MenuList_clicked(QModelIndex index)
+{
+    int selected = ui->MenuList->currentIndex().row();
+
+    if(MenuMode == 1){
+        updateAlbMenu(selected);
+        MenuMode =2;
+    }
+    else if(MenuMode == 4){
+        updateTitle(selected);
+    }
+    else{
+        updateTitle(selected);
+    }
+}
+/*
+  * When vol dial has changed
+  */
+void BeagleMain::on_VOL_dial_valueChanged(int value)
+{
+
+}
+
+/*
+  * when seek slider has moved
+  */
+void BeagleMain::on_SEEK_slider_sliderMoved(int position)
+{
+    //   widget.seek((double)position, 0);
+}
+
+/*
+  * When play button is pressed and held, seek
+  */
+void BeagleMain::on_FWD_but_pressed()
+{
+
+    int curTime = ui->SEEK_slider->value();
+
+    int FutTime = curTime + 10;
+    widget.seek((double)FutTime, curTime);
+}
+
+/*
+  * When Play button clicked, play
+  */
+void BeagleMain::on_FWD_but_clicked()
+{
+    widget.play();
+}
+/*
+  * When Pause button clicked, pause
+  */
+void BeagleMain::on_PAUSE_but_clicked()
+{
+    widget.pause();
+}
+
+/*
+  * When preferences menu item selected, open preference window
+  */
+void BeagleMain::on_actionPreferences_2_activated()
+{
+    pref.readDB();
+    prefDg.setPref(pref);
+    prefDg.show();
+    if (prefDg.exec()==QDialog::Accepted) {
+        pref = prefDg.getPref();
+        //delete custom sql db
+      //  pref.deleteDB(pref.getSQL().c_str());
+        //create custom sql db
+      //  pref.createDB();
+        /// write preferences to sql db
+        pref.writeDB();
+    }
+}
+
+/*
+  * When About menu item selected, open about dialog
+  */
+void BeagleMain::on_actionAbout_activated()
+{
+    ab.show();
+    if(ab.exec()==QDialog::Accepted) {
+        ab.close();
+    }
+}
+
+/*
+  * When Sync Button is selected , sync
+  */
+void BeagleMain::on_actionSync_activated()
+{
+    Sync(1);
+}
+
+/*
+  * When Add button is selected, get selected item (depending on mode),
+  * add to list, refill list
+  */
+void BeagleMain::on_ADD_but_clicked()
+{
+    int selID = 0;
+    int selected = 0;
+    char * strBuffer;
+    strBuffer= new char[100];
+    selected = ui->TitleList->currentIndex().row();
+
+    if(MenuMode == 2 || MenuMode == 3){
+         selID = curSongID[selected];
+      strBuffer=checkSongObjByID(selID, Song, songSize);
+    }
+    else if(MenuMode == 4){
+         selID = curVidID[selected];
+       strBuffer=checkSongObjByID(selID, Video, vidSize);
+    }
+    else{
+        selID = Song[selected].getFileID();
+        strBuffer=checkSongObjByID(selID, Song, songSize);
+    }
+    pl.AddTo(selID, strBuffer);
+    RefillMainPL();
+}
+
+
+/*
+  * when the playlist list is doubleclick get which item we've selected and play it
+  */
+void BeagleMain::on_PlayList_doubleClicked(QModelIndex index)
+{
+
+
+    int selected;
+    selected = ui->PlayList->currentIndex().row();
+    int selID = 0;
+    char *FinSong;
+
+       if(plMode == 1){
+           pl.readPLfile((pref.getPlaylistDir() + pl.getPLFolder(selected)).c_str());   /// edit with selected playlist currently defaulting
+            RefillMainPL();
+            playlistOpen = true;
+            plMode = 2;
+       }
+       else{
+           pl_selected = 0;
+           pl_selected = ui->PlayList->currentIndex().row();
+           selID = pl.getTrackID(pl_selected);
+           PlaylistPlay(selID);
+       }
+
+    /// thread adding future
+    /*
+    if(plMode == 1){
+        pl.readPLfile((pref.getPlaylistDir() + pl.getPLFolder(selected)).c_str());   /// edit with selected playlist currently defaulting
+         RefillMainPL();
+         playlistOpen = true;
+         plMode = 2;
+    }
+    else  if(plMode == 2){
+
+        pl_selected = 0;
+        pl_selected = ui->PlayList->currentIndex().row();
+        mplay.set(pl, pref, pl_selected);
+        mplay.run();
+        plMode = 3;
+    }
+    else if(plMode == 3){
+
+         pl_selected = 0;
+         pl_selected = ui->PlayList->currentIndex().row();
+         mplay.set(pl, pref, pl_selected);
+         mplay.run();
+         plMode = 2;
+     }*/
+}
+
+/*
+  * When Remove button is clicked
+  */
+void BeagleMain::on_REMOVE_but_clicked()
+{
+    int selected = 0;
+    pl.RemoveFrom(pl_selected);
+    RefillMainPL();
+}
+
+
+
+void BeagleMain::on_SAVE_but_clicked()
+{
+    string fileName, fileLocate;
+    newPL.show();
+    if(newPL.exec()==QDialog::Accepted){
+        if(newPL.plExists()){
+            fileName = newPL.getFile();
+             fileLocate = newPL.getLocate();
+             pl.setFullLocation(fileName, fileLocate);
+             pl.writePLfile();
+        }
+    }
+}
+
+void BeagleMain::on_OPEN_but_clicked()
+{
+    plMode = 0;
+    string fileName, fileLocate;
+    fileName = "";
+    fileLocate = "";
+
+        openPL.show();
+        if(openPL.exec()==QDialog::Accepted){
+           if(openPL.plExists()){
+               fileName = openPL.getFile();
+               fileLocate = openPL.getLocate();
+                 pl.setFullLocation(fileName, fileLocate);
+           }
+        }
+
+         /// list .pl files in preferreed directory
+        RefillPLFolder();
+        plMode = 1;
+
+}
+
+void BeagleMain::on_FFWD_but_clicked()
+{
+    int selID = 0;
+
+    pl_selected++;
+     selID = pl.getTrackID(pl_selected);
+    PlaylistPlay(selID);
+
+}
+
+
+void BeagleMain::on_RRWD_but_clicked()
+{
+       int selID = 0;
+    pl_selected--;
+     selID = pl.getTrackID(pl_selected);
+    PlaylistPlay(selID);
+}
+
+void BeagleMain::on_UP_but_clicked()
+{
+    pl.Move(2, pl_selected);
+    pl_selected--;
+    RefillMainPL();
+}
+
+void BeagleMain::on_DOWN_but_clicked()
+{
+    pl.Move(1, pl_selected);
+    pl_selected++;
+    RefillMainPL();
+}
+
+void BeagleMain::on_PlayList_clicked(QModelIndex index)
+{
+    pl_selected = ui->PlayList->currentIndex().row();
+}
+
+ void BeagleMain::closeEvent(QCloseEvent *event){
+
+     widget.close();
+ }
+
+void BeagleMain::on_actionDonate_2_triggered()
+{
+    QDesktopServices::openUrl(QUrl("https://flattr.com/profile/hutchgrant", QUrl::TolerantMode));
+}
+
+void BeagleMain::on_ADMIN_but_clicked()
+{
+    char mediatombAdd[100];
+    sprintf(mediatombAdd, "http://%s:%s", pref.getServ().c_str(), pref.getPort().c_str());
+    QDesktopServices::openUrl(QUrl(mediatombAdd, QUrl::TolerantMode));
+}
+
+void BeagleMain::on_but_RadAdd_clicked()
+{
+    QString Radio_url;
+    QString Radio_name;
+
+    Radio_url = ui->entry_radURL->text();
+    Radio_name = ui->entry_radName->text();
+
+    Radio.Add(Radio_name.toStdString(),Radio_url.toStdString());
+    radSize++;
+
+    Radio.writeDB();
+    RefillRadioPL();
+}
+
+void BeagleMain::on_but_RemRad_clicked()
+{
+    int pos = 0;
+    string pl_ItemName;
+    pos = ui->list_radio->currentIndex().row();
+    pl_ItemName = Radio.getName(pos);
+    Radio.Remove(pl_ItemName, pos);
+    readDB rDB(pref.getSQL().c_str());
+    Radio = rDB.RadioFill(&radSize);
+    RefillRadioPL();
+}
+
+void BeagleMain::on_list_radio_clicked(QModelIndex index)
+{
+
+}
+
+/*
+  * refill playlist list with playlist model from playlist object
+  */
+void BeagleMain::RefillRadioPL(){
+    QStringList updatedList;
+   r_Model = new QStringListModel(this);
+    updatedList = Radio.RefillPlaylist();
+    r_Model->setStringList(updatedList);
+    ui->list_radio->setModel(r_Model);
+
+}
+
+void BeagleMain::on_list_radio_doubleClicked(QModelIndex index)
+{
+    int pos =0;
+    pos = ui->list_radio->currentIndex().row();
+    string finalUrl, finalName;
+    finalUrl = Radio.getUrl(pos);
+    finalName = Radio.getName(pos);
+    ui->SONG_lbl->setText((QString)finalName.c_str());
+    widget.show();
+    widget.start(QStringList(finalUrl.c_str()));
+}
--- /dev/null
+++ beagletomb-0.1.6/.pc.moved/debian-changes-0.1.6-0ubuntu1~7/beagletomb.pro
@@ -0,0 +1,69 @@
+#-------------------------------------------------
+#
+# Project created by QtCreator 2012-01-24T14:56:37
+#
+#-------------------------------------------------
+
+QT       += core gui
+QT       += sql
+
+TARGET = beagletomb
+TEMPLATE = app
+QT += network \
+        opengl
+
+
+SOURCES += src/main.cpp\
+    src/beaglemain.cpp \
+    src/sync.cpp \
+    src/songObj.cpp \
+    src/readDB.cpp \
+    src/qmpwidget.cpp \
+    src/preferences.cpp \
+    src/prefdialog.cpp \
+    src/mysqlconn.cpp \
+    src/mplaycon.cpp \
+    src/about.cpp \
+    src/newplaylist.cpp \
+    src/playlistobj.cpp \
+    src/openplaylist.cpp \
+    src/radioObj.cpp
+
+HEADERS  += src/beaglemain.h \
+    src/sync.h \
+    src/songObj.h \
+    src/readDB.h \
+    src/qmpyuvreader.h \
+    src/qmpwidget.h \
+    src/preferences.h \
+    src/prefdialog.h \
+    src/mysqlconn.h \
+    src/mplaycon.h \
+    src/about.h \
+    src/newplaylist.h \
+    src/playlistobj.h \
+    src/sync.h \
+    src/songObj.h \
+    src/readDB.h \
+    src/qmpyuvreader.h \
+    src/qmpwidget.h \
+    src/preferences.h \
+    src/prefdialog.h \
+    src/playlistobj.h \
+    src/newplaylist.h \
+    src/mysqlconn.h \
+    src/mplaycon.h \
+    src/beaglemain.h \
+    src/about.h \
+    src/openplaylist.h \
+    src/radioObj.h
+
+FORMS    += \
+    src/prefdialog.ui \
+    src/about.ui \
+    src/newplaylist.ui \
+    src/beaglemain.ui \
+    src/openplaylist.ui
+
+RESOURCES += \
+    images/BTres.qrc
--- /dev/null
+++ beagletomb-0.1.6/.pc.moved/debian-changes-0.1.6-0ubuntu1~7/changelog
@@ -0,0 +1,5 @@
+beagletomb (0.1.5-0ubuntu1) natty; urgency=low
+
+  * Initial release (Closes: #nnnn)  <nnnn is the bug number of your ITP>
+
+ -- Grant Hutchinson <h.g.utchinson@gmail.com>  Wed, 22 Feb 2012 18:59:22 -0500
--- /dev/null
+++ beagletomb-0.1.6/.pc.moved/debian-changes-0.1.6-0ubuntu1~7/src/sync.cpp
@@ -0,0 +1,354 @@
+/*
+ *  Written By: Grant Hutchinson
+ *  License: GPLv3.
+ *  h.g.utchinson@gmail.com
+ *  Copyright (C) 2012 by Grant Hutchinson
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#include "sync.h"
+using namespace std;
+syncMe::syncMe(const char *server, const char *user, const char *pass,
+               const char *table, const char *dbLocation) {
+    string home = getenv("HOME");
+     string temp_pref = home + TEMPSYNCPREF;
+   db = QSqlDatabase::addDatabase("QSQLITE", "connection");
+   db.setDatabaseName(temp_pref.c_str());
+
+
+   if(control(server, user, pass, table, dbLocation)==0){
+        // future error popup
+   }
+
+
+}
+
+void syncMe::deleteDB(const char *dbLocation) {
+    char FinalLink[150];
+    sprintf(FinalLink, "rm %s ", dbLocation);
+    system(FinalLink);
+}
+
+void syncMe::OpenDB(){
+
+}
+
+void syncMe::createDB(const char *dbLocation) {
+    string finalQry[7];
+    finalQry[0] = "create table Artists(key INTEGER PRIMARY KEY,Artist TEXT,ArtistID integer, ArtistPar integer) ";
+    finalQry[1] = "create table Albums(key INTEGER PRIMARY KEY,Album TEXT,AlbumID integer, AlbumPar integer)";
+    finalQry[2] = "create table Songs(key INTEGER PRIMARY KEY,Song TEXT,SongID integer, SongPar integer)";
+    finalQry[3] = "create table Videos(key INTEGER PRIMARY KEY,Video TEXT,VideoID integer, VideoPar integer)";
+    finalQry[4] = "create table VidDirs(key INTEGER PRIMARY KEY,VidDir TEXT,VidDirID integer, VidDirPar integer)";
+    finalQry[5] = "create table pref(key INTEGER PRIMARY KEY,usr TEXT,PASS TEXT,SERVER TEXT,PRT TEXT,SQLTABLE TEXT,SQL TEXT,PLAYLISTDIR TEXT)";
+    finalQry[6] = "create table radio(id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL DEFAULT (0),name TEXT NOT NULL,url TEXT NOT NULL)";
+    for(int i=0; i<7; i++){
+        writeMe(finalQry[i]);
+    }
+}
+
+int syncMe::control(const char *server, const char *user, const char *pass,
+                    const char *table, const char *dbLocation) {
+    DBLocation = dbLocation;
+    int artMenu, vidDirMenu; /// main Artist Menu ID
+    int artSize, albSize, songSize, vidSize, vidDirSize; /// sizes of each Object array
+
+    artMenu = 0, artSize = 0, albSize = 0 ,songSize = 0;
+    vidSize = 0, vidDirSize = 0;
+
+    /// init Objects
+    songObj *Artist = NULL, *Album = NULL, *Song = NULL, *VidDir = NULL, *Video = NULL;
+    songObj *newSong, *newAlbum, *newArtist;
+    songObj *newVideo, *newVidDir;
+    //attempt to delete previous DB
+    deleteDB(dbLocation);
+
+    //create new DB
+    createDB(dbLocation);
+
+    /// init mysqlObject
+    mysqlconn ms(server, user, pass, table);
+
+    // get main artist menu
+    artMenu = ms.connectArtMenu();
+    vidDirMenu = ms.connectVidMenu();
+    // get from mysql each artist,album,song - store and return objects
+    newArtist = ms.connectArtist(Artist, artMenu, &artSize);
+    newAlbum = ms.connectAlbum(newArtist, &artSize, Album, &albSize);
+    newSong = ms.connectSong(newAlbum, &albSize, Song, &songSize);
+    newVidDir = ms.connectVidDir(VidDir, vidDirMenu, &vidDirSize);
+    newVideo = ms.connectVideo(newVidDir, &vidDirSize, Video, &vidSize);
+    if(artMenu ==0){
+        cout << "empty database or invalid login" << endl;
+        return 0;
+    }
+    else{
+    ///  sync artist,album,song objects to the local sql database
+    artistWrite(newArtist, artSize);
+    albumWrite(newAlbum, albSize);
+    songWrite(newSong, songSize);
+    vidDirWrite(newVidDir, vidDirSize);
+    videoWrite(newVideo, vidSize);
+    return 1;
+    }
+}
+
+void syncMe::artistWrite(songObj* Artist, int artSize){
+    int  pos = 0, posMax = 0, counter = 0, countRemind = 0;
+
+    string str2;
+    counter = getMaxPos(artSize);
+    posMax = counter;
+
+    for (int m = 0; m <= (artSize / counter); m++) {
+        countRemind = 0;
+        stringstream os;
+        for (int i = pos; i <= posMax; i++) {
+            str2 = Artist[i].getFile();
+
+            str2.erase(remove(str2.begin(), str2.end(), '\"'), str2.end());
+            Artist[i].setFile((char *)str2.c_str());
+            //           cout << str2 << endl;
+            if (i != posMax && countRemind == 0) {
+                os << " INSERT INTO artists (Artist,ArtistID,ArtistPar) " <<
+                      "SELECT \"" << Artist[i].getFile() << "\" AS \"" << "Artist" << "\", \""
+                   <<  Artist[i].getFileID() << "\" AS \"" << "ArtistID" << "\", \""
+                   << Artist[i].getFilePar() << "\" AS \"" << "ArtistPar" << "\"";
+                //             cout << os;
+                countRemind++;
+            }
+            if (i != posMax && countRemind != 0) {
+                os << " UNION SELECT \""<< Artist[i].getFile()<<"\",\""<< Artist[i].getFileID()<<"\",\""<<Artist[i].getFilePar()<<"\"";
+
+            } else if (i == posMax && countRemind != 0) {
+                os << ";";
+            }
+        }
+        str2 = os.str();
+        writeMe(str2);
+        posMax += counter;
+        pos += counter;
+
+        if (m == (artSize / counter) - 1) {
+            posMax = pos + artSize - ((artSize / counter)
+                                      * counter);
+        }
+    }
+}
+
+void syncMe::albumWrite(songObj* Album, int albSize){
+    int  pos = 0, posMax = 0, counter = 0, countRemind = 0;
+
+    string str2;
+    counter = getMaxPos(albSize);
+    posMax = counter;
+
+    for (int m = 0; m <= (albSize / counter); m++) {
+        countRemind = 0;
+        stringstream os;
+        for (int i = pos; i <= posMax; i++) {
+            str2 = Album[i].getFile();
+
+            str2.erase(remove(str2.begin(), str2.end(), '\"'), str2.end());
+            Album[i].setFile((char *)str2.c_str());
+            //         cout << str2 << endl;
+            if (i != posMax && countRemind == 0) {
+                os << " INSERT INTO albums (Album,AlbumID,AlbumPar) " <<
+                      "SELECT \"" << Album[i].getFile() << "\" AS \"" << "Album" << "\", \""
+                   <<  Album[i].getFileID() << "\" AS \"" << "AlbumID" << "\", \""
+                   << Album[i].getFilePar() << "\" AS \"" << "AlbumPar" << "\"";
+                //           cout << os;
+                countRemind++;
+            }
+            if (i != posMax && countRemind != 0) {
+                os << " UNION SELECT \""<< Album[i].getFile()<<"\",\""<< Album[i].getFileID()<<"\",\""<<Album[i].getFilePar()<<"\"";
+
+            } else if (i == posMax && countRemind != 0) {
+                os << ";";
+            }
+        }
+        str2 = os.str();
+        writeMe(str2);
+        posMax += counter;
+        pos += counter;
+
+        if (m == (albSize / counter) - 1) {
+            posMax = pos + albSize - ((albSize / counter)
+                                      * counter);
+        }
+    }
+}
+void syncMe::songWrite(songObj* Song, int songSize){
+    int  pos = 0, posMax = 0, counter = 0, countRemind = 0;
+
+    string str2;
+    counter = getMaxPos(songSize);
+    posMax = counter;
+
+    for (int m = 0; m <= (songSize / counter); m++) {
+        countRemind = 0;
+        stringstream os;
+        for (int i = pos; i <= posMax; i++) {
+            str2 = Song[i].getFile();
+
+            str2.erase(remove(str2.begin(), str2.end(), '\"'), str2.end());
+            Song[i].setFile((char *)str2.c_str());
+            //         cout << str2 << endl;
+            if (i != posMax && countRemind == 0) {
+                os << " INSERT INTO songs (Song,SongID,SongPar) " <<
+                      "SELECT \"" << Song[i].getFile() << "\" AS \"" << "Song" << "\", \""
+                   <<  Song[i].getFileID() << "\" AS \"" << "SongID" << "\", \""
+                   << Song[i].getFilePar() << "\" AS \"" << "SongPar" << "\"";
+                //           cout << os;
+                countRemind++;
+            }
+            if (i != posMax && countRemind != 0) {
+                os << " UNION SELECT \""<< Song[i].getFile()<<"\",\""<< Song[i].getFileID()<<"\",\""<<Song[i].getFilePar()<<"\"";
+
+            } else if (i == posMax && countRemind != 0) {
+                os << ";";
+            }
+        }
+        str2 = os.str();
+        writeMe(str2);
+        posMax += counter;
+        pos += counter;
+
+        if (m == (songSize / counter) - 1) {
+            posMax = pos + songSize - ((songSize / counter)
+                                       * counter);
+        }
+    }
+}
+
+void syncMe::vidDirWrite(songObj* vidDir, int vidDirSize){
+    int  pos = 0, posMax = 0, counter = 0, countRemind = 0;
+
+    string str2;
+    counter = getMaxPos(vidDirSize);
+    posMax = counter;
+
+    for (int m = 0; m <= (vidDirSize / counter); m++) {
+        countRemind = 0;
+        stringstream os;
+        for (int i = pos; i <= posMax; i++) {
+            str2 = vidDir[i].getFile();
+
+            str2.erase(remove(str2.begin(), str2.end(), '\"'), str2.end());
+            vidDir[i].setFile((char *)str2.c_str());
+            //       cout << str2 << endl;
+            if (i != posMax && countRemind == 0) {
+                os << " INSERT INTO viddirs (VidDir,VidDirID,VidDirPar) " <<
+                      "SELECT \"" << vidDir[i].getFile() << "\" AS \"" << "VidDir" << "\", \""
+                   <<  vidDir[i].getFileID() << "\" AS \"" << "VidDirID" << "\", \""
+                   << vidDir[i].getFilePar() << "\" AS \"" << "VidDirPar" << "\"";
+                //          cout << os;
+                countRemind++;
+            }
+            if (i != posMax && countRemind != 0) {
+                os << " UNION SELECT \""<< vidDir[i].getFile()<<"\",\""<< vidDir[i].getFileID()<<"\",\""<<vidDir[i].getFilePar()<<"\"";
+
+            } else if (i == posMax && countRemind != 0) {
+                os << ";";
+            }
+        }
+        str2 = os.str();
+        writeMe(str2);
+        posMax += counter;
+        pos += counter;
+
+        if (m == (vidDirSize / counter) - 1) {
+            posMax = pos + vidDirSize - ((vidDirSize / counter)
+                                         * counter);
+        }
+    }
+}
+
+
+void syncMe::videoWrite(songObj* Video, int vidSize){
+    int  pos = 0, posMax = 0, counter = 0, countRemind = 0;
+
+    string str2;
+    counter = getMaxPos(vidSize);
+    posMax = counter;
+
+    for (int m = 0; m <= (vidSize / counter); m++) {
+        countRemind = 0;
+        stringstream os;
+        for (int i = pos; i <= posMax; i++) {
+            str2 = Video[i].getFile();
+
+            str2.erase(remove(str2.begin(), str2.end(), '\"'), str2.end());
+            Video[i].setFile((char *)str2.c_str());
+            //        cout << str2 << endl;
+            if (i != posMax && countRemind == 0) {
+                os << " INSERT INTO videos (Video,VideoID,VideoPar) " <<
+                      "SELECT \"" << Video[i].getFile() << "\" AS \"" << "Video" << "\", \""
+                   <<  Video[i].getFileID() << "\" AS \"" << "VideoID" << "\", \""
+                   << Video[i].getFilePar() << "\" AS \"" << "VideoPar" << "\"";
+                //           cout << os;
+                countRemind++;
+            }
+            if (i != posMax && countRemind != 0) {
+                os << " UNION SELECT \""<< Video[i].getFile()<<"\",\""<< Video[i].getFileID()<<"\",\""<<Video[i].getFilePar()<<"\"";
+
+            } else if (i == posMax && countRemind != 0) {
+                os << ";";
+            }
+        }
+        str2 = os.str();
+        writeMe(str2);
+        posMax += counter;
+        pos += counter;
+
+        if (m == (vidSize / counter) - 1) {
+            posMax = pos + vidSize - ((vidSize / counter)
+                                      * counter);
+        }
+    }
+}
+
+void syncMe::writeMe(string qry){
+
+       if(db.open()){
+           QSqlQuery myQry(db);
+           myQry.prepare(qry.c_str());
+           myQry.exec();
+           db.close();
+       }
+}
+
+
+int syncMe::getMaxPos(int count) {
+    int posMax;
+
+    if (count < 400 && count > 100) {
+        posMax = 100;
+    } else if (count < 100 && count > 20) {
+        posMax = 10;
+    } else if (count < 20) {
+        posMax = 5;
+    } else if (count < 20 && count > 10) {
+        posMax = 1;
+    } else {
+        posMax = 200;
+    }
+    return posMax;
+}
+
+syncMe::~syncMe() {
+   // db.close();
+}
--- /dev/null
+++ beagletomb-0.1.6/.pc.moved/debian-changes-0.1.6-0ubuntu1~7/src/mysqlconn.cpp
@@ -0,0 +1,498 @@
+/*
+ *  Written By: Grant Hutchinson
+ *  License: GPLv3.
+ *  h.g.utchinson@gmail.com
+ *  Copyright (C) 2012 by Grant Hutchinson
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#include "mysqlconn.h"
+using namespace std;
+
+mysqlconn::mysqlconn(const char *server, const char* user, const char *pass, const char *table) {
+
+    // connect to the database with the details attached.
+    db = QSqlDatabase::addDatabase("QMYSQL");
+    db.setHostName(server);
+    db.setDatabaseName(table);
+    db.setUserName(user);
+    db.setPassword(pass);
+}
+
+songObj* mysqlconn::connectAlbum(songObj* Artist, int *artSize, songObj* Album, int *albSize){
+    bool Myexit = false;
+    int albCount = 0;
+    int QryCount = 0;
+    char *myQry = NULL;
+    int albQryCount = 0;
+    int curID;
+
+    *albSize = MAXSONG;
+    Album = new songObj[MAXALB];
+
+    for(int i= 0 ; i <= MAXALB; i++){
+        Album[i].set("-", 0, 0);
+    }
+
+    while(Myexit != true){
+
+	if (!myQry) {
+            myQry = new char[MAXQRY];
+	}
+        curID = Artist[QryCount].getFileID();
+        if(curID == 0){
+            Myexit = 1;
+        }
+
+
+        sprintf(myQry, "SELECT * FROM mt_cds_object WHERE parent_id = %d",
+                curID );
+
+        // connect to the mysql database
+
+        if(db.open()){
+        QSqlQuery query(db);
+        query = QString(myQry);
+
+        while (query.next()){
+
+
+            QString QVal = query.value(0).toString();
+            QString QVal1 = query.value(1).toString();
+            QString QVal2 = query.value(2).toString();
+            QString QVal3 = query.value(3).toString();
+            QString QVal4 = query.value(4).toString();
+            QString QVal5 = query.value(5).toString();
+
+            ///////*****  Query for Album rows using artist
+            if(QVal4.toStdString().compare("object.container.album.musicAlbum") == 0){
+                if (QVal2.toInt() == curID) {
+                    albCount++;
+                    string Qstr5Convert = QVal5.toStdString();
+                    char *QVal5Convert;
+                    QVal5Convert = new char[Qstr5Convert.length() + 1];
+                    strcpy(QVal5Convert, Qstr5Convert.c_str());
+                    Album[albCount].set(QVal5Convert, QVal.toInt(), QVal2.toInt());
+                }
+            }
+        }
+        *albSize = albCount;
+        QryCount++;
+        if (QryCount == *artSize) {
+            Myexit = true;
+        }
+         db.close();
+        }
+        else{
+            cout << "error couldn't connect to mysql" << endl;
+        }
+    }
+    return Album;
+}
+
+songObj* mysqlconn::connectSong(songObj* Album, int *albSize, songObj* Song, int *songSize){
+
+    int songCount = 0;
+    int QryCount = 0;
+    char *myQry = NULL;
+    int curID = 0;
+    bool Myexit = false;
+
+    *songSize = MAXSONG;
+    Song = new songObj[MAXSONG];
+
+    for(int i= 0 ; i <= MAXSONG; i++){
+        Song[i].set("-", 0, 0);
+    }
+
+
+    while (Myexit != true){
+
+
+	if (!myQry) {
+            myQry = new char[MAXQRY];
+        }
+
+	curID = Album[QryCount+1].getFileID();
+	if(curID == 0){
+            Myexit = true;
+        }
+
+
+        sprintf(myQry, "SELECT * FROM mt_cds_object WHERE parent_id = %d",
+                curID);
+        if(db.open()){
+        QSqlQuery query(db);
+        query = QString(myQry);
+
+        while (query.next()){
+
+
+            QString QVal = query.value(0).toString();
+            QString QVal1 = query.value(1).toString();
+            QString QVal2 = query.value(2).toString();
+            QString QVal3 = query.value(3).toString();
+            QString QVal4 = query.value(4).toString();
+            QString QVal5 = query.value(5).toString();
+
+
+            ///////*****  Query for Songs
+            if (QVal2.toInt() == curID) {
+                songCount++;
+                string QstrConvert = QVal5.toStdString();
+                char *QVal5Convert;
+                QVal5Convert = new char[QstrConvert.length() + 1];
+                strcpy(QVal5Convert, QstrConvert.c_str());
+                Song[songCount].set(QVal5Convert, QVal.toInt(), QVal2.toInt());
+            }
+        }
+
+        *songSize = songCount;
+        QryCount++;
+        if (QryCount == *albSize) {
+            Myexit = true;
+        }
+        db.close();
+        }
+    }
+    return Song;
+}
+songObj* mysqlconn::connectArtist(songObj* Artist, int artMenu, int *mySize){
+
+
+    int artCount = 0;
+    *mySize = MAXART;
+    Artist = new songObj[MAXART];
+
+    for(int i= 0 ; i <= MAXART; i++){
+        Artist[i].set("-", 0, 0);
+    }
+
+
+
+    char *myQry = NULL;
+
+    if (!myQry) {
+        myQry = new char[MAXQRY];
+    }
+
+    /// use artist menu ID  to get artists
+
+    sprintf(myQry, "SELECT * FROM mt_cds_object WHERE parent_id = %d",
+            artMenu);
+
+    if(!db.open()){
+        cout << "error couldn't connect to mysql" << endl;
+    }
+    else{
+    QSqlQuery query(db);
+    query = QString(myQry);
+
+    while (query.next()){
+
+    QString QVal = query.value(0).toString();
+    QString QVal1 = query.value(1).toString();
+    QString QVal2 = query.value(2).toString();
+    QString QVal3 = query.value(3).toString();
+    QString QVal4 = query.value(4).toString();
+    QString QVal5 = query.value(5).toString();
+
+        ///////*****  Query for MAIN root menu
+        if (QVal2.toInt() == artMenu) {
+            string Qstr5Convert = QVal5.toStdString();
+            char *QVal5Convert;
+            QVal5Convert = new char[Qstr5Convert.length() + 1];
+            strcpy(QVal5Convert, Qstr5Convert.c_str());
+            Artist[artCount].set(QVal5Convert, QVal.toInt(), QVal2.toInt());
+            artCount++;
+        }
+    }
+
+    *mySize = artCount;
+    db.close();
+    }
+
+    return Artist;
+}
+
+songObj* mysqlconn::connectVideo(songObj* VidDir, int *vidDirSize, songObj* Video, int *vidSize){
+
+    int VidCount = 0;
+
+
+    int QryCount = 0;
+    char *myQry = NULL;
+    int curID = 0;
+    bool Myexit = false;
+
+    *vidSize = MAXVIDEO;
+    Video = new songObj[MAXVIDEO];
+
+    for(int i= 0 ; i <= MAXVIDEO; i++){
+        Video[i].set("-", 0, 0);
+    }
+
+    while (Myexit != true){
+
+
+        if (!myQry) {
+            myQry = new char[MAXQRY];
+        }
+
+
+        curID = VidDir[QryCount+1].getFileID();
+        if(curID == 0){
+            Myexit = true;
+        }
+
+
+        sprintf(myQry, "SELECT * FROM mt_cds_object WHERE parent_id = %d",
+                curID);
+        if(db.open()){
+        QSqlQuery query(db);
+        query = QString(myQry);
+
+        while (query.next()){
+
+
+            QString QVal = query.value(0).toString();
+            QString QVal1 = query.value(1).toString();
+            QString QVal2 = query.value(2).toString();
+            QString QVal3 = query.value(3).toString();
+            QString QVal4 = query.value(4).toString();
+            QString QVal5 = query.value(5).toString();
+            ///////*****  Query for Songs
+
+            if (QVal2.toInt() == curID) {
+                VidCount++;
+                string Qstr5Convert = QVal5.toStdString();
+                char *QVal5Convert;
+                QVal5Convert = new char[Qstr5Convert.length() + 1];
+                strcpy(QVal5Convert, Qstr5Convert.c_str());
+                Video[VidCount].set(QVal5Convert, QVal.toInt(), QVal2.toInt());
+            }
+        }
+
+        *vidSize = VidCount;
+        QryCount++;
+        if (QryCount == *vidDirSize) {
+            Myexit = true;
+        }
+
+        db.close();
+        }
+        else{
+            cout << "error couldn't to mysql" << endl;
+              Myexit = true;
+        }
+    }
+    return Video;
+}
+
+
+
+songObj* mysqlconn::connectVidDir(songObj* VidDir, int vidMenu, int *vidDirSize){
+
+    int VidDirCount = 0;
+
+    *vidDirSize = MAXVIDEO;
+    VidDir = new songObj[MAXVIDEO];
+
+    for(int i= 0 ; i <= MAXVIDEO; i++){
+        VidDir[i].set("-", 0, 0);
+    }
+
+    char *myQry = NULL;
+
+    if (!myQry) {
+        myQry = new char[MAXQRY];
+    }
+
+    /// use video menu ID  to get vid directory
+
+    sprintf(myQry, "SELECT * FROM mt_cds_object WHERE parent_id = %d",
+            vidMenu);
+    if(db.open()){
+    QSqlQuery query(db);
+    query = QString(myQry);
+
+    while (query.next()){
+
+
+        QString QVal = query.value(0).toString();
+        QString QVal1 = query.value(1).toString();
+        QString QVal2 = query.value(2).toString();
+        QString QVal3 = query.value(3).toString();
+        QString QVal4 = query.value(4).toString();
+        QString QVal5 = query.value(5).toString();
+        ///////*****  Query for MAIN root menu
+        if (QVal2.toInt() == vidMenu) {
+            string Qstr5Convert = QVal5.toStdString();
+            char *QVal5Convert;
+            QVal5Convert = new char[Qstr5Convert.length() + 1];
+            strcpy(QVal5Convert, Qstr5Convert.c_str());
+            VidDir[VidDirCount].set(QVal5Convert, QVal.toInt(), QVal2.toInt());
+            VidDirCount++;
+        }
+    }
+
+    *vidDirSize = VidDirCount;
+    db.close();
+    }
+    else{
+        cout << "error couldn't connect to vid dir in mysql" << endl;
+    }
+    return VidDir;
+}
+
+int mysqlconn::connectVidMenu(){
+    int vidMenuID = 0, vidDirMenuID = 0, vidMenu = 0;
+
+
+    bool Myexit = false; // exit variable
+    int QryCount = 0;
+    int rowCount = 0;
+    char *myQry = NULL;
+
+
+    while (Myexit != true) {
+
+        if (!myQry) {
+            myQry = new char[MAXQRY];
+        }
+
+
+        /// use root to query for the Main menu's (audio + video)
+        if (QryCount == 0) {
+            sprintf(myQry, "SELECT * FROM mt_cds_object WHERE parent_id = %d",
+                    0);
+        }
+
+        else if(QryCount == 1){
+            sprintf(myQry, "SELECT * FROM mt_cds_object WHERE parent_id = %d",
+                    vidMenuID);
+        }
+
+        if(db.open()){
+        QSqlQuery query(db);
+        query = QString(myQry);
+        rowCount = 0;
+        while (query.next()){
+
+            QString QVal = query.value(0).toString();
+            QString QVal1 = query.value(1).toString();
+            QString QVal2 = query.value(2).toString();
+            QString QVal3 = query.value(3).toString();
+            QString QVal4 = query.value(4).toString();
+            QString QVal5 = query.value(5).toString();
+
+            if (QVal2.toInt() == 0 && rowCount == 3){
+                vidMenuID = QVal.toInt();
+            }
+
+            if(QVal2.toInt() == vidMenuID && rowCount == 1){
+                vidDirMenuID = QVal.toInt();
+            }
+            rowCount++;
+
+        }
+        QryCount++;
+        if (QryCount > 2) { // + albCount
+            Myexit = true;
+        }
+        db.close();
+
+        }
+        else{
+            cout << "error couldn't connect to vid menu in mysql" << endl;
+              Myexit = true;
+        }
+    }
+    return vidDirMenuID;
+}
+
+int mysqlconn::connectArtMenu() {
+
+
+    int audMenuID = 0, artMenuID = 0, QryCount = 0, menu = 0, artMenu = 0;
+    bool Myexit = false; // exit variable
+
+    char *myQry = NULL;
+
+    while (Myexit != true) {
+
+        if (!myQry) {
+            myQry = new char[MAXQRY];
+        }
+
+        /// use root to query for the Main menu's (audio + video)
+        if (QryCount == 0) {
+            sprintf(myQry, "SELECT * FROM mt_cds_object WHERE parent_id = %d",
+                    0);
+        }
+
+        /// use audio menu ID to get Artist Menu ID
+        else if (QryCount == 1) {
+            sprintf(myQry, "SELECT * FROM mt_cds_object WHERE parent_id = %d",
+                    audMenuID);
+        }
+        if(db.open()){
+        QSqlQuery query(db);
+        query = QString(myQry);
+        while (query.next()){
+
+            QString QVal = query.value(0).toString();
+            QString QVal1 = query.value(1).toString();
+            QString QVal2 = query.value(2).toString();
+            QString QVal3 = query.value(3).toString();
+            QString QVal4 = query.value(4).toString();
+            QString QVal5 = query.value(5).toString();
+            ///////*****  Query for MAIN root menu
+            if (QVal2.toInt() == 0 && QryCount == 0) {
+                menu++;
+                if (menu == 1) {
+                    audMenuID = QVal.toInt();
+                }
+            }
+
+            //check for Audio menus
+            else if (QVal2.toInt() == audMenuID) {
+                artMenu++;
+                //set ID of artist sub Menu
+                if (artMenu == 4) {
+                    artMenuID = QVal.toInt();
+                }
+            }
+
+        }
+        QryCount++;
+        if (QryCount > 3) { // + albCount
+            Myexit = true;
+        }
+        db.close();
+        }
+        else{
+            cout << "error couldn't connect to mysql" << endl;
+              Myexit = true;
+        }
+    }
+    return artMenuID;
+}
+
+mysqlconn::~mysqlconn() {
+
+
+}
--- /dev/null
+++ beagletomb-0.1.6/.pc.moved/debian-changes-0.1.6-0ubuntu1~7/src/mysqlconn.h
@@ -0,0 +1,57 @@
+/*
+ *  Written By: Grant Hutchinson
+ *  License: GPLv3.
+ *  h.g.utchinson@gmail.com
+ *  Copyright (C) 2012 by Grant Hutchinson
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#ifndef MYSQLCONN_H_
+#define MYSQLCONN_H_
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <cstring>
+#include <iostream>
+#include <string>
+#include <string.h>
+#include "songObj.h"
+#include <QtSql>
+
+using namespace std;
+
+#define MAXART 10000
+#define MAXALB 10000
+#define MAXSONG 20000
+#define MAXVIDEO 10000
+#define MAXQRY 1000
+class mysqlconn {
+
+public:
+        QSqlDatabase db;
+	mysqlconn(const char *server, const char* user, const char *pass, const char *database);
+	songObj* connectArtist(songObj* Artist, int artMenu, int *mySize);
+	songObj* connectSong(songObj* Album, int *albSize, songObj* Song, int *songSize);
+	songObj* connectAlbum(songObj* Artist, int *artSize, songObj* Album, int *albSize);
+        songObj* connectVidDir(songObj* VidDir, int vidDirMenu, int *vidDirSize);
+        songObj* connectVideo(songObj* VidDir, int *vidDirSize, songObj* Video, int *vidSize);
+        int connectVidMenu();
+        int connectArtMenu();
+        void display(ostream& os, int pos);
+         virtual ~mysqlconn();
+};
+
+#endif /* MYSQLCONN_H_ */
--- /dev/null
+++ beagletomb-0.1.6/.pc.moved/debian-changes-0.1.6-0ubuntu1~7/src/sync.h
@@ -0,0 +1,78 @@
+/*
+ *  Written By: Grant Hutchinson
+ *  License: GPLv3.
+ *  h.g.utchinson@gmail.com
+ *  Copyright (C) 2012 by Grant Hutchinson
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#ifndef SYNCMe_H_
+#define SYNCMe_H_
+
+#include <QtSql>
+
+#include <iostream>
+#include <stdio.h>
+#include <iostream>
+#include <string>
+#include <stdlib.h>
+#include <algorithm>
+#include <sstream>
+#include <iostream>
+#include <fstream>
+
+#include "mysqlconn.h"
+#include "readDB.h"
+#include "songObj.h"
+#include "radioObj.h"
+#include "mysqlconn.h"
+
+#define TEMPSYNCPREF "/.BeagleTomb/BTmedia.db"
+
+using namespace std;
+
+class syncMe {
+
+public:
+        string DBLocation;
+        QSqlDatabase db;
+
+        syncMe(const char *server, const char *user, const char *pass, const char *table, const char *dbLocation);
+
+        void videoWrite(songObj* Song, int songSize);
+
+        void vidDirWrite(songObj* Song, int songSize);
+
+        void songWrite(songObj* Song, int songSize);
+
+        void albumWrite(songObj* Album, int albSize);
+
+        void artistWrite(songObj* Artist, int artSize);
+
+        void writeMe(string qry);;
+
+        int getMaxPos(int count);
+        void sendToShell();
+        void RemoveTMP();
+	void display(songObj* Artist, int *artSize, songObj* Album, int *albSize, songObj *Song, int *songSize);
+	void deleteDB(const char *dbLocation);
+	void createDB(const char *dbLocation);
+        void OpenDB();
+        int control(const char *server, const char *user, const char *pass, const char *table, const char *dbLocation);
+
+	virtual ~syncMe();
+};
+#endif /* SYNCMe_H_ */
--- /dev/null
+++ beagletomb-0.1.6/.pc.moved/debian-changes-0.1.6-0ubuntu1~8/changelog
@@ -0,0 +1,25 @@
+beagletomb (0.1.6-0ubuntu1~7) natty; urgency=low
+
+  * Update: Fixed dynamic memory allocation, sync improved (Closes: #nnnn)
+
+ -- Grant Hutchinson <h.g.utchinson@gmail.com>  Mon, 27 Mar 2012 18:59:22 -0500
+
+beagletomb (0.1.6-0ubuntu1) natty; urgency=low
+
+  * Update: fixed mediatomb mysql install/configure (Closes: #nnnn)
+  * Update: Added dynamic account creation (Closes: #nnnn)
+  * Update: changed sql cache to be more elegant and efficient (Closes: #nnnn)
+
+ -- Grant Hutchinson <h.g.utchinson@gmail.com>  Wed, 21 Mar 2012 18:59:22 -0500
+
+beagletomb (0.1.6-0ubuntu1) natty; urgency=low
+
+  * Update: changed sql cache to be more elegant and efficient (Closes: #nnnn)
+
+ -- Grant Hutchinson <h.g.utchinson@gmail.com>  Wed, 22 Feb 2012 18:59:22 -0500
+
+beagletomb (0.1.5-0ubuntu1) natty; urgency=low
+
+  * Initial release (Closes: #nnnn)
+
+ -- Grant Hutchinson <h.g.utchinson@gmail.com>  Wed, 22 Feb 2012 18:59:22 -0500
--- /dev/null
+++ beagletomb-0.1.6/.pc.moved/debian-changes-0.1.6-0ubuntu1~8/src/fileobj.cpp
@@ -0,0 +1,107 @@
+#include "fileobj.h"
+
+fileObj::fileObj()
+{
+
+    objSize = 0;
+    InitSize = 0;
+    initFile(INITSIZE);
+}
+
+fileObj::fileObj(const fileObj &src){
+
+    if(src.objSize > 0){
+        objSize = 0;
+        delete [] fileName;
+        delete [] fileID;
+        delete [] filePar;
+        fileName = new string[src.objSize+1];
+        fileID = new int[src.objSize+1];
+        filePar = new int[src.objSize+1];
+        for(int i=0; i< src.objSize; i++){
+            set(i,src.fileID[i], src.filePar[i], src.fileName[i].c_str());
+        }
+        InitSize = src.InitSize;
+    }
+}
+
+void fileObj::initFile(int initSZ){
+    fileName = new string[initSZ];
+    fileID = new int[initSZ];
+    filePar = new int[initSZ];
+    InitSize = 0;
+    for(int i=0; i< initSZ; i++){
+        setInit(i, 0, 0, "-");
+    }
+}
+
+void fileObj::REinitFile(int oldsize, int newsize){
+    //set the new initialize size
+    InitSize = oldsize+newsize;
+    int tempObjSize = 0;
+    string *nameCopy;
+    int *idCopy, *parCopy;
+    nameCopy = new string[objSize+1];
+    parCopy = new int[objSize+1];
+   idCopy = new int[objSize+1];
+
+    for(int i=0; i< objSize; i++){
+        nameCopy[i] = "-";
+        parCopy[i]= 0;
+        idCopy[i] = 0;
+    }
+
+    for(int i=0; i< objSize-4; i++){
+        nameCopy[i] = fileName[i];
+        parCopy[i] = filePar[i];
+        idCopy[i] = fileID[i];
+    }
+      initFile(InitSize);
+   /// refill array fileName fileID filePar array
+
+      tempObjSize = objSize;
+      objSize = 0;
+   for(int i=0; i< tempObjSize; i++){
+        set(i,idCopy[i], parCopy[i], nameCopy[i].c_str());
+    }
+
+}
+
+
+fileObj::~fileObj(){
+        delete [] fileName;
+        delete [] fileID;
+        delete [] filePar;
+}
+
+void fileObj::display(){
+    cout << "obj size is " << objSize << endl;
+    for(int i=0; i< objSize; i++){
+        cout << " Num: " << i
+             << " ID: " << getID(i)
+             << " PAR: " << getPar(i)
+             << " NAME: " << getName(i) << endl;
+    }
+}
+
+fileObj& fileObj::operator=(const fileObj& src){
+
+    if(this != &src){
+        if(src.objSize > 0){
+            objSize = 0;
+            delete [] fileName;
+            delete [] fileID;
+            delete [] filePar;
+            fileName = new string[src.objSize+1];
+            fileID = new int[src.objSize+1];
+            filePar = new int[src.objSize+1];
+            for(int i=0; i< src.objSize-1; i++){
+                set(i,src.fileID[i], src.filePar[i], src.fileName[i].c_str());
+            }
+            objSize = src.objSize;
+            InitSize = src.InitSize;
+        }
+    }
+     return *this;
+
+}
--- /dev/null
+++ beagletomb-0.1.6/src/sync.h.OTHER
@@ -0,0 +1,79 @@
+/*
+ *  Written By: Grant Hutchinson
+ *  License: GPLv3.
+ *  h.g.utchinson@gmail.com
+ *  Copyright (C) 2012 by Grant Hutchinson
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#ifndef SYNCMe_H_
+#define SYNCMe_H_
+
+#include <QtSql>
+
+#include <iostream>
+#include <stdio.h>
+#include <iostream>
+#include <string>
+#include <stdlib.h>
+#include <algorithm>
+#include <sstream>
+#include <iostream>
+#include <fstream>
+
+#include "mysqlconn.h"
+#include "readDB.h"
+#include "songObj.h"
+#include "radioObj.h"
+#include "mysqlconn.h"
+#include "fileobj.h"
+
+#define TEMPSYNCPREF "/.BeagleTomb/BTmedia.db"
+
+using namespace std;
+
+class syncMe {
+
+public:
+        string DBLocation;
+        QSqlDatabase db;
+
+        syncMe(const char *server, const char *user, const char *pass, const char *table, const char *dbLocation);
+
+        void videoWrite(fileObj& Video);
+
+        void vidDirWrite(fileObj& VidDir);
+
+        void songWrite(fileObj& Song);
+
+        void albumWrite(fileObj& Album);
+
+        void artistWrite(fileObj& Artist);
+
+        void writeMe(string qry);;
+
+        int getMaxPos(int count);
+        void sendToShell();
+        void RemoveTMP();
+        void display(songObj* Artist, int *artSize, songObj* Album, int *albSize, songObj *Song, int *songSize);
+	void deleteDB(const char *dbLocation);
+	void createDB(const char *dbLocation);
+        void OpenDB();
+        int control(const char *server, const char *user, const char *pass, const char *table, const char *dbLocation);
+
+	virtual ~syncMe();
+};
+#endif /* SYNCMe_H_ */
--- beagletomb-0.1.6.orig/src/sync.cpp
+++ beagletomb-0.1.6/src/sync.cpp
@@ -24,14 +24,14 @@ using namespace std;
 syncMe::syncMe(const char *server, const char *user, const char *pass,
                const char *table, const char *dbLocation) {
     string home = getenv("HOME");
-     string temp_pref = home + TEMPSYNCPREF;
-   db = QSqlDatabase::addDatabase("QSQLITE", "connection");
-   db.setDatabaseName(temp_pref.c_str());
+    string temp_pref = home + TEMPSYNCPREF;
+    db = QSqlDatabase::addDatabase("QSQLITE", "connection");
+    db.setDatabaseName(temp_pref.c_str());
 
 
-   if(control(server, user, pass, table, dbLocation)==0){
+    if(control(server, user, pass, table, dbLocation)==0){
         // future error popup
-   }
+    }
 
 
 }
@@ -86,7 +86,11 @@ int syncMe::control(const char *server,
     // query mysql each artist,album,song,vidDir,video - store and return objects
     Artist = ms.connectArtist(artMenu, Artist);
     Album = ms.connectAlbum(Artist, Album);
+<<<<<<< TREE
+    //  Album.display();
+=======
   //  Album.display();
+>>>>>>> MERGE-SOURCE
     Song = ms.connectSong(Album,Song);
     VidDir = ms.connectVidDir(vidDirMenu,VidDir);
     Video = ms.connectVideo(VidDir,Video);
@@ -96,6 +100,15 @@ int syncMe::control(const char *server,
         return 0;
     }
     else{
+<<<<<<< TREE
+        ///  sync artist,album,song objects to the local sql database
+        artistWrite(Artist);
+        albumWrite(Album);
+        songWrite(Song);
+        vidDirWrite(VidDir);
+        videoWrite(Video);
+        return 1;
+=======
     ///  sync artist,album,song objects to the local sql database
     artistWrite(Artist);
     albumWrite(Album);
@@ -103,6 +116,7 @@ int syncMe::control(const char *server,
     vidDirWrite(VidDir);
     videoWrite(Video);
     return 1;
+>>>>>>> MERGE-SOURCE
     }
 }
 
@@ -329,12 +343,12 @@ void syncMe::videoWrite(fileObj& Video){
 
 void syncMe::writeMe(string qry){
 
-       if(db.open()){
-           QSqlQuery myQry(db);
-           myQry.prepare(qry.c_str());
-           myQry.exec();
-           db.close();
-       }
+    if(db.open()){
+        QSqlQuery myQry(db);
+        myQry.prepare(qry.c_str());
+        myQry.exec();
+        db.close();
+    }
 }
 
 
@@ -356,5 +370,5 @@ int syncMe::getMaxPos(int count) {
 }
 
 syncMe::~syncMe() {
-   // db.close();
+    // db.close();
 }
--- beagletomb-0.1.6.orig/src/readDB.h
+++ beagletomb-0.1.6/src/readDB.h
@@ -25,31 +25,29 @@
 #ifndef READDB_H_
 #define READDB_H_
 #define MAX 10000
-#include "songObj.h"
 #include "radioObj.h"
 #include <stdlib.h>
 #include <stdio.h>
 #include <iostream>
 #include <cstring>
 #include <QtSql>
+#include "fileobj.h"
 using namespace std;
 class readDB {
-
-        songObj *Artist, *Album, *Song, *Video, *VidDir;
         radioObj play_list;
         char *DBlocation2;
 
 public:
         QSqlDatabase db2;
         readDB(const char *dbLocation);
-	songObj* SongFill(int *songSize);
-	songObj* AlbumFill(int *albSize);
-	songObj* ArtistFill(int *artSize);
-        songObj* VidDirFill(int *vidDirSize);
-        songObj* VideoFill(int *vidSize);
+        fileObj& SongFill(fileObj& Song);
+        fileObj& AlbumFill(fileObj& Album);
+        fileObj& ArtistFill(fileObj& Artist);
+        fileObj& VidDirFill(fileObj& VidDir);
+        fileObj& VideoFill(fileObj& Video);
        radioObj RadioFill( int *radSize);
        void OpenDB();
-	void display(int artSize, int albSize, int songSize);
+        void display(fileObj&Artist, fileObj& Song,fileObj& Album);
 	virtual ~readDB();
 };
 
--- beagletomb-0.1.6.orig/src/beaglemain.h
+++ beagletomb-0.1.6/src/beaglemain.h
@@ -26,7 +26,6 @@
 #include <stdlib.h>
 #include <stdio.h>
 #include "sync.h"
-#include "songObj.h"
 #include "readDB.h"
 #include "mplaycon.h"
 #include "prefdialog.h"
@@ -37,6 +36,7 @@
 #include "newplaylist.h"
 #include "openplaylist.h"
 #include "radioObj.h"
+#include "localsync.h"
 namespace Ui {
 class BeagleMain;
 }
@@ -53,6 +53,7 @@ public:
     int plMode;        /// playlist mode : 1 playlist browsing and 2: browsing tracks within playlist
     int pl_selected;  /// global playlist selection
      int title_selected;  /// global title selection
+    int CON_MODE;
 
     About ab;
     PrefDialog prefDg;
@@ -62,7 +63,12 @@ public:
     openplaylist openPL;
     QMPwidget widget;
     mplayCon mplay;
-    songObj* Artist, *Song, *Album, *VidDir, *Video;
+<<<<<<< TREE
+    localsync SyncAudioLocal, SyncVideoLocal;
+    fileObj Artist, Song, Album, VidDir, Video, DirecLocal, SongLocal, vidDirecLocal, VideoLocal;
+=======
+    fileObj Artist, Song, Album, VidDir, Video;
+>>>>>>> MERGE-SOURCE
     radioObj Radio;
     int artSize, albSize, songSize, vidSize, vidDirSize, radSize;
 
@@ -75,8 +81,11 @@ public:
    ~BeagleMain();
 
     void updateMenu(int type);
-
     void updateTitle();
+    void updateLclSongDirs();
+    void updateLclSongs();
+    void updateLclVidDirs();
+    void updateLclVideos();
 
     void updateAlbMenu(int select);
     void updateTitle(int select);
@@ -88,6 +97,7 @@ public:
     void RefillMainPL();
     void RefillPLFolder();
     void startSong(char *FinSong, int selID);
+    void startLocal(char *finSong, char *finPath);
     void PlaylistPlay(int selID);
     void closeEvent(QCloseEvent *event);
 
@@ -151,6 +161,12 @@ private slots:
 
     void on_list_radio_doubleClicked(QModelIndex index);
 
+    void on_but_import_aud_clicked();
+
+    void on_but_remote_tog_clicked();
+
+    void on_but_import_vid_clicked();
+
 private:
     Ui::BeagleMain *ui;
     QStringListModel *t_Model;
--- /dev/null
+++ beagletomb-0.1.6/src/sync.cpp.THIS
@@ -0,0 +1,360 @@
+/*
+ *  Written By: Grant Hutchinson
+ *  License: GPLv3.
+ *  h.g.utchinson@gmail.com
+ *  Copyright (C) 2012 by Grant Hutchinson
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#include "sync.h"
+using namespace std;
+syncMe::syncMe(const char *server, const char *user, const char *pass,
+               const char *table, const char *dbLocation) {
+    string home = getenv("HOME");
+    string temp_pref = home + TEMPSYNCPREF;
+    db = QSqlDatabase::addDatabase("QSQLITE", "connection");
+    db.setDatabaseName(temp_pref.c_str());
+
+
+    if(control(server, user, pass, table, dbLocation)==0){
+        // future error popup
+    }
+
+
+}
+
+void syncMe::deleteDB(const char *dbLocation) {
+    char FinalLink[150];
+    sprintf(FinalLink, "rm %s ", dbLocation);
+    system(FinalLink);
+}
+
+void syncMe::OpenDB(){
+
+}
+
+void syncMe::createDB(const char *dbLocation) {
+    string finalQry[7];
+    finalQry[0] = "create table Artists(key INTEGER PRIMARY KEY,Artist TEXT,ArtistID integer, ArtistPar integer) ";
+    finalQry[1] = "create table Albums(key INTEGER PRIMARY KEY,Album TEXT,AlbumID integer, AlbumPar integer)";
+    finalQry[2] = "create table Songs(key INTEGER PRIMARY KEY,Song TEXT,SongID integer, SongPar integer)";
+    finalQry[3] = "create table Videos(key INTEGER PRIMARY KEY,Video TEXT,VideoID integer, VideoPar integer)";
+    finalQry[4] = "create table VidDirs(key INTEGER PRIMARY KEY,VidDir TEXT,VidDirID integer, VidDirPar integer)";
+    finalQry[5] = "create table pref(key INTEGER PRIMARY KEY,usr TEXT,PASS TEXT,SERVER TEXT,PRT TEXT,SQLTABLE TEXT,SQL TEXT,PLAYLISTDIR TEXT)";
+    finalQry[6] = "create table radio(id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL DEFAULT (0),name TEXT NOT NULL,url TEXT NOT NULL)";
+    for(int i=0; i<7; i++){
+        writeMe(finalQry[i]);
+    }
+}
+
+int syncMe::control(const char *server, const char *user, const char *pass,
+                    const char *table, const char *dbLocation) {
+    DBLocation = dbLocation;
+    int artMenu, vidDirMenu; /// main Artist Menu ID
+    int artSize, albSize, songSize, vidSize, vidDirSize; /// sizes of each Object array
+
+    artMenu = 0, artSize = 0, albSize = 0 ,songSize = 0;
+    vidSize = 0, vidDirSize = 0;
+
+    /// init Objects
+    fileObj Artist, Album, Song, VidDir, Video;
+    //attempt to delete previous DB
+    deleteDB(dbLocation);
+
+    //create new DB
+    createDB(dbLocation);
+
+    /// init mysqlObject
+    mysqlconn ms(server, user, pass, table);
+
+    // get main artist menu
+    artMenu = ms.connectArtMenu();
+    vidDirMenu = ms.connectVidMenu();
+    // query mysql each artist,album,song,vidDir,video - store and return objects
+    Artist = ms.connectArtist(artMenu, Artist);
+    Album = ms.connectAlbum(Artist, Album);
+    //  Album.display();
+    Song = ms.connectSong(Album,Song);
+    VidDir = ms.connectVidDir(vidDirMenu,VidDir);
+    Video = ms.connectVideo(VidDir,Video);
+
+    if(artMenu ==0){
+        cout << "empty database or invalid login" << endl;
+        return 0;
+    }
+    else{
+        ///  sync artist,album,song objects to the local sql database
+        artistWrite(Artist);
+        albumWrite(Album);
+        songWrite(Song);
+        vidDirWrite(VidDir);
+        videoWrite(Video);
+        return 1;
+    }
+}
+
+void syncMe::artistWrite(fileObj& Artist){
+    int  pos = 0, posMax = 0, counter = 0, countRemind = 0;
+    int artSize =0;
+    artSize = Artist.getSize();
+    string str2;
+    counter = getMaxPos(artSize);
+    posMax = counter;
+
+    for (int m = 0; m <= (artSize / counter); m++) {
+        countRemind = 0;
+        stringstream os;
+        for (int i = pos; i <= posMax; i++) {
+            str2 = Artist.getName(i);
+
+            str2.erase(remove(str2.begin(), str2.end(), '\"'), str2.end());
+            Artist.setName(i,(char *)str2.c_str());
+            //           cout << str2 << endl;
+            if (i != posMax && countRemind == 0) {
+                os << " INSERT INTO artists (Artist,ArtistID,ArtistPar) " <<
+                      "SELECT \"" << Artist.getName(i) << "\" AS \"" << "Artist" << "\", \""
+                   <<  Artist.getID(i) << "\" AS \"" << "ArtistID" << "\", \""
+                   << Artist.getPar(i) << "\" AS \"" << "ArtistPar" << "\"";
+                //             cout << os;
+                countRemind++;
+            }
+            if (i != posMax && countRemind != 0) {
+                os << " UNION SELECT \""<< Artist.getName(i)<<"\",\""<< Artist.getID(i)<<"\",\""<<Artist.getPar(i)<<"\"";
+
+            } else if (i == posMax && countRemind != 0) {
+                os << ";";
+            }
+        }
+        str2 = os.str();
+        writeMe(str2);
+        posMax += counter;
+        pos += counter;
+
+        if (m == (artSize / counter) - 1) {
+            posMax = pos + artSize - ((artSize / counter)
+                                      * counter);
+        }
+    }
+}
+
+void syncMe::albumWrite(fileObj& Album){
+    int  pos = 0, posMax = 0, counter = 0, countRemind = 0;
+    int albSize = 0;
+    albSize = Album.getSize();
+    string str2;
+
+    counter = getMaxPos(albSize);
+    posMax = counter;
+
+    for (int m = 0; m <= (albSize / counter); m++) {
+        countRemind = 0;
+        stringstream os;
+        for (int i = pos; i <= posMax; i++) {
+            str2 = Album.getName(i);
+
+            str2.erase(remove(str2.begin(), str2.end(), '\"'), str2.end());
+            Album.setName(i,(char *)str2.c_str());
+            //         cout << str2 << endl;
+            if (i != posMax && countRemind == 0) {
+                os << " INSERT INTO albums (Album,AlbumID,AlbumPar) " <<
+                      "SELECT \"" << Album.getName(i) << "\" AS \"" << "Album" << "\", \""
+                   <<  Album.getID(i) << "\" AS \"" << "AlbumID" << "\", \""
+                   << Album.getPar(i) << "\" AS \"" << "AlbumPar" << "\"";
+                //           cout << os;
+                countRemind++;
+            }
+            if (i != posMax && countRemind != 0) {
+                os << " UNION SELECT \""<< Album.getName(i)<<"\",\""<< Album.getID(i)<<"\",\""<<Album.getPar(i)<<"\"";
+
+            } else if (i == posMax && countRemind != 0) {
+                os << ";";
+            }
+        }
+        str2 = os.str();
+        writeMe(str2);
+        posMax += counter;
+        pos += counter;
+
+        if (m == (albSize / counter) - 1) {
+            posMax = pos + albSize - ((albSize / counter)
+                                      * counter);
+        }
+    }
+}
+void syncMe::songWrite(fileObj& Song){
+    int  pos = 0, posMax = 0, counter = 0, countRemind = 0;
+    int songSize = 0;
+    songSize = Song.getSize();
+    string str2;
+    counter = getMaxPos(songSize);
+    posMax = counter;
+
+    for (int m = 0; m <= (songSize / counter); m++) {
+        countRemind = 0;
+        stringstream os;
+        for (int i = pos; i <= posMax; i++) {
+            str2 = Song.getName(i);
+
+            str2.erase(remove(str2.begin(), str2.end(), '\"'), str2.end());
+            Song.setName(i,(char *)str2.c_str());
+            //         cout << str2 << endl;
+            if (i != posMax && countRemind == 0) {
+                os << " INSERT INTO songs (Song,SongID,SongPar) " <<
+                      "SELECT \"" << Song.getName(i) << "\" AS \"" << "Song" << "\", \""
+                   <<  Song.getID(i) << "\" AS \"" << "SongID" << "\", \""
+                   << Song.getPar(i) << "\" AS \"" << "SongPar" << "\"";
+                //           cout << os;
+                countRemind++;
+            }
+            if (i != posMax && countRemind != 0) {
+                os << " UNION SELECT \""<< Song.getName(i)<<"\",\""<< Song.getID(i)<<"\",\""<<Song.getPar(i)<<"\"";
+
+            } else if (i == posMax && countRemind != 0) {
+                os << ";";
+            }
+        }
+        str2 = os.str();
+        writeMe(str2);
+        posMax += counter;
+        pos += counter;
+
+        if (m == (songSize / counter) - 1) {
+            posMax = pos + songSize - ((songSize / counter)
+                                       * counter);
+        }
+    }
+}
+
+void syncMe::vidDirWrite(fileObj& vidDir){
+    int  pos = 0, posMax = 0, counter = 0, countRemind = 0;
+    int vidDirSize = 0;
+    vidDirSize = vidDir.getSize();
+    string str2;
+    counter = getMaxPos(vidDirSize);
+    posMax = counter;
+
+    for (int m = 0; m <= (vidDirSize / counter); m++) {
+        countRemind = 0;
+        stringstream os;
+        for (int i = pos; i <= posMax; i++) {
+            str2 = vidDir.getName(i);
+
+            str2.erase(remove(str2.begin(), str2.end(), '\"'), str2.end());
+            vidDir.setName(i,(char *)str2.c_str());
+            //       cout << str2 << endl;
+            if (i != posMax && countRemind == 0) {
+                os << " INSERT INTO viddirs (VidDir,VidDirID,VidDirPar) " <<
+                      "SELECT \"" << vidDir.getName(i) << "\" AS \"" << "VidDir" << "\", \""
+                   <<  vidDir.getID(i) << "\" AS \"" << "VidDirID" << "\", \""
+                   << vidDir.getPar(i) << "\" AS \"" << "VidDirPar" << "\"";
+                //          cout << os;
+                countRemind++;
+            }
+            if (i != posMax && countRemind != 0) {
+                os << " UNION SELECT \""<< vidDir.getName(i)<<"\",\""<< vidDir.getID(i)<<"\",\""<<vidDir.getPar(i)<<"\"";
+
+            } else if (i == posMax && countRemind != 0) {
+                os << ";";
+            }
+        }
+        str2 = os.str();
+        writeMe(str2);
+        posMax += counter;
+        pos += counter;
+
+        if (m == (vidDirSize / counter) - 1) {
+            posMax = pos + vidDirSize - ((vidDirSize / counter)
+                                         * counter);
+        }
+    }
+}
+
+
+void syncMe::videoWrite(fileObj& Video){
+    int  pos = 0, posMax = 0, counter = 0, countRemind = 0;
+    int vidSize = 0;
+    vidSize = Video.getSize();
+    string str2;
+    counter = getMaxPos(vidSize);
+    posMax = counter;
+
+    for (int m = 0; m <= (vidSize / counter); m++) {
+        countRemind = 0;
+        stringstream os;
+        for (int i = pos; i <= posMax; i++) {
+            str2 = Video.getName(i);
+
+            str2.erase(remove(str2.begin(), str2.end(), '\"'), str2.end());
+            Video.setName(i,(char *)str2.c_str());
+            //        cout << str2 << endl;
+            if (i != posMax && countRemind == 0) {
+                os << " INSERT INTO videos (Video,VideoID,VideoPar) " <<
+                      "SELECT \"" << Video.getName(i) << "\" AS \"" << "Video" << "\", \""
+                   <<  Video.getID(i) << "\" AS \"" << "VideoID" << "\", \""
+                   << Video.getPar(i) << "\" AS \"" << "VideoPar" << "\"";
+                //           cout << os;
+                countRemind++;
+            }
+            if (i != posMax && countRemind != 0) {
+                os << " UNION SELECT \""<< Video.getName(i)<<"\",\""<< Video.getID(i)<<"\",\""<<Video.getPar(i)<<"\"";
+
+            } else if (i == posMax && countRemind != 0) {
+                os << ";";
+            }
+        }
+        str2 = os.str();
+        writeMe(str2);
+        posMax += counter;
+        pos += counter;
+
+        if (m == (vidSize / counter) - 1) {
+            posMax = pos + vidSize - ((vidSize / counter)
+                                      * counter);
+        }
+    }
+}
+
+void syncMe::writeMe(string qry){
+
+    if(db.open()){
+        QSqlQuery myQry(db);
+        myQry.prepare(qry.c_str());
+        myQry.exec();
+        db.close();
+    }
+}
+
+
+int syncMe::getMaxPos(int count) {
+    int posMax;
+
+    if (count < 400 && count > 100) {
+        posMax = 100;
+    } else if (count < 100 && count > 20) {
+        posMax = 10;
+    } else if (count < 20) {
+        posMax = 5;
+    } else if (count < 20 && count > 10) {
+        posMax = 1;
+    } else {
+        posMax = 200;
+    }
+    return posMax;
+}
+
+syncMe::~syncMe() {
+    // db.close();
+}
--- /dev/null
+++ beagletomb-0.1.6/src/beaglemain.cpp.THIS
@@ -0,0 +1,873 @@
+/*
+ *  Written By: Grant Hutchinson
+ *  License: GPLv3.
+ *  h.g.utchinson@gmail.com
+ *  Copyright (C) 2012 by Grant Hutchinson
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#include "beaglemain.h"
+#include "ui_beaglemain.h"
+
+BeagleMain::BeagleMain(QWidget *parent) :
+    QMainWindow(parent),
+    ui(new Ui::BeagleMain)
+{
+    ui->setupUi(this);
+    Sync(0);
+    ui->MenuList->setEditTriggers(QAbstractItemView::NoEditTriggers);
+    ui->TitleList->setEditTriggers(QAbstractItemView::NoEditTriggers);
+    ui->PlayList->setEditTriggers(QAbstractItemView::NoEditTriggers);
+    ui->list_radio->setEditTriggers(QAbstractItemView::NoEditTriggers);
+    widget.setSeekSlider(ui->SEEK_slider);
+    widget.setVolumeSlider(ui->VOL_dial);
+    CON_MODE = 0;
+}
+
+/*
+  *  SYNCHRONIZE ALL DATA
+  */
+void BeagleMain::Sync(int type){
+    artSize = 0;
+    albSize = 0;
+    songSize = 0;
+    vidDirSize = 0;
+    vidSize = 0;
+   radSize = 0;
+    if(type == 0){
+        /// init playlist
+        pl.setCount(0);
+        pl.initPL();
+
+        plMode= 0; // set playlist mode to browse
+        playlistOpen = false; // set playlist open
+        /// if SQL file doesn't exist
+        if(pref.initDB() == false){
+            prefDg.show();
+            if (prefDg.exec()==QDialog::Accepted) {
+
+                //create cache directory
+                pref.createCache();
+                pref = prefDg.getPref();
+                //create custom sql db
+                pref.createDB();
+                /// write preferences to sql db
+                pref.writeDB();
+                pref.setInitDB();
+            }
+        }
+
+        else{
+            //// read from sql and fill songObjs
+            readDB rDB(pref.getSQL().c_str());
+            Artist = rDB.ArtistFill(Artist);
+            Album = rDB.AlbumFill(Album);
+            Song = rDB.SongFill(Song);
+            VidDir = rDB.VidDirFill(VidDir);
+            Video = rDB.VideoFill(Video);
+            /// read from sql and fill radio obj
+            Radio = rDB.RadioFill(&radSize);
+            Radio.setDB(pref.getSQL());
+            Radio.setSize(radSize);
+            RefillRadioPL();
+        }
+    }
+    else if(type == 1){
+
+        readDB rDB(pref.getSQL().c_str());
+        ///check database for previous radio stations
+        Radio = rDB.RadioFill(&radSize);
+        // read preferences prior to delete
+   //     pref.readDB();
+        pref.deleteDB(pref.getSQL().c_str());
+        ///
+        pref.createDB();
+
+        cout << "syncing.... " << pref.getServ() << "\t" << pref.getPort()<<  endl;
+        /// read from remote mysql write to local sqlite
+        syncMe sy(pref.getServ().c_str(), pref.getUser().c_str(), pref.getPass().c_str(), pref.getTable().c_str(), pref.getSQL().c_str());
+        /// write radio stations
+        Radio.writeDBFill();
+        /// write preferences to sql db
+        pref.writeDB();
+        pref.setInitDB();
+        cout << "reading.... " << endl;
+        /// read from sqlite to songObjs
+        Artist = rDB.ArtistFill(Artist);
+        Album = rDB.AlbumFill(Album);
+        Song = rDB.SongFill(Song);
+        VidDir = rDB.VidDirFill(VidDir);
+        Video = rDB.VideoFill(Video);
+        /// read from sql and fill radio obj
+        cout << "syncing radio" << endl;
+        Radio = rDB.RadioFill(&radSize);
+        Radio.setDB(pref.getSQL());
+        Radio.setSize(radSize);
+        RefillRadioPL();
+        cout << "Database synced!" << endl;
+    }
+}
+
+/*
+  *  UPDATE MENU LIST WITH ALL ARTISTS OR ALL ALBUMS
+  */
+void BeagleMain::updateMenu(int type){
+    QStringList curMenu;
+    m_Model = new QStringListModel(this);
+    if(type == 1){
+        /// update with artist
+        for(int i=0; i< Artist.getSize(); i++){
+            curMenu << Artist.getName(i);
+        }
+    }
+    else if(type == 2){
+        /// update with album
+        for(int i=0; i< Album.getSize(); i++){
+            curMenu << Album.getName(i);
+        }
+    }
+    else if(type == 3){
+        /// update with directories
+        for(int i=0; i< VidDir.getSize(); i++){
+            curMenu << VidDir.getName(i);
+        }
+    }
+
+
+    m_Model->setStringList(curMenu);
+    ui->MenuList->setModel(m_Model);
+}
+
+void BeagleMain::setMainPref(preferences my_pref){
+    pref = my_pref;
+}
+
+/*
+  *  UPDATE MENU LIST WITH ALBUMS FROM SELECTED
+  */
+void BeagleMain::updateAlbMenu(int select){
+    albCount = 0;
+    int selID = 0;
+    QStringList curAlb;
+    m_Model = new QStringListModel(this);
+    curAlbID = new int[MAX];
+    selID = Artist.getID(select);    /// selected ID
+
+    for(int i=0; i< Album.getSize(); i++){
+        if(Album.getPar(i) == selID ){
+            curAlb << Album.getName(i);
+            curAlbID[albCount] = Album.getID(i);
+            albCount++;
+        }
+    }
+
+    m_Model->setStringList(curAlb);
+    ui->MenuList->setModel(m_Model);
+}
+
+/*
+  *  UPDATE TITLE LIST WITH ALL SONGS
+  */
+void BeagleMain::updateTitle(){
+    t_Model = new QStringListModel(this);
+    QStringList songList;
+
+    for(int i = 0; i<= Song.getSize(); i++){
+        songList << Song.getName(i);
+    }
+    t_Model->setStringList(songList);
+    ui->TitleList->setModel(t_Model);
+
+}
+
+/*
+  *  UPDATE TITLE LIST WITH SONGS FROM SELECTED
+  */
+void BeagleMain::updateTitle(int selected){
+    songCount = 0;
+    vidCount = 0;
+    int selID = 0;
+    QStringList curSong;
+    t_Model = new QStringListModel(this);
+    curSongID = new int[MAX];
+    curVidID = new int[MAX];
+    if(MenuMode == 3){     ///  if ALL ALBUM
+        selID = Album.getID(selected);
+        for(int i = 0; i< Song.getSize(); i++){
+            if(Song.getPar(i) == selID){
+                curSong << Song.getName(i);
+                curSongID[songCount] = Song.getID(i);
+                songCount++;
+            }
+        }
+    }
+    else if(MenuMode == 4){    ////// if VIDEO DIR MODE
+        selID = VidDir.getID(selected);
+        for(int i = 0; i<= Video.getSize(); i++){
+            if(Video.getPar(i) == selID){
+                curSong << Video.getName(i);
+                curVidID[vidCount] = Video.getID(i);
+                vidCount++;
+            }
+        }
+    }
+    else{   /// IF ALBUM DIR MODE
+        selID = curAlbID[selected];
+        for(int i = 0; i<= Song.getSize(); i++){
+            if(Song.getPar(i) == selID){
+                curSong << Song.getName(i);
+                curSongID[songCount] = Song.getID(i);
+                songCount++;
+            }
+        }
+    }
+
+    t_Model->setStringList(curSong);
+    ui->TitleList->setModel(t_Model);
+
+}
+
+/*
+  * UPDATE with LOCAL Video directories
+  */
+void BeagleMain::updateLclVidDirs(){
+
+    vidDirecLocal = SyncVideoLocal.readLocalDB(2, vidDirecLocal);
+    t_Model = new QStringListModel(this);
+    QStringList dirList;
+
+    for(int i = 0; i< vidDirecLocal.getSize(); i++){
+        dirList << QString::fromStdString(string(vidDirecLocal.getName(i)));
+    }
+
+
+    t_Model->setStringList(dirList);
+    ui->MenuList->setModel(t_Model);
+}
+
+/*
+  * UPDATE with Local Video Files
+  */
+
+void BeagleMain::updateLclVideos(){
+    VideoLocal = SyncVideoLocal.readLocalDB(3, VideoLocal);
+    t_Model = new QStringListModel(this);
+    QStringList songList;
+
+    for(int i = 0; i< VideoLocal.getSize(); i++){
+        songList << QString::fromStdString(string(VideoLocal.getName(i)));
+    }
+    t_Model->setStringList(songList);
+    ui->TitleList->setModel(t_Model);
+}
+
+/*
+  * UPDATE with LOCAL Audio directories
+  */
+void BeagleMain::updateLclSongDirs(){
+
+    DirecLocal = SyncAudioLocal.readLocalDB(0, DirecLocal);
+    t_Model = new QStringListModel(this);
+    QStringList dirList;
+
+    for(int i = 0; i< DirecLocal.getSize(); i++){
+        dirList << QString::fromStdString(string(DirecLocal.getName(i)));
+    }
+    t_Model->setStringList(dirList);
+    ui->MenuList->setModel(t_Model);
+}
+
+/*
+  * UPDATE with Local Audio Files
+  */
+
+void BeagleMain::updateLclSongs(){
+    SongLocal = SyncAudioLocal.readLocalDB(1, SongLocal);
+    t_Model = new QStringListModel(this);
+    QStringList songList;
+
+    for(int i = 0; i< SongLocal.getSize(); i++){
+        songList << QString::fromStdString(string(SongLocal.getName(i)));
+    }
+    t_Model->setStringList(songList);
+    ui->TitleList->setModel(t_Model);
+}
+
+/*
+  *  Control for Start of remote File
+  */
+void BeagleMain::startSong(char *FinSong, int selID){
+
+    char * strBuffer;
+    strBuffer= new char[100];
+    sprintf(strBuffer, "http://%s:%s/content/media/object_id/%d/res_id/0", pref.getServ().c_str(), pref.getPort().c_str(), selID);
+    ui->SONG_lbl->setText((QString)FinSong);
+    widget.show();
+    widget.start(QStringList(strBuffer));
+}
+
+void BeagleMain::startLocal(char *finSong, char *finPath){
+
+    char *final;
+    final = new char[sizeof(finPath) + 100];
+    sprintf(final, "%s", finPath);
+    cout << "Final File Playing: " << final << endl;
+    ui->SONG_lbl->setText((QString)finSong);
+    widget.show();
+    widget.start(QStringList(final));
+}
+
+/*
+  * refill playlist list with playlist model from playlist object
+  */
+void BeagleMain::RefillMainPL(){
+    QStringList updatedList;
+   t_Model = new QStringListModel(this);
+    updatedList = pl.RefillPlaylist();
+    t_Model->setStringList(updatedList);
+    ui->PlayList->setModel(t_Model);
+}
+
+/*
+  * refill playlist list with playlist model from playlist user Folder
+  */
+void BeagleMain::RefillPLFolder(){
+    QStringList updatedList;
+   t_Model = new QStringListModel(this);
+    updatedList = pl.listDirectories(pl.getFullLocation().c_str());
+    t_Model->setStringList(updatedList);
+    ui->PlayList->setModel(t_Model);
+}
+
+void BeagleMain::PlaylistPlay(int selID){
+        char* FinSong;
+        for(int i = 0; i<= pl.getCount(); i++){
+            if(pl.getTrackID(i) == selID){
+                FinSong = new char[strlen(pl.getTrackName(i).c_str())+1];
+                strcpy(FinSong,pl.getTrackName(i).c_str());
+            }
+        }
+        // start song
+        startSong(FinSong, selID);
+    }
+/*
+  * MEM CLEANUP
+  */
+BeagleMain::~BeagleMain()
+{
+    delete ui;
+}
+
+/*
+  *When Sync Button is pressed
+  */
+void BeagleMain::on_SYNC_but_clicked()
+{
+    Sync(1);
+}
+
+/*
+  *When Mode combo button is changed, change the mode, update lists
+  */
+void BeagleMain::on_MODE_combo_currentIndexChanged(int index)
+{
+    if(index == 1){   //  update lists with artists
+        if(CON_MODE == 1){
+            updateMenu(1);
+            MenuMode=1;
+        }
+        else{
+             MenuMode=1;
+            updateLclSongDirs();
+        }
+    }
+    else if(index == 2){  // update lists with albums
+        if(CON_MODE == 1){
+            updateMenu(2);
+            MenuMode=3;
+        }
+        else{
+       //      updateLclAlbumDir();  // need to detect albums first.
+        }
+    }
+    else if(index == 3){  // update lists with songs
+        if(CON_MODE == 1){
+            updateTitle();
+            TitleMode = 1;
+        }
+        else{
+            updateLclSongs();
+        }
+
+    }
+    else if(index == 4){  // update lists with vid directories
+        if(CON_MODE == 1){
+            MenuMode = 4;
+            updateMenu(3);
+        }
+        else{
+             MenuMode = 4;
+            updateLclVidDirs();
+            updateLclVideos();
+        }
+    }
+}
+
+/*
+  *When Stop Button is pressed
+  */
+void BeagleMain::on_STOP_but_clicked()
+{
+    widget.stop();
+}
+
+/*
+  *When a track is double clicked from the TitleList, depending on which mode we are in
+  */
+void BeagleMain::on_TitleList_doubleClicked(QModelIndex index)
+{
+    int selID = 0;
+    int selected = 0;
+    selected = ui->TitleList->currentIndex().row();
+    int FinParentID = 0;
+
+    if(CON_MODE == 1) {
+
+        char *FinSong;
+        char *FinParent;
+        FinSong = new char[100];
+        FinParent = new char[100];
+
+        if(MenuMode == 2 || MenuMode == 3){
+            selID = curSongID[selected];
+            FinSong = checkSongObjByID(selID, Song);
+            FinParentID = checkSongObjParByID(selID,Song);
+            FinParent = checkSongObjByID(FinParentID, Song);
+        }
+        else if(MenuMode == 4){
+            selID = curVidID[selected];
+            FinSong = checkSongObjByID(selID, Video);
+            FinParentID = checkSongObjParByID(selID,Video);
+            FinParent = checkSongObjByID(FinParentID, Video);
+        }
+        else{
+            selID = Song.getID(selected);
+            FinSong = checkSongObjByID(selID, Song);
+            FinParentID = checkSongObjParByID(selID,Song);
+            FinParent = checkSongObjByID(FinParentID, Song);
+        }
+        // start song
+        startSong(FinSong, selID);
+    }
+    else{
+        char *finPath;
+        char *finSong;
+
+        if(MenuMode != 4){
+            finSong = new char[strlen(SongLocal.getName(selected))+10];
+            finPath = new char[strlen(SongLocal.getPath(selected))+10];
+            finSong = SongLocal.getName(selected);
+            finPath = SongLocal.getPath(selected);
+        }
+        else{
+            finSong = new char[strlen(VideoLocal.getName(selected))+10];
+            finPath = new char[strlen(VideoLocal.getPath(selected))+10];
+            finSong = VideoLocal.getName(selected);
+            finPath = VideoLocal.getPath(selected);
+        }
+        startLocal(finSong, finPath);
+    }
+
+
+}
+
+/*
+  *When the Main list is selected, depending on which mode we are in
+  */
+void BeagleMain::on_MenuList_clicked(QModelIndex index)
+{
+    int selected = ui->MenuList->currentIndex().row();
+
+    if(MenuMode == 1){
+        updateAlbMenu(selected);
+        MenuMode =2;
+    }
+    else if(MenuMode == 4){
+        updateTitle(selected);
+    }
+    else{
+        updateTitle(selected);
+    }
+}
+/*
+  * When vol dial has changed
+  */
+void BeagleMain::on_VOL_dial_valueChanged(int value)
+{
+
+}
+
+/*
+  * when seek slider has moved
+  */
+void BeagleMain::on_SEEK_slider_sliderMoved(int position)
+{
+    //   widget.seek((double)position, 0);
+}
+
+/*
+  * When play button is pressed and held, seek
+  */
+void BeagleMain::on_FWD_but_pressed()
+{
+
+    int curTime = ui->SEEK_slider->value();
+
+    int FutTime = curTime + 10;
+    widget.seek((double)FutTime, curTime);
+}
+
+/*
+  * When Play button clicked, play
+  */
+void BeagleMain::on_FWD_but_clicked()
+{
+    widget.play();
+}
+/*
+  * When Pause button clicked, pause
+  */
+void BeagleMain::on_PAUSE_but_clicked()
+{
+    widget.pause();
+}
+
+/*
+  * When preferences menu item selected, open preference window
+  */
+void BeagleMain::on_actionPreferences_2_activated()
+{
+    pref.readDB();
+    prefDg.setPref(pref);
+    prefDg.show();
+    if (prefDg.exec()==QDialog::Accepted) {
+        pref = prefDg.getPref();
+        //delete custom sql db
+      //  pref.deleteDB(pref.getSQL().c_str());
+        //create custom sql db
+      //  pref.createDB();
+        /// write preferences to sql db
+        pref.writeDB();
+    }
+}
+
+/*
+  * When About menu item selected, open about dialog
+  */
+void BeagleMain::on_actionAbout_activated()
+{
+    ab.show();
+    if(ab.exec()==QDialog::Accepted) {
+        ab.close();
+    }
+}
+
+/*
+  * When Sync Button is selected , sync
+  */
+void BeagleMain::on_actionSync_activated()
+{
+    Sync(1);
+}
+
+/*
+  * When Add button is selected, get selected item (depending on mode),
+  * add to list, refill list
+  */
+void BeagleMain::on_ADD_but_clicked()
+{
+    int selID = 0;
+    int selected = 0;
+    char * strBuffer;
+    strBuffer= new char[100];
+    selected = ui->TitleList->currentIndex().row();
+
+    if(MenuMode == 2 || MenuMode == 3){
+         selID = curSongID[selected];
+      strBuffer=checkSongObjByID(selID, Song);
+    }
+    else if(MenuMode == 4){
+         selID = curVidID[selected];
+       strBuffer=checkSongObjByID(selID, Video);
+    }
+    else{
+        selID = Song.getID(selected);
+        strBuffer=checkSongObjByID(selID, Song);
+    }
+    pl.AddTo(selID, strBuffer);
+    RefillMainPL();
+}
+
+
+/*
+  * when the playlist list is doubleclick get which item we've selected and play it
+  */
+void BeagleMain::on_PlayList_doubleClicked(QModelIndex index)
+{
+
+
+    int selected;
+    selected = ui->PlayList->currentIndex().row();
+    int selID = 0;
+    char *FinSong;
+
+       if(plMode == 1){
+           pl.readPLfile((pref.getPlaylistDir() + pl.getPLFolder(selected)).c_str());   /// edit with selected playlist currently defaulting
+            RefillMainPL();
+            playlistOpen = true;
+            plMode = 2;
+       }
+       else{
+           pl_selected = 0;
+           pl_selected = ui->PlayList->currentIndex().row();
+           selID = pl.getTrackID(pl_selected);
+           PlaylistPlay(selID);
+       }
+
+    /// thread adding future
+    /*
+    if(plMode == 1){
+        pl.readPLfile((pref.getPlaylistDir() + pl.getPLFolder(selected)).c_str());   /// edit with selected playlist currently defaulting
+         RefillMainPL();
+         playlistOpen = true;
+         plMode = 2;
+    }
+    else  if(plMode == 2){
+
+        pl_selected = 0;
+        pl_selected = ui->PlayList->currentIndex().row();
+        mplay.set(pl, pref, pl_selected);
+        mplay.run();
+        plMode = 3;
+    }
+    else if(plMode == 3){
+
+         pl_selected = 0;
+         pl_selected = ui->PlayList->currentIndex().row();
+         mplay.set(pl, pref, pl_selected);
+         mplay.run();
+         plMode = 2;
+     }*/
+}
+
+/*
+  * When Remove button is clicked
+  */
+void BeagleMain::on_REMOVE_but_clicked()
+{
+    int selected = 0;
+    pl.RemoveFrom(pl_selected);
+    RefillMainPL();
+}
+
+
+
+void BeagleMain::on_SAVE_but_clicked()
+{
+    string fileName, fileLocate;
+    newPL.show();
+    if(newPL.exec()==QDialog::Accepted){
+        if(newPL.plExists()){
+            fileName = newPL.getFile();
+             fileLocate = newPL.getLocate();
+             pl.setFullLocation(fileName, fileLocate);
+             pl.writePLfile();
+        }
+    }
+}
+
+void BeagleMain::on_OPEN_but_clicked()
+{
+    plMode = 0;
+    string fileName, fileLocate;
+    fileName = "";
+    fileLocate = "";
+
+        openPL.show();
+        if(openPL.exec()==QDialog::Accepted){
+           if(openPL.plExists()){
+               fileName = openPL.getFile();
+               fileLocate = openPL.getLocate();
+                 pl.setFullLocation(fileName, fileLocate);
+           }
+        }
+
+         /// list .pl files in preferreed directory
+        RefillPLFolder();
+        plMode = 1;
+
+}
+
+void BeagleMain::on_FFWD_but_clicked()
+{
+    int selID = 0;
+
+    pl_selected++;
+     selID = pl.getTrackID(pl_selected);
+    PlaylistPlay(selID);
+
+}
+
+
+void BeagleMain::on_RRWD_but_clicked()
+{
+       int selID = 0;
+    pl_selected--;
+     selID = pl.getTrackID(pl_selected);
+    PlaylistPlay(selID);
+}
+
+void BeagleMain::on_UP_but_clicked()
+{
+    pl.Move(2, pl_selected);
+    pl_selected--;
+    RefillMainPL();
+}
+
+void BeagleMain::on_DOWN_but_clicked()
+{
+    pl.Move(1, pl_selected);
+    pl_selected++;
+    RefillMainPL();
+}
+
+void BeagleMain::on_PlayList_clicked(QModelIndex index)
+{
+    pl_selected = ui->PlayList->currentIndex().row();
+}
+
+ void BeagleMain::closeEvent(QCloseEvent *event){
+
+     widget.close();
+ }
+
+void BeagleMain::on_actionDonate_2_triggered()
+{
+    QDesktopServices::openUrl(QUrl("https://flattr.com/profile/hutchgrant", QUrl::TolerantMode));
+}
+
+void BeagleMain::on_ADMIN_but_clicked()
+{
+    char mediatombAdd[100];
+    sprintf(mediatombAdd, "http://%s:%s", pref.getServ().c_str(), pref.getPort().c_str());
+    QDesktopServices::openUrl(QUrl(mediatombAdd, QUrl::TolerantMode));
+}
+
+void BeagleMain::on_but_RadAdd_clicked()
+{
+    QString Radio_url;
+    QString Radio_name;
+
+    Radio_url = ui->entry_radURL->text();
+    Radio_name = ui->entry_radName->text();
+
+    Radio.Add(Radio_name.toStdString(),Radio_url.toStdString());
+    radSize++;
+
+    Radio.writeDB();
+    RefillRadioPL();
+}
+
+void BeagleMain::on_but_RemRad_clicked()
+{
+    int pos = 0;
+    string pl_ItemName;
+    pos = ui->list_radio->currentIndex().row();
+    pl_ItemName = Radio.getName(pos);
+    Radio.Remove(pl_ItemName, pos);
+    readDB rDB(pref.getSQL().c_str());
+    Radio = rDB.RadioFill(&radSize);
+    RefillRadioPL();
+}
+
+void BeagleMain::on_list_radio_clicked(QModelIndex index)
+{
+
+}
+
+/*
+  * refill playlist list with playlist model from playlist object
+  */
+void BeagleMain::RefillRadioPL(){
+    QStringList updatedList;
+   r_Model = new QStringListModel(this);
+    updatedList = Radio.RefillPlaylist();
+    r_Model->setStringList(updatedList);
+    ui->list_radio->setModel(r_Model);
+
+}
+
+void BeagleMain::on_list_radio_doubleClicked(QModelIndex index)
+{
+    int pos =0;
+    pos = ui->list_radio->currentIndex().row();
+    string finalUrl, finalName;
+    finalUrl = Radio.getUrl(pos);
+    finalName = Radio.getName(pos);
+    ui->SONG_lbl->setText((QString)finalName.c_str());
+    widget.show();
+    widget.start(QStringList(finalUrl.c_str()));
+}
+
+/*
+  * Import Audio folder button
+  */
+void BeagleMain::on_but_import_aud_clicked()
+{
+    QDir usrDir = QFileDialog::getExistingDirectory(this, tr("Import a directory"), QDir::currentPath());  // get folder import directory
+    SyncAudioLocal.Sync(usrDir, 0);
+    updateLclSongDirs();
+    updateLclSongs();
+}
+
+/*
+  * Import Video folder button
+  */
+void BeagleMain::on_but_import_vid_clicked()
+{
+    QDir usrDir = QFileDialog::getExistingDirectory(this, tr("Import a directory"), QDir::currentPath());  // get folder import directory
+   SyncVideoLocal.Sync(usrDir, 1);
+   updateLclVidDirs();
+   updateLclVideos();
+}
+
+
+/*
+  *  Toggle button for remote / local
+  */
+void BeagleMain::on_but_remote_tog_clicked()
+{
+    if(CON_MODE == 1){
+        CON_MODE = 0;  // set connection mode local
+        cout << "viewing local library" << endl;
+    }
+    else{
+        CON_MODE = 1; // set connection mode remote
+        cout << "viewing remote library" << endl;
+    }
+}
+
+
--- /dev/null
+++ beagletomb-0.1.6/src/beaglemain.h.BASE
@@ -0,0 +1,161 @@
+/*
+ *  Written By: Grant Hutchinson
+ *  License: GPLv3.
+ *  h.g.utchinson@gmail.com
+ *  Copyright (C) 2012 by Grant Hutchinson
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#ifndef BEAGLEMAIN_H
+#define BEAGLEMAIN_H
+
+#include <QMainWindow>
+#include <stdlib.h>
+#include <stdio.h>
+#include "sync.h"
+#include "songObj.h"
+#include "readDB.h"
+#include "mplaycon.h"
+#include "prefdialog.h"
+#include "qmpwidget.h"
+#include "preferences.h"
+#include "about.h"
+#include "playlistobj.h"
+#include "newplaylist.h"
+#include "openplaylist.h"
+#include "radioObj.h"
+namespace Ui {
+class BeagleMain;
+}
+
+class BeagleMain : public QMainWindow
+{
+    Q_OBJECT
+
+public:
+
+    int MenuMode, TitleMode;
+    int albCount, songCount, vidCount, vidDirCount, radCount; ///  count of each item in the list
+    int *curAlbID, *curSongID, *curVidID, *curVidDirID;       ///  unique identifier for current file
+    int plMode;        /// playlist mode : 1 playlist browsing and 2: browsing tracks within playlist
+    int pl_selected;  /// global playlist selection
+     int title_selected;  /// global title selection
+
+    About ab;
+    PrefDialog prefDg;
+    preferences pref, pref2;
+    playlistobj pl;
+    newplaylist newPL;
+    openplaylist openPL;
+    QMPwidget widget;
+    mplayCon mplay;
+    songObj* Artist, *Song, *Album, *VidDir, *Video;
+    radioObj Radio;
+    int artSize, albSize, songSize, vidSize, vidDirSize, radSize;
+
+    bool playlistOpen;
+
+    void RefillRadioPL();
+    QStringList RefillRadList();
+
+    explicit BeagleMain(QWidget *parent = 0);
+   ~BeagleMain();
+
+    void updateMenu(int type);
+
+    void updateTitle();
+
+    void updateAlbMenu(int select);
+    void updateTitle(int select);
+    void Sync(int type);
+
+    bool isRunning();
+
+    void setMainPref(preferences pref);
+    void RefillMainPL();
+    void RefillPLFolder();
+    void startSong(char *FinSong, int selID);
+    void PlaylistPlay(int selID);
+    void closeEvent(QCloseEvent *event);
+
+private slots:
+    void on_SYNC_but_clicked();
+
+    void on_MODE_combo_currentIndexChanged(int index);
+
+    void on_STOP_but_clicked();
+
+    void on_TitleList_doubleClicked(QModelIndex index);
+
+    void on_MenuList_clicked(QModelIndex index);
+
+    void on_VOL_dial_valueChanged(int value);
+
+    void on_SEEK_slider_sliderMoved(int position);
+
+    void on_FWD_but_pressed();
+
+    void on_FWD_but_clicked();
+
+    void on_PAUSE_but_clicked();
+
+
+    void on_actionPreferences_2_activated();
+
+    void on_actionAbout_activated();
+
+    void on_actionSync_activated();
+
+    void on_ADD_but_clicked();
+
+    void on_PlayList_doubleClicked(QModelIndex index);
+
+    void on_REMOVE_but_clicked();
+
+    void on_SAVE_but_clicked();
+
+    void on_OPEN_but_clicked();
+
+    void on_FFWD_but_clicked();
+
+    void on_RRWD_but_clicked();
+
+    void on_UP_but_clicked();
+
+    void on_DOWN_but_clicked();
+
+    void on_PlayList_clicked(QModelIndex index);
+
+    void on_actionDonate_2_triggered();
+
+    void on_ADMIN_but_clicked();
+
+    void on_but_RadAdd_clicked();
+
+    void on_but_RemRad_clicked();
+
+    void on_list_radio_clicked(QModelIndex index);
+
+    void on_list_radio_doubleClicked(QModelIndex index);
+
+private:
+    Ui::BeagleMain *ui;
+    QStringListModel *t_Model;
+    QStringListModel *m_Model;
+    QStringListModel *r_Model;
+};
+
+#endif // BEAGLEMAIN_H
--- /dev/null
+++ beagletomb-0.1.6/src/beaglemain.cpp.BASE
@@ -0,0 +1,709 @@
+/*
+ *  Written By: Grant Hutchinson
+ *  License: GPLv3.
+ *  h.g.utchinson@gmail.com
+ *  Copyright (C) 2012 by Grant Hutchinson
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#include "beaglemain.h"
+#include "ui_beaglemain.h"
+
+BeagleMain::BeagleMain(QWidget *parent) :
+    QMainWindow(parent),
+    ui(new Ui::BeagleMain)
+{
+    ui->setupUi(this);
+    Sync(0);
+    ui->MenuList->setEditTriggers(QAbstractItemView::NoEditTriggers);
+    ui->TitleList->setEditTriggers(QAbstractItemView::NoEditTriggers);
+    ui->PlayList->setEditTriggers(QAbstractItemView::NoEditTriggers);
+    ui->list_radio->setEditTriggers(QAbstractItemView::NoEditTriggers);
+    widget.setSeekSlider(ui->SEEK_slider);
+    widget.setVolumeSlider(ui->VOL_dial);
+
+}
+
+/*
+  *  SYNCHRONIZE ALL DATA
+  */
+void BeagleMain::Sync(int type){
+    artSize = 0;
+    albSize = 0;
+    songSize = 0;
+    vidDirSize = 0;
+    vidSize = 0;
+   radSize = 0;
+    if(type == 0){
+        /// init playlist
+        pl.setCount(0);
+        pl.initPL();
+
+        plMode= 0; // set playlist mode to browse
+        playlistOpen = false; // set playlist open
+        /// if SQL file doesn't exist
+        if(pref.initDB() == false){
+            prefDg.show();
+            if (prefDg.exec()==QDialog::Accepted) {
+
+                //create cache directory
+                pref.createCache();
+                pref = prefDg.getPref();
+                //create custom sql db
+                pref.createDB();
+                /// write preferences to sql db
+                pref.writeDB();
+                pref.setInitDB();
+            }
+        }
+
+        else{
+            //// read from sql and fill songObjs
+            readDB rDB(pref.getSQL().c_str());
+            Artist = rDB.ArtistFill(&artSize);
+            Album = rDB.AlbumFill(&albSize);
+            Song = rDB.SongFill(&songSize);
+            VidDir = rDB.VidDirFill(&vidDirSize);
+            Video = rDB.VideoFill(&vidSize);
+            /// read from sql and fill radio obj
+            Radio = rDB.RadioFill(&radSize);
+            Radio.setDB(pref.getSQL());
+            Radio.setSize(radSize);
+            RefillRadioPL();
+        }
+    }
+    else if(type == 1){
+
+        readDB rDB(pref.getSQL().c_str());
+        ///check database for previous radio stations
+        Radio = rDB.RadioFill(&radSize);
+        // read preferences prior to delete
+   //     pref.readDB();
+        pref.deleteDB(pref.getSQL().c_str());
+        ///
+        pref.createDB();
+
+        cout << "syncing.... " << pref.getServ() << "\t" << pref.getPort()<<  endl;
+        /// read from remote mysql write to local sqlite
+        syncMe sy(pref.getServ().c_str(), pref.getUser().c_str(), pref.getPass().c_str(), pref.getTable().c_str(), pref.getSQL().c_str());
+        /// write radio stations
+        Radio.writeDBFill();
+        /// write preferences to sql db
+        pref.writeDB();
+        pref.setInitDB();
+        cout << "reading.... " << endl;
+        /// read from sqlite to songObjs
+        Artist = rDB.ArtistFill(&artSize);
+        Album = rDB.AlbumFill(&albSize);
+        Song = rDB.SongFill(&songSize);
+        VidDir = rDB.VidDirFill(&vidDirSize);
+        Video = rDB.VideoFill(&vidSize);
+        /// read from sql and fill radio obj
+        cout << "syncing radio" << endl;
+        Radio = rDB.RadioFill(&radSize);
+        Radio.setDB(pref.getSQL());
+        Radio.setSize(radSize);
+        RefillRadioPL();
+        cout << "Database synced!" << endl;
+    }
+}
+
+/*
+  *  UPDATE MENU LIST WITH ALL ARTISTS OR ALL ALBUMS
+  */
+void BeagleMain::updateMenu(int type){
+    QStringList curMenu;
+    m_Model = new QStringListModel(this);
+    if(type == 1){
+        /// update with artist
+        for(int i=0; i<= artSize; i++){
+            curMenu << Artist[i].getFile();
+        }
+    }
+    else if(type == 2){
+        /// update with album
+        for(int i=0; i<= albSize; i++){
+            curMenu << Album[i].getFile();
+        }
+    }
+    else if(type == 3){
+        /// update with directories
+        for(int i=0; i<=vidDirSize; i++){
+            curMenu << VidDir[i].getFile();
+        }
+    }
+
+
+    m_Model->setStringList(curMenu);
+    ui->MenuList->setModel(m_Model);
+}
+
+void BeagleMain::setMainPref(preferences my_pref){
+    pref = my_pref;
+}
+
+/*
+  *  UPDATE MENU LIST WITH ALBUMS FROM SELECTED
+  */
+void BeagleMain::updateAlbMenu(int select){
+    albCount = 0;
+    int selID = 0;
+    QStringList curAlb;
+    m_Model = new QStringListModel(this);
+    curAlbID = new int[MAX];
+    selID = Artist[select].getFileID();    /// selected ID
+
+    for(int i=0; i<= albSize; i++){
+        if(Album[i].getFilePar() == selID ){
+            curAlb << Album[i].getFile();
+            curAlbID[albCount] = Album[i].getFileID();
+            albCount++;
+        }
+    }
+
+    m_Model->setStringList(curAlb);
+    ui->MenuList->setModel(m_Model);
+}
+
+/*
+  *  UPDATE TITLE LIST WITH ALL SONGS
+  */
+void BeagleMain::updateTitle(){
+    t_Model = new QStringListModel(this);
+    QStringList songList;
+
+    for(int i = 0; i<= songSize; i++){
+        songList << Song[i].getFile();
+    }
+    t_Model->setStringList(songList);
+    ui->TitleList->setModel(t_Model);
+
+}
+
+/*
+  *  UPDATE TITLE LIST WITH SONGS FROM SELECTED
+  */
+void BeagleMain::updateTitle(int selected){
+    songCount = 0;
+    vidCount = 0;
+    int selID = 0;
+    QStringList curSong;
+    t_Model = new QStringListModel(this);
+    curSongID = new int[MAX];
+    curVidID = new int[MAX];
+    if(MenuMode == 3){     ///  if ALL ALBUM
+        selID = Album[selected].getFileID();
+        for(int i = 0; i<= songSize; i++){
+            if(Song[i].getFilePar() == selID){
+                curSong << Song[i].getFile();
+                curSongID[songCount] = Song[i].getFileID();
+                songCount++;
+            }
+        }
+    }
+    else if(MenuMode == 4){    ////// if VIDEO DIR MODE
+        selID = VidDir[selected].getFileID();
+        for(int i = 0; i<= vidSize; i++){
+            if(Video[i].getFilePar() == selID){
+                curSong << Video[i].getFile();
+                curVidID[vidCount] = Video[i].getFileID();
+                vidCount++;
+            }
+        }
+    }
+    else{   /// IF ALBUM DIR MODE
+        selID = curAlbID[selected];
+        for(int i = 0; i<= songSize; i++){
+            if(Song[i].getFilePar() == selID){
+                curSong << Song[i].getFile();
+                curSongID[songCount] = Song[i].getFileID();
+                songCount++;
+            }
+        }
+    }
+
+    t_Model->setStringList(curSong);
+    ui->TitleList->setModel(t_Model);
+
+}
+void BeagleMain::startSong(char *FinSong, int selID){
+
+    char * strBuffer;
+    strBuffer= new char[100];
+    sprintf(strBuffer, "http://%s:%s/content/media/object_id/%d/res_id/0", pref.getServ().c_str(), pref.getPort().c_str(), selID);
+    ui->SONG_lbl->setText((QString)FinSong);
+    widget.show();
+    widget.start(QStringList(strBuffer));
+}
+/*
+  * refill playlist list with playlist model from playlist object
+  */
+void BeagleMain::RefillMainPL(){
+    QStringList updatedList;
+   t_Model = new QStringListModel(this);
+    updatedList = pl.RefillPlaylist();
+    t_Model->setStringList(updatedList);
+    ui->PlayList->setModel(t_Model);
+}
+
+/*
+  * refill playlist list with playlist model from playlist user Folder
+  */
+void BeagleMain::RefillPLFolder(){
+    QStringList updatedList;
+   t_Model = new QStringListModel(this);
+    updatedList = pl.listDirectories(pl.getFullLocation().c_str());
+    t_Model->setStringList(updatedList);
+    ui->PlayList->setModel(t_Model);
+}
+
+void BeagleMain::PlaylistPlay(int selID){
+        char* FinSong;
+        for(int i = 0; i<= pl.getCount(); i++){
+            if(pl.getTrackID(i) == selID){
+                FinSong = new char[strlen(pl.getTrackName(i).c_str())+1];
+                strcpy(FinSong,pl.getTrackName(i).c_str());
+            }
+        }
+        // start song
+        startSong(FinSong, selID);
+    }
+/*
+  * MEM CLEANUP
+  */
+BeagleMain::~BeagleMain()
+{
+    delete ui;
+    delete [] Artist;
+    delete [] Album;
+    delete [] Song;
+    delete [] Video;
+    delete [] VidDir;
+}
+
+/*
+  *When Sync Button is pressed
+  */
+void BeagleMain::on_SYNC_but_clicked()
+{
+    Sync(1);
+}
+
+/*
+  *When Mode combo button is changed, change the mode, update lists
+  */
+void BeagleMain::on_MODE_combo_currentIndexChanged(int index)
+{
+    if(index == 1){   //  update lists with artists
+        updateMenu(1);
+        MenuMode=1;
+    }
+    else if(index == 2){  // update lists with albums
+        updateMenu(2);
+        MenuMode=3;
+    }
+    else if(index == 3){  // update lists with songs
+        updateTitle();
+        TitleMode = 1;
+    }
+    else if(index == 4){  // update lists with vid directories
+        MenuMode = 4;
+        updateMenu(3);
+    }
+}
+
+/*
+  *When Stop Button is pressed
+  */
+void BeagleMain::on_STOP_but_clicked()
+{
+    widget.stop();
+}
+
+/*
+  *When a track is double clicked from the TitleList, depending on which mode we are in
+  */
+void BeagleMain::on_TitleList_doubleClicked(QModelIndex index)
+{
+    int selID = 0;
+    int selected = 0;
+    selected = ui->TitleList->currentIndex().row();
+    int FinParentID = 0;
+    char *FinSong;
+    char *FinParent;
+
+    FinSong = new char[100];
+    FinParent = new char[100];
+
+    if(MenuMode == 2 || MenuMode == 3){
+        selID = curSongID[selected];
+        FinSong = checkSongObjByID(selID, Song, songSize);
+        FinParentID = checkSongObjParByID(selID,Song, songSize);
+        FinParent = checkSongObjByID(FinParentID, Song, songSize);
+    }
+    else if(MenuMode == 4){
+        selID = curVidID[selected];
+        FinSong = checkSongObjByID(selID, Video, vidSize);
+        FinParentID = checkSongObjParByID(selID,Video, vidSize);
+        FinParent = checkSongObjByID(FinParentID, Video, vidSize);
+    }
+    else{
+        selID = Song[selected].getFileID();
+        FinSong = checkSongObjByID(selID, Song, songSize);
+        FinParentID = checkSongObjParByID(selID,Song, songSize);
+        FinParent = checkSongObjByID(FinParentID, Song, songSize);
+    }
+    // start song
+    startSong(FinSong, selID);
+}
+
+/*
+  *When the Main list is selected, depending on which mode we are in
+  */
+void BeagleMain::on_MenuList_clicked(QModelIndex index)
+{
+    int selected = ui->MenuList->currentIndex().row();
+
+    if(MenuMode == 1){
+        updateAlbMenu(selected);
+        MenuMode =2;
+    }
+    else if(MenuMode == 4){
+        updateTitle(selected);
+    }
+    else{
+        updateTitle(selected);
+    }
+}
+/*
+  * When vol dial has changed
+  */
+void BeagleMain::on_VOL_dial_valueChanged(int value)
+{
+
+}
+
+/*
+  * when seek slider has moved
+  */
+void BeagleMain::on_SEEK_slider_sliderMoved(int position)
+{
+    //   widget.seek((double)position, 0);
+}
+
+/*
+  * When play button is pressed and held, seek
+  */
+void BeagleMain::on_FWD_but_pressed()
+{
+
+    int curTime = ui->SEEK_slider->value();
+
+    int FutTime = curTime + 10;
+    widget.seek((double)FutTime, curTime);
+}
+
+/*
+  * When Play button clicked, play
+  */
+void BeagleMain::on_FWD_but_clicked()
+{
+    widget.play();
+}
+/*
+  * When Pause button clicked, pause
+  */
+void BeagleMain::on_PAUSE_but_clicked()
+{
+    widget.pause();
+}
+
+/*
+  * When preferences menu item selected, open preference window
+  */
+void BeagleMain::on_actionPreferences_2_activated()
+{
+    pref.readDB();
+    prefDg.setPref(pref);
+    prefDg.show();
+    if (prefDg.exec()==QDialog::Accepted) {
+        pref = prefDg.getPref();
+        //delete custom sql db
+      //  pref.deleteDB(pref.getSQL().c_str());
+        //create custom sql db
+      //  pref.createDB();
+        /// write preferences to sql db
+        pref.writeDB();
+    }
+}
+
+/*
+  * When About menu item selected, open about dialog
+  */
+void BeagleMain::on_actionAbout_activated()
+{
+    ab.show();
+    if(ab.exec()==QDialog::Accepted) {
+        ab.close();
+    }
+}
+
+/*
+  * When Sync Button is selected , sync
+  */
+void BeagleMain::on_actionSync_activated()
+{
+    Sync(1);
+}
+
+/*
+  * When Add button is selected, get selected item (depending on mode),
+  * add to list, refill list
+  */
+void BeagleMain::on_ADD_but_clicked()
+{
+    int selID = 0;
+    int selected = 0;
+    char * strBuffer;
+    strBuffer= new char[100];
+    selected = ui->TitleList->currentIndex().row();
+
+    if(MenuMode == 2 || MenuMode == 3){
+         selID = curSongID[selected];
+      strBuffer=checkSongObjByID(selID, Song, songSize);
+    }
+    else if(MenuMode == 4){
+         selID = curVidID[selected];
+       strBuffer=checkSongObjByID(selID, Video, vidSize);
+    }
+    else{
+        selID = Song[selected].getFileID();
+        strBuffer=checkSongObjByID(selID, Song, songSize);
+    }
+    pl.AddTo(selID, strBuffer);
+    RefillMainPL();
+}
+
+
+/*
+  * when the playlist list is doubleclick get which item we've selected and play it
+  */
+void BeagleMain::on_PlayList_doubleClicked(QModelIndex index)
+{
+
+
+    int selected;
+    selected = ui->PlayList->currentIndex().row();
+    int selID = 0;
+    char *FinSong;
+
+       if(plMode == 1){
+           pl.readPLfile((pref.getPlaylistDir() + pl.getPLFolder(selected)).c_str());   /// edit with selected playlist currently defaulting
+            RefillMainPL();
+            playlistOpen = true;
+            plMode = 2;
+       }
+       else{
+           pl_selected = 0;
+           pl_selected = ui->PlayList->currentIndex().row();
+           selID = pl.getTrackID(pl_selected);
+           PlaylistPlay(selID);
+       }
+
+    /// thread adding future
+    /*
+    if(plMode == 1){
+        pl.readPLfile((pref.getPlaylistDir() + pl.getPLFolder(selected)).c_str());   /// edit with selected playlist currently defaulting
+         RefillMainPL();
+         playlistOpen = true;
+         plMode = 2;
+    }
+    else  if(plMode == 2){
+
+        pl_selected = 0;
+        pl_selected = ui->PlayList->currentIndex().row();
+        mplay.set(pl, pref, pl_selected);
+        mplay.run();
+        plMode = 3;
+    }
+    else if(plMode == 3){
+
+         pl_selected = 0;
+         pl_selected = ui->PlayList->currentIndex().row();
+         mplay.set(pl, pref, pl_selected);
+         mplay.run();
+         plMode = 2;
+     }*/
+}
+
+/*
+  * When Remove button is clicked
+  */
+void BeagleMain::on_REMOVE_but_clicked()
+{
+    int selected = 0;
+    pl.RemoveFrom(pl_selected);
+    RefillMainPL();
+}
+
+
+
+void BeagleMain::on_SAVE_but_clicked()
+{
+    string fileName, fileLocate;
+    newPL.show();
+    if(newPL.exec()==QDialog::Accepted){
+        if(newPL.plExists()){
+            fileName = newPL.getFile();
+             fileLocate = newPL.getLocate();
+             pl.setFullLocation(fileName, fileLocate);
+             pl.writePLfile();
+        }
+    }
+}
+
+void BeagleMain::on_OPEN_but_clicked()
+{
+    plMode = 0;
+    string fileName, fileLocate;
+    fileName = "";
+    fileLocate = "";
+
+        openPL.show();
+        if(openPL.exec()==QDialog::Accepted){
+           if(openPL.plExists()){
+               fileName = openPL.getFile();
+               fileLocate = openPL.getLocate();
+                 pl.setFullLocation(fileName, fileLocate);
+           }
+        }
+
+         /// list .pl files in preferreed directory
+        RefillPLFolder();
+        plMode = 1;
+
+}
+
+void BeagleMain::on_FFWD_but_clicked()
+{
+    int selID = 0;
+
+    pl_selected++;
+     selID = pl.getTrackID(pl_selected);
+    PlaylistPlay(selID);
+
+}
+
+
+void BeagleMain::on_RRWD_but_clicked()
+{
+       int selID = 0;
+    pl_selected--;
+     selID = pl.getTrackID(pl_selected);
+    PlaylistPlay(selID);
+}
+
+void BeagleMain::on_UP_but_clicked()
+{
+    pl.Move(2, pl_selected);
+    pl_selected--;
+    RefillMainPL();
+}
+
+void BeagleMain::on_DOWN_but_clicked()
+{
+    pl.Move(1, pl_selected);
+    pl_selected++;
+    RefillMainPL();
+}
+
+void BeagleMain::on_PlayList_clicked(QModelIndex index)
+{
+    pl_selected = ui->PlayList->currentIndex().row();
+}
+
+ void BeagleMain::closeEvent(QCloseEvent *event){
+
+     widget.close();
+ }
+
+void BeagleMain::on_actionDonate_2_triggered()
+{
+    QDesktopServices::openUrl(QUrl("https://flattr.com/profile/hutchgrant", QUrl::TolerantMode));
+}
+
+void BeagleMain::on_ADMIN_but_clicked()
+{
+    char mediatombAdd[100];
+    sprintf(mediatombAdd, "http://%s:%s", pref.getServ().c_str(), pref.getPort().c_str());
+    QDesktopServices::openUrl(QUrl(mediatombAdd, QUrl::TolerantMode));
+}
+
+void BeagleMain::on_but_RadAdd_clicked()
+{
+    QString Radio_url;
+    QString Radio_name;
+
+    Radio_url = ui->entry_radURL->text();
+    Radio_name = ui->entry_radName->text();
+
+    Radio.Add(Radio_name.toStdString(),Radio_url.toStdString());
+    radSize++;
+
+    Radio.writeDB();
+    RefillRadioPL();
+}
+
+void BeagleMain::on_but_RemRad_clicked()
+{
+    int pos = 0;
+    string pl_ItemName;
+    pos = ui->list_radio->currentIndex().row();
+    pl_ItemName = Radio.getName(pos);
+    Radio.Remove(pl_ItemName, pos);
+    readDB rDB(pref.getSQL().c_str());
+    Radio = rDB.RadioFill(&radSize);
+    RefillRadioPL();
+}
+
+void BeagleMain::on_list_radio_clicked(QModelIndex index)
+{
+
+}
+
+/*
+  * refill playlist list with playlist model from playlist object
+  */
+void BeagleMain::RefillRadioPL(){
+    QStringList updatedList;
+   r_Model = new QStringListModel(this);
+    updatedList = Radio.RefillPlaylist();
+    r_Model->setStringList(updatedList);
+    ui->list_radio->setModel(r_Model);
+
+}
+
+void BeagleMain::on_list_radio_doubleClicked(QModelIndex index)
+{
+    int pos =0;
+    pos = ui->list_radio->currentIndex().row();
+    string finalUrl, finalName;
+    finalUrl = Radio.getUrl(pos);
+    finalName = Radio.getName(pos);
+    ui->SONG_lbl->setText((QString)finalName.c_str());
+    widget.show();
+    widget.start(QStringList(finalUrl.c_str()));
+}
--- beagletomb-0.1.6.orig/src/readDB.cpp
+++ beagletomb-0.1.6/src/readDB.cpp
@@ -24,29 +24,6 @@
 readDB::readDB(const char *dbLocation) {
     DBlocation2 = new char[strlen(dbLocation) + 1];
     strcpy(DBlocation2, dbLocation);
-
-    Artist = new songObj[MAX];
-    for(int i = 0; i<= MAX; i++){
-        Artist[i].set("-",0,0);
-    }
-
-    Album = new songObj[MAX];
-    for(int i = 0; i<= MAX; i++){
-        Album[i].set("-",0,0);
-    }
-    Song = new songObj[MAX];
-    for(int i = 0; i<= MAX; i++){
-        Song[i].set("-", 0, 0);
-    }
-    VidDir = new songObj[MAX];
-    for(int i = 0; i<= MAX; i++){
-        VidDir[i].set("-", 0, 0);
-    }
-    Video = new songObj[MAX];
-    for(int i = 0; i<= MAX; i++){
-        Video[i].set("-", 0, 0);
-    }
-
 }
 
 void readDB::OpenDB(){
@@ -55,7 +32,7 @@ void readDB::OpenDB(){
 
 }
 
-songObj* readDB::SongFill(int *songSize){
+fileObj& readDB::SongFill(fileObj& Song){
     int count = 0;
      if(db2.open()){
        QSqlQuery query(db2);
@@ -68,21 +45,16 @@ songObj* readDB::SongFill(int *songSize)
          QString QVal3 = query.value(3).toString();
 
          if(QVal2.toInt() != 0){
-             string QstrConvert = QVal1.toStdString();
-             char *QVal1Convert;
-             QVal1Convert = new char[QstrConvert.length() + 1];
-             strcpy(QVal1Convert, QstrConvert.c_str());
-             Song[count].set(QVal1Convert, QVal2.toInt(), QVal3.toInt());
+             Song.set(count, QVal2.toInt(), QVal3.toInt(), QVal1.toStdString().c_str());
              count++;
          }
      }
-     *songSize = count;
      db2.close();
     }
     return Song;
 }
 
-songObj* readDB::AlbumFill(int *albSize){
+fileObj& readDB::AlbumFill(fileObj& Album){
 
     int count = 0;
      if(db2.open()){
@@ -95,21 +67,16 @@ songObj* readDB::AlbumFill(int *albSize)
                 QString QVal3 = query.value(3).toString();
 
                 if(QVal2.toInt() != 0){
-                    string QstrConvert = QVal1.toStdString();
-                    char *QVal1Convert;
-                    QVal1Convert = new char[QstrConvert.length() + 1];
-                    strcpy(QVal1Convert, QstrConvert.c_str());
-                    Album[count].set(QVal1Convert, QVal2.toInt(), QVal3.toInt());
+                    Album.set(count, QVal2.toInt(), QVal3.toInt(), QVal1.toStdString().c_str());
                     count++;
                 }
             }
-            *albSize = count;
              db2.close();
     }
     return Album;
 }
 
-songObj* readDB::ArtistFill( int *artSize){
+fileObj& readDB::ArtistFill(fileObj& Artist){
     OpenDB();
     int count = 0;
     if(db2.open()){
@@ -122,20 +89,15 @@ songObj* readDB::ArtistFill( int *artSiz
                 QString QVal3 = query.value(3).toString();
 
                 if(QVal2.toInt() != 0){
-                    string QstrConvert = QVal1.toStdString();
-                    char *QVal1Convert;
-                    QVal1Convert = new char[QstrConvert.length() + 1];
-                    strcpy(QVal1Convert, QstrConvert.c_str());
-                    Artist[count].set(QVal1Convert, QVal2.toInt(), QVal3.toInt());
+                    Artist.set(count, QVal2.toInt(), QVal3.toInt(), QVal1.toStdString().c_str());
                     count++;
                 }
             }
-            *artSize = count;
              db2.close();
     }
     return Artist;
 }
-songObj* readDB::VidDirFill( int *vidDirSize){
+fileObj& readDB::VidDirFill( fileObj& VidDir){
 
     int count = 0;
     if(db2.open()){
@@ -152,16 +114,15 @@ songObj* readDB::VidDirFill( int *vidDir
                     char *QVal1Convert;
                     QVal1Convert = new char[QstrConvert.length() + 1];
                     strcpy(QVal1Convert, QstrConvert.c_str());
-                    VidDir[count].set(QVal1Convert, QVal2.toInt(), QVal3.toInt());
+                    VidDir.set(count, QVal2.toInt(), QVal3.toInt(), QVal1.toStdString().c_str());
                     count++;
                 }
             }
-            *vidDirSize = count;
              db2.close();
     }
     return VidDir;
 }
-songObj* readDB::VideoFill( int *vidSize){
+fileObj& readDB::VideoFill( fileObj& Video){
 
     int count = 0;
     if(db2.open()){
@@ -178,11 +139,10 @@ songObj* readDB::VideoFill( int *vidSize
                     char *QVal1Convert;
                     QVal1Convert = new char[QstrConvert.length() + 1];
                     strcpy(QVal1Convert, QstrConvert.c_str());
-                    Video[count].set(QVal1Convert, QVal2.toInt(), QVal3.toInt());
+                    Video.set(count, QVal2.toInt(), QVal3.toInt(), QVal1.toStdString().c_str());
                     count++;
                 }
             }
-            *vidSize = count;
              db2.close();
     }
     return Video;
@@ -222,7 +182,7 @@ radioObj readDB::RadioFill(int *radSize)
 
 }
 
-void readDB::display(int artSize, int albSize, int songSize){
+void readDB::display( fileObj&Artist, fileObj& Song,fileObj& Album ){
     int choice = 0;
     bool Exit = 0;
     while(!Exit){
@@ -232,22 +192,16 @@ void readDB::display(int artSize, int al
 	cin >> choice;
 
 	if(choice == 1){
-            for(int i = 0; i<=artSize; i++){
-                cout << Artist[i];
-            }
-            cout << "total artists: " << artSize;
+            Artist.display();
+            cout << "total artists: " << Artist.getSize();
 	}
 	if(choice == 2){
-            for(int i = 0; i<=albSize; i++){
-                cout << Album[i];
-            }
-            cout << "Total Albums: " << albSize;
+            Album.display();
+            cout << "Total Albums: " << Album.getSize();
 	}
 	if(choice == 3){
-            for(int i = 0; i<=songSize; i++){
-                cout << Song[i];
-            }
-            cout << "Total Songs: " << songSize;
+            Song.display();
+            cout << "Total Songs: " << Song.getSize();
 	}
 	if(choice == 4){
             Exit = 1;
--- beagletomb-0.1.6.orig/src/beaglemain.ui
+++ beagletomb-0.1.6/src/beaglemain.ui
@@ -6,25 +6,25 @@
    <rect>
     <x>0</x>
     <y>0</y>
-    <width>720</width>
+    <width>721</width>
     <height>460</height>
    </rect>
   </property>
   <property name="minimumSize">
    <size>
-    <width>720</width>
+    <width>721</width>
     <height>460</height>
    </size>
   </property>
   <property name="windowTitle">
-   <string>BeagleTomb v.0.1.6</string>
+   <string>BeagleTomb v.0.1.7</string>
   </property>
   <widget class="QWidget" name="centralWidget">
    <widget class="QListView" name="MenuList">
     <property name="geometry">
      <rect>
       <x>10</x>
-      <y>0</y>
+      <y>30</y>
       <width>256</width>
       <height>271</height>
      </rect>
@@ -40,7 +40,7 @@
     <property name="geometry">
      <rect>
       <x>270</x>
-      <y>0</y>
+      <y>30</y>
       <width>256</width>
       <height>271</height>
      </rect>
@@ -58,7 +58,7 @@
       <x>530</x>
       <y>0</y>
       <width>181</width>
-      <height>271</height>
+      <height>301</height>
      </rect>
     </property>
     <property name="minimumSize">
@@ -68,7 +68,7 @@
      </size>
     </property>
     <property name="toolTip">
-     <string>Sync Menu!</string>
+     <string/>
     </property>
     <property name="currentIndex">
      <number>1</number>
@@ -83,7 +83,7 @@
         <x>1</x>
         <y>1</y>
         <width>170</width>
-        <height>160</height>
+        <height>200</height>
        </rect>
       </property>
       <property name="sizePolicy">
@@ -95,315 +95,405 @@
       <property name="minimumSize">
        <size>
         <width>170</width>
-        <height>160</height>
+        <height>200</height>
        </size>
       </property>
       <property name="maximumSize">
        <size>
         <width>170</width>
-        <height>160</height>
+        <height>200</height>
        </size>
       </property>
       <property name="toolTip">
-       <string>Playist not working yet, coming soon</string>
+       <string>loop/shuffle coming soon</string>
       </property>
       <property name="resizeMode">
        <enum>QListView::Adjust</enum>
       </property>
      </widget>
-     <widget class="QPushButton" name="DOWN_but">
-      <property name="geometry">
-       <rect>
-        <x>60</x>
-        <y>201</y>
-        <width>55</width>
-        <height>30</height>
-       </rect>
-      </property>
-      <property name="minimumSize">
-       <size>
-        <width>55</width>
-        <height>30</height>
-       </size>
-      </property>
-      <property name="maximumSize">
-       <size>
-        <width>55</width>
-        <height>30</height>
-       </size>
-      </property>
-      <property name="text">
-       <string>Down</string>
-      </property>
-     </widget>
-     <widget class="QPushButton" name="UP_but">
-      <property name="geometry">
-       <rect>
-        <x>3</x>
-        <y>201</y>
-        <width>55</width>
-        <height>30</height>
-       </rect>
-      </property>
-      <property name="minimumSize">
-       <size>
-        <width>55</width>
-        <height>30</height>
-       </size>
-      </property>
-      <property name="maximumSize">
-       <size>
-        <width>55</width>
-        <height>30</height>
-       </size>
-      </property>
-      <property name="text">
-       <string>Up</string>
-      </property>
-     </widget>
-     <widget class="QPushButton" name="OPEN_but">
+     <widget class="QWidget" name="">
       <property name="geometry">
        <rect>
-        <x>117</x>
-        <y>201</y>
-        <width>55</width>
-        <height>30</height>
-       </rect>
-      </property>
-      <property name="minimumSize">
-       <size>
-        <width>55</width>
-        <height>30</height>
-       </size>
-      </property>
-      <property name="maximumSize">
-       <size>
-        <width>55</width>
-        <height>30</height>
-       </size>
-      </property>
-      <property name="text">
-       <string>Open</string>
-      </property>
-     </widget>
-     <widget class="QPushButton" name="ADD_but">
-      <property name="geometry">
-       <rect>
-        <x>3</x>
-        <y>166</y>
-        <width>55</width>
-        <height>30</height>
-       </rect>
-      </property>
-      <property name="minimumSize">
-       <size>
-        <width>55</width>
-        <height>30</height>
-       </size>
-      </property>
-      <property name="maximumSize">
-       <size>
-        <width>55</width>
-        <height>30</height>
-       </size>
-      </property>
-      <property name="text">
-       <string>Add</string>
-      </property>
-     </widget>
-     <widget class="QPushButton" name="SAVE_but">
-      <property name="geometry">
-       <rect>
-        <x>117</x>
-        <y>166</y>
-        <width>55</width>
-        <height>30</height>
-       </rect>
-      </property>
-      <property name="minimumSize">
-       <size>
-        <width>55</width>
-        <height>30</height>
-       </size>
-      </property>
-      <property name="maximumSize">
-       <size>
-        <width>55</width>
-        <height>30</height>
-       </size>
-      </property>
-      <property name="text">
-       <string>Save</string>
-      </property>
-     </widget>
-     <widget class="QPushButton" name="REMOVE_but">
-      <property name="geometry">
-       <rect>
-        <x>60</x>
-        <y>166</y>
-        <width>55</width>
-        <height>30</height>
+        <x>0</x>
+        <y>200</y>
+        <width>171</width>
+        <height>72</height>
        </rect>
       </property>
-      <property name="minimumSize">
-       <size>
-        <width>55</width>
-        <height>30</height>
-       </size>
-      </property>
-      <property name="maximumSize">
-       <size>
-        <width>55</width>
-        <height>30</height>
-       </size>
-      </property>
-      <property name="text">
-       <string>Remove</string>
-      </property>
+      <layout class="QVBoxLayout" name="verticalLayout_2">
+       <item>
+        <layout class="QHBoxLayout" name="horizontalLayout_4">
+         <item>
+          <widget class="QPushButton" name="ADD_but">
+           <property name="minimumSize">
+            <size>
+             <width>55</width>
+             <height>30</height>
+            </size>
+           </property>
+           <property name="maximumSize">
+            <size>
+             <width>55</width>
+             <height>30</height>
+            </size>
+           </property>
+           <property name="text">
+            <string>Add</string>
+           </property>
+          </widget>
+         </item>
+         <item>
+          <widget class="QPushButton" name="REMOVE_but">
+           <property name="minimumSize">
+            <size>
+             <width>55</width>
+             <height>30</height>
+            </size>
+           </property>
+           <property name="maximumSize">
+            <size>
+             <width>55</width>
+             <height>30</height>
+            </size>
+           </property>
+           <property name="text">
+            <string>Remove</string>
+           </property>
+          </widget>
+         </item>
+         <item>
+          <widget class="QPushButton" name="SAVE_but">
+           <property name="minimumSize">
+            <size>
+             <width>55</width>
+             <height>30</height>
+            </size>
+           </property>
+           <property name="maximumSize">
+            <size>
+             <width>55</width>
+             <height>30</height>
+            </size>
+           </property>
+           <property name="text">
+            <string>Save</string>
+           </property>
+          </widget>
+         </item>
+        </layout>
+       </item>
+       <item>
+        <layout class="QHBoxLayout" name="horizontalLayout_8">
+         <item>
+          <widget class="QPushButton" name="UP_but">
+           <property name="minimumSize">
+            <size>
+             <width>55</width>
+             <height>30</height>
+            </size>
+           </property>
+           <property name="maximumSize">
+            <size>
+             <width>55</width>
+             <height>30</height>
+            </size>
+           </property>
+           <property name="text">
+            <string>Up</string>
+           </property>
+          </widget>
+         </item>
+         <item>
+          <widget class="QPushButton" name="DOWN_but">
+           <property name="minimumSize">
+            <size>
+             <width>55</width>
+             <height>30</height>
+            </size>
+           </property>
+           <property name="maximumSize">
+            <size>
+             <width>55</width>
+             <height>30</height>
+            </size>
+           </property>
+           <property name="text">
+            <string>Down</string>
+           </property>
+          </widget>
+         </item>
+         <item>
+          <widget class="QPushButton" name="OPEN_but">
+           <property name="minimumSize">
+            <size>
+             <width>55</width>
+             <height>30</height>
+            </size>
+           </property>
+           <property name="maximumSize">
+            <size>
+             <width>55</width>
+             <height>30</height>
+            </size>
+           </property>
+           <property name="text">
+            <string>Open</string>
+           </property>
+          </widget>
+         </item>
+        </layout>
+       </item>
+      </layout>
      </widget>
     </widget>
     <widget class="QWidget" name="tab">
      <attribute name="title">
       <string>Radio</string>
      </attribute>
-     <widget class="QPushButton" name="but_RadAdd">
-      <property name="geometry">
-       <rect>
-        <x>0</x>
-        <y>210</y>
-        <width>85</width>
-        <height>27</height>
-       </rect>
-      </property>
-      <property name="minimumSize">
-       <size>
-        <width>80</width>
-        <height>27</height>
-       </size>
-      </property>
-      <property name="text">
-       <string>Add</string>
-      </property>
-     </widget>
-     <widget class="QPushButton" name="but_RemRad">
-      <property name="geometry">
-       <rect>
-        <x>90</x>
-        <y>210</y>
-        <width>81</width>
-        <height>27</height>
-       </rect>
-      </property>
-      <property name="minimumSize">
-       <size>
-        <width>80</width>
-        <height>27</height>
-       </size>
-      </property>
-      <property name="text">
-       <string>Remove</string>
-      </property>
-     </widget>
      <widget class="QListView" name="list_radio">
       <property name="geometry">
        <rect>
         <x>0</x>
         <y>0</y>
         <width>171</width>
-        <height>151</height>
+        <height>171</height>
        </rect>
       </property>
      </widget>
-     <widget class="QWidget" name="layoutWidget_2">
+     <widget class="QWidget" name="">
       <property name="geometry">
        <rect>
         <x>0</x>
-        <y>150</y>
+        <y>170</y>
         <width>171</width>
-        <height>27</height>
+        <height>97</height>
        </rect>
       </property>
-      <layout class="QHBoxLayout" name="horizontalLayout_6">
+      <layout class="QVBoxLayout" name="verticalLayout_7">
        <item>
-        <widget class="QLabel" name="label_4">
-         <property name="text">
-          <string>Name</string>
-         </property>
-        </widget>
+        <layout class="QHBoxLayout" name="horizontalLayout_6">
+         <item>
+          <widget class="QLabel" name="label_4">
+           <property name="text">
+            <string>Name</string>
+           </property>
+          </widget>
+         </item>
+         <item>
+          <widget class="QLineEdit" name="entry_radName"/>
+         </item>
+        </layout>
        </item>
        <item>
-        <widget class="QLineEdit" name="entry_radName"/>
+        <layout class="QHBoxLayout" name="horizontalLayout_5">
+         <item>
+          <widget class="QLabel" name="label_3">
+           <property name="text">
+            <string>URL     </string>
+           </property>
+          </widget>
+         </item>
+         <item>
+          <widget class="QLineEdit" name="entry_radURL"/>
+         </item>
+        </layout>
+       </item>
+       <item>
+        <layout class="QHBoxLayout" name="horizontalLayout_9">
+         <item>
+          <widget class="QPushButton" name="but_RadAdd">
+           <property name="minimumSize">
+            <size>
+             <width>80</width>
+             <height>27</height>
+            </size>
+           </property>
+           <property name="text">
+            <string>Add</string>
+           </property>
+          </widget>
+         </item>
+         <item>
+          <widget class="QPushButton" name="but_RemRad">
+           <property name="minimumSize">
+            <size>
+             <width>80</width>
+             <height>27</height>
+            </size>
+           </property>
+           <property name="text">
+            <string>Remove</string>
+           </property>
+          </widget>
+         </item>
+        </layout>
        </item>
       </layout>
      </widget>
+    </widget>
+    <widget class="QWidget" name="Sync_tab">
+     <attribute name="title">
+      <string>Sync</string>
+     </attribute>
      <widget class="QWidget" name="layoutWidget">
       <property name="geometry">
        <rect>
-        <x>0</x>
-        <y>180</y>
-        <width>171</width>
-        <height>27</height>
+        <x>20</x>
+        <y>30</y>
+        <width>137</width>
+        <height>85</height>
        </rect>
       </property>
-      <layout class="QHBoxLayout" name="horizontalLayout_5">
+      <layout class="QVBoxLayout" name="verticalLayout">
        <item>
-        <widget class="QLabel" name="label_3">
+        <widget class="QLabel" name="label_6">
          <property name="text">
-          <string>URL     </string>
+          <string>Local Machine</string>
          </property>
         </widget>
        </item>
        <item>
-        <widget class="QLineEdit" name="entry_radURL"/>
+        <widget class="QPushButton" name="but_import_aud">
+         <property name="text">
+          <string>Import Audio</string>
+         </property>
+        </widget>
+       </item>
+       <item>
+        <widget class="QPushButton" name="but_import_vid">
+         <property name="text">
+          <string>Import Video</string>
+         </property>
+        </widget>
        </item>
       </layout>
      </widget>
-    </widget>
-    <widget class="QWidget" name="Sync_tab">
-     <attribute name="title">
-      <string>Sync</string>
-     </attribute>
-     <widget class="QPushButton" name="SYNC_but">
-      <property name="geometry">
-       <rect>
-        <x>30</x>
-        <y>90</y>
-        <width>93</width>
-        <height>27</height>
-       </rect>
-      </property>
-      <property name="toolTip">
-       <string>Sync from mediatomb</string>
-      </property>
-      <property name="text">
-       <string>Sync</string>
-      </property>
-     </widget>
-     <widget class="QPushButton" name="ADMIN_but">
+     <widget class="QWidget" name="layoutWidget">
       <property name="geometry">
        <rect>
-        <x>30</x>
-        <y>130</y>
-        <width>91</width>
-        <height>27</height>
+        <x>20</x>
+        <y>140</y>
+        <width>137</width>
+        <height>85</height>
        </rect>
       </property>
-      <property name="text">
-       <string>Admin</string>
-      </property>
+      <layout class="QVBoxLayout" name="verticalLayout_4">
+       <item>
+        <widget class="QLabel" name="label_5">
+         <property name="text">
+          <string>Remote Mediatomb</string>
+         </property>
+        </widget>
+       </item>
+       <item>
+        <widget class="QPushButton" name="SYNC_but">
+         <property name="toolTip">
+          <string>Sync from mediatomb</string>
+         </property>
+         <property name="text">
+          <string>Sync</string>
+         </property>
+        </widget>
+       </item>
+       <item>
+        <widget class="QPushButton" name="ADMIN_but">
+         <property name="text">
+          <string>Admin</string>
+         </property>
+        </widget>
+       </item>
+      </layout>
      </widget>
     </widget>
    </widget>
-   <widget class="QWidget" name="layoutWidget">
+   <widget class="QComboBox" name="MODE_combo">
     <property name="geometry">
      <rect>
       <x>10</x>
-      <y>284</y>
-      <width>701</width>
-      <height>105</height>
+      <y>0</y>
+      <width>121</width>
+      <height>29</height>
      </rect>
     </property>
-    <layout class="QHBoxLayout" name="horizontalLayout_4">
+    <property name="minimumSize">
+     <size>
+      <width>121</width>
+      <height>29</height>
+     </size>
+    </property>
+    <property name="maximumSize">
+     <size>
+      <width>121</width>
+      <height>29</height>
+     </size>
+    </property>
+    <item>
+     <property name="text">
+      <string>Mode:</string>
+     </property>
+    </item>
+    <item>
+     <property name="text">
+      <string>Artists</string>
+     </property>
+    </item>
+    <item>
+     <property name="text">
+      <string>Albums</string>
+     </property>
+    </item>
+    <item>
+     <property name="text">
+      <string>Songs</string>
+     </property>
+    </item>
+    <item>
+     <property name="text">
+      <string>Videos</string>
+     </property>
+    </item>
+   </widget>
+   <widget class="QToolButton" name="but_remote_tog">
+    <property name="geometry">
+     <rect>
+      <x>130</x>
+      <y>0</y>
+      <width>60</width>
+      <height>29</height>
+     </rect>
+    </property>
+    <property name="minimumSize">
+     <size>
+      <width>60</width>
+      <height>29</height>
+     </size>
+    </property>
+    <property name="maximumSize">
+     <size>
+      <width>60</width>
+      <height>29</height>
+     </size>
+    </property>
+    <property name="text">
+     <string>Remote</string>
+    </property>
+    <property name="checkable">
+     <bool>true</bool>
+    </property>
+    <property name="checked">
+     <bool>false</bool>
+    </property>
+   </widget>
+   <widget class="QWidget" name="">
+    <property name="geometry">
+     <rect>
+      <x>11</x>
+      <y>301</y>
+      <width>691</width>
+      <height>101</height>
+     </rect>
+    </property>
+    <layout class="QHBoxLayout" name="horizontalLayout_2">
      <item>
       <layout class="QVBoxLayout" name="verticalLayout_3">
        <item>
@@ -420,32 +510,168 @@
         </widget>
        </item>
        <item>
-        <layout class="QHBoxLayout" name="horizontalLayout_2">
+        <layout class="QVBoxLayout" name="verticalLayout_6">
+         <item>
+          <widget class="QLabel" name="SEEK_lbl">
+           <property name="text">
+            <string>00:00</string>
+           </property>
+          </widget>
+         </item>
          <item>
-          <layout class="QVBoxLayout" name="verticalLayout_2">
+          <layout class="QVBoxLayout" name="verticalLayout_5">
            <item>
-            <widget class="QRadioButton" name="rad_loopSong">
-             <property name="text">
-              <string>Loop(song)</string>
+            <widget class="QSlider" name="SEEK_slider">
+             <property name="minimumSize">
+              <size>
+               <width>160</width>
+               <height>19</height>
+              </size>
+             </property>
+             <property name="toolTip">
+              <string>Seek</string>
+             </property>
+             <property name="orientation">
+              <enum>Qt::Horizontal</enum>
              </property>
             </widget>
            </item>
            <item>
-            <widget class="QRadioButton" name="rad_loop">
-             <property name="text">
-              <string>Loop(all)</string>
-             </property>
-            </widget>
+            <layout class="QHBoxLayout" name="horizontalLayout_3">
+             <item>
+              <widget class="QPushButton" name="RRWD_but">
+               <property name="minimumSize">
+                <size>
+                 <width>25</width>
+                 <height>25</height>
+                </size>
+               </property>
+               <property name="maximumSize">
+                <size>
+                 <width>25</width>
+                 <height>25</height>
+                </size>
+               </property>
+               <property name="toolTip">
+                <string>Prev</string>
+               </property>
+               <property name="text">
+                <string/>
+               </property>
+               <property name="icon">
+                <iconset resource="../images/BTres.qrc">
+                 <normaloff>:/images/RRWD_icon.png</normaloff>:/images/RRWD_icon.png</iconset>
+               </property>
+              </widget>
+             </item>
+             <item>
+              <widget class="QPushButton" name="STOP_but">
+               <property name="minimumSize">
+                <size>
+                 <width>25</width>
+                 <height>25</height>
+                </size>
+               </property>
+               <property name="maximumSize">
+                <size>
+                 <width>25</width>
+                 <height>25</height>
+                </size>
+               </property>
+               <property name="toolTip">
+                <string>Stop</string>
+               </property>
+               <property name="text">
+                <string/>
+               </property>
+               <property name="icon">
+                <iconset resource="../images/BTres.qrc">
+                 <normaloff>:/images/STOP_icon.png</normaloff>:/images/STOP_icon.png</iconset>
+               </property>
+              </widget>
+             </item>
+             <item>
+              <widget class="QPushButton" name="PAUSE_but">
+               <property name="minimumSize">
+                <size>
+                 <width>25</width>
+                 <height>25</height>
+                </size>
+               </property>
+               <property name="maximumSize">
+                <size>
+                 <width>25</width>
+                 <height>25</height>
+                </size>
+               </property>
+               <property name="toolTip">
+                <string>Pause</string>
+               </property>
+               <property name="text">
+                <string/>
+               </property>
+               <property name="icon">
+                <iconset resource="../images/BTres.qrc">
+                 <normaloff>:/images/PAUSE_icon.png</normaloff>:/images/PAUSE_icon.png</iconset>
+               </property>
+              </widget>
+             </item>
+             <item>
+              <widget class="QPushButton" name="FWD_but">
+               <property name="minimumSize">
+                <size>
+                 <width>25</width>
+                 <height>25</height>
+                </size>
+               </property>
+               <property name="maximumSize">
+                <size>
+                 <width>25</width>
+                 <height>25</height>
+                </size>
+               </property>
+               <property name="toolTip">
+                <string>Play</string>
+               </property>
+               <property name="text">
+                <string/>
+               </property>
+               <property name="icon">
+                <iconset resource="../images/BTres.qrc">
+                 <normaloff>:/images/FWD_icon.png</normaloff>:/images/FWD_icon.png</iconset>
+               </property>
+              </widget>
+             </item>
+             <item>
+              <widget class="QPushButton" name="FFWD_but">
+               <property name="minimumSize">
+                <size>
+                 <width>25</width>
+                 <height>25</height>
+                </size>
+               </property>
+               <property name="maximumSize">
+                <size>
+                 <width>25</width>
+                 <height>25</height>
+                </size>
+               </property>
+               <property name="toolTip">
+                <string>Next</string>
+               </property>
+               <property name="text">
+                <string/>
+               </property>
+               <property name="icon">
+                <iconset resource="../images/BTres.qrc">
+                 <normaloff>:/images/FFWD_icon.png</normaloff>:/images/FFWD_icon.png</iconset>
+               </property>
+              </widget>
+             </item>
+            </layout>
            </item>
           </layout>
          </item>
-         <item>
-          <widget class="QRadioButton" name="rad_shuffle">
-           <property name="text">
-            <string>Shuffle</string>
-           </property>
-          </widget>
-         </item>
         </layout>
        </item>
       </layout>
@@ -455,294 +681,114 @@
        <property name="orientation">
         <enum>Qt::Horizontal</enum>
        </property>
-       <property name="sizeType">
-        <enum>QSizePolicy::Expanding</enum>
-       </property>
        <property name="sizeHint" stdset="0">
         <size>
-         <width>80</width>
+         <width>68</width>
          <height>20</height>
         </size>
        </property>
       </spacer>
      </item>
      <item>
-      <layout class="QVBoxLayout" name="verticalLayout_6">
+      <layout class="QVBoxLayout" name="verticalLayout_9">
        <item>
-        <widget class="QLabel" name="SEEK_lbl">
+        <widget class="QRadioButton" name="rad_loopSong">
          <property name="text">
-          <string>00:00</string>
+          <string>Loop(song)</string>
          </property>
         </widget>
        </item>
        <item>
-        <layout class="QVBoxLayout" name="verticalLayout_5">
-         <item>
-          <widget class="QSlider" name="SEEK_slider">
-           <property name="minimumSize">
-            <size>
-             <width>160</width>
-             <height>19</height>
-            </size>
-           </property>
-           <property name="toolTip">
-            <string>Seek</string>
-           </property>
-           <property name="orientation">
-            <enum>Qt::Horizontal</enum>
-           </property>
-          </widget>
-         </item>
-         <item>
-          <layout class="QHBoxLayout" name="horizontalLayout_3">
-           <item>
-            <widget class="QPushButton" name="RRWD_but">
-             <property name="minimumSize">
-              <size>
-               <width>25</width>
-               <height>25</height>
-              </size>
-             </property>
-             <property name="maximumSize">
-              <size>
-               <width>25</width>
-               <height>25</height>
-              </size>
-             </property>
-             <property name="toolTip">
-              <string>Prev</string>
-             </property>
-             <property name="text">
-              <string/>
-             </property>
-             <property name="icon">
-              <iconset resource="../images/BTres.qrc">
-               <normaloff>:/images/RRWD_icon.png</normaloff>:/images/RRWD_icon.png</iconset>
-             </property>
-            </widget>
-           </item>
-           <item>
-            <widget class="QPushButton" name="STOP_but">
-             <property name="minimumSize">
-              <size>
-               <width>25</width>
-               <height>25</height>
-              </size>
-             </property>
-             <property name="maximumSize">
-              <size>
-               <width>25</width>
-               <height>25</height>
-              </size>
-             </property>
-             <property name="toolTip">
-              <string>Stop</string>
-             </property>
-             <property name="text">
-              <string/>
-             </property>
-             <property name="icon">
-              <iconset resource="../images/BTres.qrc">
-               <normaloff>:/images/STOP_icon.png</normaloff>:/images/STOP_icon.png</iconset>
-             </property>
-            </widget>
-           </item>
-           <item>
-            <widget class="QPushButton" name="PAUSE_but">
-             <property name="minimumSize">
-              <size>
-               <width>25</width>
-               <height>25</height>
-              </size>
-             </property>
-             <property name="maximumSize">
-              <size>
-               <width>25</width>
-               <height>25</height>
-              </size>
-             </property>
-             <property name="toolTip">
-              <string>Pause</string>
-             </property>
-             <property name="text">
-              <string/>
-             </property>
-             <property name="icon">
-              <iconset resource="../images/BTres.qrc">
-               <normaloff>:/images/PAUSE_icon.png</normaloff>:/images/PAUSE_icon.png</iconset>
-             </property>
-            </widget>
-           </item>
-           <item>
-            <widget class="QPushButton" name="FWD_but">
-             <property name="minimumSize">
-              <size>
-               <width>25</width>
-               <height>25</height>
-              </size>
-             </property>
-             <property name="maximumSize">
-              <size>
-               <width>25</width>
-               <height>25</height>
-              </size>
-             </property>
-             <property name="toolTip">
-              <string>Play</string>
-             </property>
-             <property name="text">
-              <string/>
-             </property>
-             <property name="icon">
-              <iconset resource="../images/BTres.qrc">
-               <normaloff>:/images/FWD_icon.png</normaloff>:/images/FWD_icon.png</iconset>
-             </property>
-            </widget>
-           </item>
-           <item>
-            <widget class="QPushButton" name="FFWD_but">
-             <property name="minimumSize">
-              <size>
-               <width>25</width>
-               <height>25</height>
-              </size>
-             </property>
-             <property name="maximumSize">
-              <size>
-               <width>25</width>
-               <height>25</height>
-              </size>
-             </property>
-             <property name="toolTip">
-              <string>Next</string>
-             </property>
-             <property name="text">
-              <string/>
-             </property>
-             <property name="icon">
-              <iconset resource="../images/BTres.qrc">
-               <normaloff>:/images/FFWD_icon.png</normaloff>:/images/FFWD_icon.png</iconset>
-             </property>
-            </widget>
-           </item>
-          </layout>
-         </item>
-        </layout>
+        <widget class="QRadioButton" name="rad_loop">
+         <property name="text">
+          <string>Loop(all)</string>
+         </property>
+        </widget>
+       </item>
+       <item>
+        <widget class="QRadioButton" name="rad_shuffle">
+         <property name="text">
+          <string>Shuffle</string>
+         </property>
+        </widget>
        </item>
       </layout>
      </item>
      <item>
-      <spacer name="horizontalSpacer_3">
+      <spacer name="horizontalSpacer_2">
        <property name="orientation">
         <enum>Qt::Horizontal</enum>
        </property>
        <property name="sizeHint" stdset="0">
         <size>
-         <width>13</width>
-         <height>17</height>
+         <width>40</width>
+         <height>20</height>
         </size>
        </property>
       </spacer>
      </item>
      <item>
-      <layout class="QVBoxLayout" name="verticalLayout">
+      <layout class="QHBoxLayout" name="horizontalLayout">
        <item>
-        <widget class="QComboBox" name="MODE_combo">
+        <widget class="QDial" name="VOL_dial">
          <property name="minimumSize">
           <size>
-           <width>121</width>
-           <height>29</height>
+           <width>50</width>
+           <height>40</height>
           </size>
          </property>
          <property name="maximumSize">
           <size>
-           <width>121</width>
-           <height>29</height>
+           <width>50</width>
+           <height>64</height>
           </size>
          </property>
-         <item>
-          <property name="text">
-           <string>Mode:</string>
-          </property>
-         </item>
-         <item>
-          <property name="text">
-           <string>Artists</string>
-          </property>
-         </item>
-         <item>
-          <property name="text">
-           <string>Albums</string>
-          </property>
-         </item>
-         <item>
-          <property name="text">
-           <string>Songs</string>
-          </property>
-         </item>
-         <item>
-          <property name="text">
-           <string>Videos</string>
-          </property>
-         </item>
+         <property name="toolTip">
+          <string>Volume</string>
+         </property>
+         <property name="value">
+          <number>50</number>
+         </property>
         </widget>
        </item>
        <item>
-        <layout class="QHBoxLayout" name="horizontalLayout">
-         <item>
-          <widget class="QDial" name="VOL_dial">
-           <property name="minimumSize">
-            <size>
-             <width>50</width>
-             <height>64</height>
-            </size>
-           </property>
-           <property name="maximumSize">
-            <size>
-             <width>50</width>
-             <height>64</height>
-            </size>
-           </property>
-           <property name="toolTip">
-            <string>Volume</string>
-           </property>
-           <property name="value">
-            <number>50</number>
-           </property>
-          </widget>
-         </item>
-         <item>
-          <widget class="QLabel" name="label">
-           <property name="minimumSize">
-            <size>
-             <width>67</width>
-             <height>17</height>
-            </size>
-           </property>
-           <property name="maximumSize">
-            <size>
-             <width>67</width>
-             <height>17</height>
-            </size>
-           </property>
-           <property name="text">
-            <string>Volume</string>
-           </property>
-          </widget>
-         </item>
-         <item>
-          <widget class="QLabel" name="VOL_lbl">
-           <property name="text">
-            <string>50</string>
-           </property>
-          </widget>
-         </item>
+        <widget class="QLabel" name="label">
+         <property name="minimumSize">
+          <size>
+           <width>67</width>
+           <height>17</height>
+          </size>
+         </property>
+         <property name="maximumSize">
+          <size>
+           <width>67</width>
+           <height>17</height>
+          </size>
+         </property>
+         <property name="text">
+          <string>Volume</string>
+         </property>
+        </widget>
+       </item>
+       <item>
+        <layout class="QVBoxLayout" name="verticalLayout_8">
          <item>
-          <widget class="QLabel" name="label_2">
-           <property name="text">
-            <string>%</string>
-           </property>
-          </widget>
+          <layout class="QHBoxLayout" name="horizontalLayout_10">
+           <item>
+            <widget class="QLabel" name="VOL_lbl">
+             <property name="text">
+              <string>50</string>
+             </property>
+            </widget>
+           </item>
+           <item>
+            <widget class="QLabel" name="label_2">
+             <property name="text">
+              <string>%</string>
+             </property>
+            </widget>
+           </item>
+          </layout>
          </item>
         </layout>
        </item>
@@ -756,7 +802,7 @@
     <rect>
      <x>0</x>
      <y>0</y>
-     <width>720</width>
+     <width>721</width>
      <height>27</height>
     </rect>
    </property>
--- beagletomb-0.1.6.orig/src/fileobj.cpp
+++ beagletomb-0.1.6/src/fileobj.cpp
@@ -108,3 +108,53 @@ fileObj& fileObj::operator=(const fileOb
      return *this;
 
 }
+
+
+/*
+  *  Search any Object for a track name by the using the ID
+  */
+char* checkSongObjByID(int id, fileObj& src){
+    char *FinSong;
+    if(src.getSize() > 0){
+        for(int i = 0; i< src.getSize(); i++){
+            if(src.getID(i) == id){
+
+                FinSong = new char[strlen(src.getName(i))+1];
+                strcpy(FinSong,src.getName(i));
+            }
+        }
+    }
+    return FinSong;
+}
+
+/*
+  *  Search any Object for a track ID by the using the parent
+  */
+int checkSongObjIDbyPar(int par, fileObj& src){
+    int FinID = 0;
+    if(src.getSize() > 0){
+        for(int i = 0; i< src.getSize(); i++){
+            if(src.getPar(i) == par){
+
+                FinID = src.getID(i);
+            }
+        }
+    }
+    return FinID;
+}
+
+/*
+  *  Search any Object for a track Par by the using the ID
+  */
+int checkSongObjParByID(int id, fileObj& src){
+    int FinPar;
+    if(src.getSize() > 0){
+        for(int i = 0; i< src.getSize(); i++){
+            if(src.getID(i) == id){
+
+                FinPar = src.getPar(i);
+            }
+        }
+    }
+    return FinPar;
+}
--- /dev/null
+++ beagletomb-0.1.6/src/fileobj.h.moved
@@ -0,0 +1,121 @@
+#ifndef FILEOBJ_H
+#define FILEOBJ_H
+
+#define INITSIZE 100
+#include <stdlib.h>
+#include <stdio.h>
+#include <iostream>
+#include <cstring>
+#include <QtGui/QMainWindow>
+
+using namespace std;
+class fileObj
+{
+public:
+
+    string *fileName;    // Item name
+    string *filePath;    // Item Path  *only if local
+    int *fileID;         // Item Identification number
+    int *filePar;       // Item Parent number
+    int objSize;        // Number of Items
+    int InitSize;       // Number size before reallocate
+
+
+    fileObj();
+    fileObj(const fileObj& src);
+    fileObj& operator=(const fileObj& src);
+
+    void initFile(int initSZ);
+    void REinitFile(int oldsize, int newsize);
+    void display();
+    virtual ~fileObj();
+
+    void setName(int item, const char *name){
+        if(item >= 0 && item <= objSize){
+            fileName[item] = name;
+        }
+    }
+    void setPath(int item, const char *path){
+        if(item >= 0 && item <= objSize){
+            filePath[item] = path;
+        }
+    }
+
+    void setID(int item, int newID){
+        if(item >= 0 && item <= objSize){
+            /// fill with new entry
+            fileID[item] = newID;
+        }
+    }
+    void setPar(int item, int newPar){
+        if(item >= 0 && item <= objSize){
+
+            /// fill with new entry
+            filePar[item] = newPar;
+        }
+    }
+    void set(int item, int newid, int newpar, const char *newname, const char *newpath){
+        if (objSize >= InitSize-1){
+            REinitFile(InitSize, 1000);
+        }
+        setID(item, newid);
+        setPar(item, newpar);
+        setName(item, newname);
+        setPath(item, newpath);
+        objSize++;
+    }
+    void set(int item, int newid, int newpar, const char *newname){
+        if (objSize >= InitSize-1){
+            REinitFile(InitSize, 1000);
+        }
+        setID(item, newid);
+        setPar(item, newpar);
+        setName(item, newname);
+        setPath(item, "-");
+        objSize++;
+    }
+    void setInit(int item, int newid, int newpar, const char *newname, const char *newpath){
+        setID(item, newid);
+        setPar(item, newpar);
+        setName(item, newname);
+        setPath(item, newpath);
+        InitSize++;
+    }
+    int getID(int item){
+        return fileID[item];
+    }
+    int getPar(int item){
+        return filePar[item];
+    }
+    char *getName(int item){
+        char *final;
+        final = new char[fileName[item].length()+1];
+        strcpy(final, fileName[item].c_str());
+        return final;
+    }
+    char *getPath(int item){
+        char *final;
+        final = new char[filePath[item].length()+1];
+        strcpy(final, filePath[item].c_str());
+        return final;
+    }
+
+    int getSize(){
+        return objSize;
+    }
+    void setInit(int initItem){
+        InitSize = initItem;
+    }
+    int getInit(){
+        return InitSize;
+    }
+
+
+
+};
+
+char* checkSongObjByID(int id, fileObj& src);   // returns song name based on query by unique ID
+int checkSongObjIDByPar(int par, fileObj& src);   // returns song ID based on query by parent ID
+int checkSongObjParByID(int id, fileObj& src);   // returns song ParID based on query by ID
+
+#endif // FILEOBJ_H
--- /dev/null
+++ beagletomb-0.1.6/src/fileobj.cpp.moved
@@ -0,0 +1,166 @@
+#include "fileobj.h"
+
+fileObj::fileObj()
+{
+    objSize = 0;
+    InitSize = 0;
+    initFile(INITSIZE);
+}
+
+
+fileObj::fileObj(const fileObj &src){
+
+    if(src.objSize > 0){
+        objSize = 0;
+        delete [] fileName;
+        delete [] fileID;
+        delete [] filePar;
+        delete [] filePath;
+        initFile(src.objSize);
+        for(int i=0; i< src.objSize; i++){
+            set(i,src.fileID[i], src.filePar[i], src.fileName[i].c_str(), src.filePath[i].c_str());
+        }
+        objSize = src.objSize;
+        InitSize = src.InitSize;
+    }
+}
+
+void fileObj::initFile(int initSZ){
+    fileName = new string[initSZ];
+    fileID = new int[initSZ];
+    filePar = new int[initSZ];
+    filePath = new string[initSZ];
+    InitSize = 0;
+    for(int i=0; i< initSZ; i++){
+        setInit(i, 0, 0, "-", "-");
+    }
+}
+
+void fileObj::REinitFile(int oldsize, int newsize){
+    //set the new initialize size
+    InitSize = oldsize+newsize;
+    int tempObjSize = 0;
+    string *nameCopy, *pathCopy;
+    int *idCopy, *parCopy;
+    nameCopy = new string[objSize+1];
+    parCopy = new int[objSize+1];
+   idCopy = new int[objSize+1];
+    pathCopy = new string[objSize+1];
+
+    for(int i=0; i< objSize; i++){
+        nameCopy[i] = "-";
+        pathCopy[i] = "-";
+        parCopy[i]= 0;
+        idCopy[i] = 0;
+    }
+
+    for(int i=0; i< objSize; i++){
+        nameCopy[i] = fileName[i];
+        parCopy[i] = filePar[i];
+        idCopy[i] = fileID[i];
+        pathCopy[i] = filePath[i];
+    }
+    delete [] fileName;
+    delete [] fileID;
+    delete [] filePar;
+   delete [] filePath;
+      initFile(InitSize);
+   /// refill array fileName fileID filePar array
+
+      tempObjSize = objSize;
+      objSize = 0;
+   for(int i=0; i< tempObjSize; i++){
+        set(i,idCopy[i], parCopy[i], nameCopy[i].c_str(), pathCopy[i].c_str());
+    }
+
+}
+
+
+fileObj::~fileObj(){
+        delete [] fileName;
+        delete [] fileID;
+        delete [] filePar;
+        delete [] filePath;
+}
+
+void fileObj::display(){
+    cout << "obj size is " << objSize << endl;
+    for(int i=0; i< objSize; i++){
+        cout << " Num: " << i
+             << " ID: " << getID(i)
+             << " PAR: " << getPar(i)
+             << " NAME: " << getName(i)
+             <<  " PATH: " << getPath(i) << endl;
+    }
+}
+
+fileObj& fileObj::operator=(const fileObj& src){
+
+    if(this != &src){
+        if(src.objSize > 0){
+            objSize = 0;
+            delete [] fileName;
+            delete [] fileID;
+            delete [] filePar;
+            delete [] filePath;
+            initFile(src.objSize+1);
+
+            for(int i=0; i< src.objSize-1; i++){
+                set(i,src.fileID[i], src.filePar[i], src.fileName[i].c_str(), src.filePath[i].c_str());
+            }
+            objSize = src.objSize;
+            InitSize = src.InitSize;
+        }
+    }
+     return *this;
+
+}
+
+/*
+  *  Search any Object for a track name by the using the ID
+  */
+char* checkSongObjByID(int id, fileObj& src){
+    char *FinSong;
+    if(src.getSize() > 0){
+        for(int i = 0; i< src.getSize(); i++){
+            if(src.getID(i) == id){
+
+                FinSong = new char[strlen(src.getName(i))+1];
+                strcpy(FinSong,src.getName(i));
+            }
+        }
+    }
+    return FinSong;
+}
+
+/*
+  *  Search any Object for a track ID by the using the parent
+  */
+int checkSongObjIDbyPar(int par, fileObj& src){
+    int FinID = 0;
+    if(src.getSize() > 0){
+        for(int i = 0; i< src.getSize(); i++){
+            if(src.getPar(i) == par){
+
+                FinID = src.getID(i);
+            }
+        }
+    }
+    return FinID;
+}
+
+/*
+  *  Search any Object for a track Par by the using the ID
+  */
+int checkSongObjParByID(int id, fileObj& src){
+    int FinPar;
+    if(src.getSize() > 0){
+        for(int i = 0; i< src.getSize(); i++){
+            if(src.getID(i) == id){
+
+                FinPar = src.getPar(i);
+            }
+        }
+    }
+    return FinPar;
+}
--- /dev/null
+++ beagletomb-0.1.6/src/beaglemain.cpp.OTHER
@@ -0,0 +1,704 @@
+/*
+ *  Written By: Grant Hutchinson
+ *  License: GPLv3.
+ *  h.g.utchinson@gmail.com
+ *  Copyright (C) 2012 by Grant Hutchinson
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#include "beaglemain.h"
+#include "ui_beaglemain.h"
+
+BeagleMain::BeagleMain(QWidget *parent) :
+    QMainWindow(parent),
+    ui(new Ui::BeagleMain)
+{
+    ui->setupUi(this);
+    Sync(0);
+    ui->MenuList->setEditTriggers(QAbstractItemView::NoEditTriggers);
+    ui->TitleList->setEditTriggers(QAbstractItemView::NoEditTriggers);
+    ui->PlayList->setEditTriggers(QAbstractItemView::NoEditTriggers);
+    ui->list_radio->setEditTriggers(QAbstractItemView::NoEditTriggers);
+    widget.setSeekSlider(ui->SEEK_slider);
+    widget.setVolumeSlider(ui->VOL_dial);
+
+}
+
+/*
+  *  SYNCHRONIZE ALL DATA
+  */
+void BeagleMain::Sync(int type){
+    artSize = 0;
+    albSize = 0;
+    songSize = 0;
+    vidDirSize = 0;
+    vidSize = 0;
+   radSize = 0;
+    if(type == 0){
+        /// init playlist
+        pl.setCount(0);
+        pl.initPL();
+
+        plMode= 0; // set playlist mode to browse
+        playlistOpen = false; // set playlist open
+        /// if SQL file doesn't exist
+        if(pref.initDB() == false){
+            prefDg.show();
+            if (prefDg.exec()==QDialog::Accepted) {
+
+                //create cache directory
+                pref.createCache();
+                pref = prefDg.getPref();
+                //create custom sql db
+                pref.createDB();
+                /// write preferences to sql db
+                pref.writeDB();
+                pref.setInitDB();
+            }
+        }
+
+        else{
+            //// read from sql and fill songObjs
+            readDB rDB(pref.getSQL().c_str());
+            Artist = rDB.ArtistFill(Artist);
+            Album = rDB.AlbumFill(Album);
+            Song = rDB.SongFill(Song);
+            VidDir = rDB.VidDirFill(VidDir);
+            Video = rDB.VideoFill(Video);
+            /// read from sql and fill radio obj
+            Radio = rDB.RadioFill(&radSize);
+            Radio.setDB(pref.getSQL());
+            Radio.setSize(radSize);
+            RefillRadioPL();
+        }
+    }
+    else if(type == 1){
+
+        readDB rDB(pref.getSQL().c_str());
+        ///check database for previous radio stations
+        Radio = rDB.RadioFill(&radSize);
+        // read preferences prior to delete
+   //     pref.readDB();
+        pref.deleteDB(pref.getSQL().c_str());
+        ///
+        pref.createDB();
+
+        cout << "syncing.... " << pref.getServ() << "\t" << pref.getPort()<<  endl;
+        /// read from remote mysql write to local sqlite
+        syncMe sy(pref.getServ().c_str(), pref.getUser().c_str(), pref.getPass().c_str(), pref.getTable().c_str(), pref.getSQL().c_str());
+        /// write radio stations
+        Radio.writeDBFill();
+        /// write preferences to sql db
+        pref.writeDB();
+        pref.setInitDB();
+        cout << "reading.... " << endl;
+        /// read from sqlite to songObjs
+        Artist = rDB.ArtistFill(Artist);
+        Album = rDB.AlbumFill(Album);
+        Song = rDB.SongFill(Song);
+        VidDir = rDB.VidDirFill(VidDir);
+        Video = rDB.VideoFill(Video);
+        /// read from sql and fill radio obj
+        cout << "syncing radio" << endl;
+        Radio = rDB.RadioFill(&radSize);
+        Radio.setDB(pref.getSQL());
+        Radio.setSize(radSize);
+        RefillRadioPL();
+        cout << "Database synced!" << endl;
+    }
+}
+
+/*
+  *  UPDATE MENU LIST WITH ALL ARTISTS OR ALL ALBUMS
+  */
+void BeagleMain::updateMenu(int type){
+    QStringList curMenu;
+    m_Model = new QStringListModel(this);
+    if(type == 1){
+        /// update with artist
+        for(int i=0; i< Artist.getSize(); i++){
+            curMenu << Artist.getName(i);
+        }
+    }
+    else if(type == 2){
+        /// update with album
+        for(int i=0; i< Album.getSize(); i++){
+            curMenu << Album.getName(i);
+        }
+    }
+    else if(type == 3){
+        /// update with directories
+        for(int i=0; i< VidDir.getSize(); i++){
+            curMenu << VidDir.getName(i);
+        }
+    }
+
+
+    m_Model->setStringList(curMenu);
+    ui->MenuList->setModel(m_Model);
+}
+
+void BeagleMain::setMainPref(preferences my_pref){
+    pref = my_pref;
+}
+
+/*
+  *  UPDATE MENU LIST WITH ALBUMS FROM SELECTED
+  */
+void BeagleMain::updateAlbMenu(int select){
+    albCount = 0;
+    int selID = 0;
+    QStringList curAlb;
+    m_Model = new QStringListModel(this);
+    curAlbID = new int[MAX];
+    selID = Artist.getID(select);    /// selected ID
+
+    for(int i=0; i< Album.getSize(); i++){
+        if(Album.getPar(i) == selID ){
+            curAlb << Album.getName(i);
+            curAlbID[albCount] = Album.getID(i);
+            albCount++;
+        }
+    }
+
+    m_Model->setStringList(curAlb);
+    ui->MenuList->setModel(m_Model);
+}
+
+/*
+  *  UPDATE TITLE LIST WITH ALL SONGS
+  */
+void BeagleMain::updateTitle(){
+    t_Model = new QStringListModel(this);
+    QStringList songList;
+
+    for(int i = 0; i<= Song.getSize(); i++){
+        songList << Song.getName(i);
+    }
+    t_Model->setStringList(songList);
+    ui->TitleList->setModel(t_Model);
+
+}
+
+/*
+  *  UPDATE TITLE LIST WITH SONGS FROM SELECTED
+  */
+void BeagleMain::updateTitle(int selected){
+    songCount = 0;
+    vidCount = 0;
+    int selID = 0;
+    QStringList curSong;
+    t_Model = new QStringListModel(this);
+    curSongID = new int[MAX];
+    curVidID = new int[MAX];
+    if(MenuMode == 3){     ///  if ALL ALBUM
+        selID = Album.getID(selected);
+        for(int i = 0; i< Song.getSize(); i++){
+            if(Song.getPar(i) == selID){
+                curSong << Song.getName(i);
+                curSongID[songCount] = Song.getID(i);
+                songCount++;
+            }
+        }
+    }
+    else if(MenuMode == 4){    ////// if VIDEO DIR MODE
+        selID = VidDir.getID(selected);
+        for(int i = 0; i<= Video.getSize(); i++){
+            if(Video.getPar(i) == selID){
+                curSong << Video.getName(i);
+                curVidID[vidCount] = Video.getID(i);
+                vidCount++;
+            }
+        }
+    }
+    else{   /// IF ALBUM DIR MODE
+        selID = curAlbID[selected];
+        for(int i = 0; i<= Song.getSize(); i++){
+            if(Song.getPar(i) == selID){
+                curSong << Song.getName(i);
+                curSongID[songCount] = Song.getID(i);
+                songCount++;
+            }
+        }
+    }
+
+    t_Model->setStringList(curSong);
+    ui->TitleList->setModel(t_Model);
+
+}
+void BeagleMain::startSong(char *FinSong, int selID){
+
+    char * strBuffer;
+    strBuffer= new char[100];
+    sprintf(strBuffer, "http://%s:%s/content/media/object_id/%d/res_id/0", pref.getServ().c_str(), pref.getPort().c_str(), selID);
+    ui->SONG_lbl->setText((QString)FinSong);
+    widget.show();
+    widget.start(QStringList(strBuffer));
+}
+/*
+  * refill playlist list with playlist model from playlist object
+  */
+void BeagleMain::RefillMainPL(){
+    QStringList updatedList;
+   t_Model = new QStringListModel(this);
+    updatedList = pl.RefillPlaylist();
+    t_Model->setStringList(updatedList);
+    ui->PlayList->setModel(t_Model);
+}
+
+/*
+  * refill playlist list with playlist model from playlist user Folder
+  */
+void BeagleMain::RefillPLFolder(){
+    QStringList updatedList;
+   t_Model = new QStringListModel(this);
+    updatedList = pl.listDirectories(pl.getFullLocation().c_str());
+    t_Model->setStringList(updatedList);
+    ui->PlayList->setModel(t_Model);
+}
+
+void BeagleMain::PlaylistPlay(int selID){
+        char* FinSong;
+        for(int i = 0; i<= pl.getCount(); i++){
+            if(pl.getTrackID(i) == selID){
+                FinSong = new char[strlen(pl.getTrackName(i).c_str())+1];
+                strcpy(FinSong,pl.getTrackName(i).c_str());
+            }
+        }
+        // start song
+        startSong(FinSong, selID);
+    }
+/*
+  * MEM CLEANUP
+  */
+BeagleMain::~BeagleMain()
+{
+    delete ui;
+}
+
+/*
+  *When Sync Button is pressed
+  */
+void BeagleMain::on_SYNC_but_clicked()
+{
+    Sync(1);
+}
+
+/*
+  *When Mode combo button is changed, change the mode, update lists
+  */
+void BeagleMain::on_MODE_combo_currentIndexChanged(int index)
+{
+    if(index == 1){   //  update lists with artists
+        updateMenu(1);
+        MenuMode=1;
+    }
+    else if(index == 2){  // update lists with albums
+        updateMenu(2);
+        MenuMode=3;
+    }
+    else if(index == 3){  // update lists with songs
+        updateTitle();
+        TitleMode = 1;
+    }
+    else if(index == 4){  // update lists with vid directories
+        MenuMode = 4;
+        updateMenu(3);
+    }
+}
+
+/*
+  *When Stop Button is pressed
+  */
+void BeagleMain::on_STOP_but_clicked()
+{
+    widget.stop();
+}
+
+/*
+  *When a track is double clicked from the TitleList, depending on which mode we are in
+  */
+void BeagleMain::on_TitleList_doubleClicked(QModelIndex index)
+{
+    int selID = 0;
+    int selected = 0;
+    selected = ui->TitleList->currentIndex().row();
+    int FinParentID = 0;
+    char *FinSong;
+    char *FinParent;
+
+    FinSong = new char[100];
+    FinParent = new char[100];
+
+    if(MenuMode == 2 || MenuMode == 3){
+        selID = curSongID[selected];
+        FinSong = checkSongObjByID(selID, Song);
+        FinParentID = checkSongObjParByID(selID,Song);
+        FinParent = checkSongObjByID(FinParentID, Song);
+    }
+    else if(MenuMode == 4){
+        selID = curVidID[selected];
+        FinSong = checkSongObjByID(selID, Video);
+        FinParentID = checkSongObjParByID(selID,Video);
+        FinParent = checkSongObjByID(FinParentID, Video);
+    }
+    else{
+        selID = Song.getID(selected);
+        FinSong = checkSongObjByID(selID, Song);
+        FinParentID = checkSongObjParByID(selID,Song);
+        FinParent = checkSongObjByID(FinParentID, Song);
+    }
+    // start song
+    startSong(FinSong, selID);
+}
+
+/*
+  *When the Main list is selected, depending on which mode we are in
+  */
+void BeagleMain::on_MenuList_clicked(QModelIndex index)
+{
+    int selected = ui->MenuList->currentIndex().row();
+
+    if(MenuMode == 1){
+        updateAlbMenu(selected);
+        MenuMode =2;
+    }
+    else if(MenuMode == 4){
+        updateTitle(selected);
+    }
+    else{
+        updateTitle(selected);
+    }
+}
+/*
+  * When vol dial has changed
+  */
+void BeagleMain::on_VOL_dial_valueChanged(int value)
+{
+
+}
+
+/*
+  * when seek slider has moved
+  */
+void BeagleMain::on_SEEK_slider_sliderMoved(int position)
+{
+    //   widget.seek((double)position, 0);
+}
+
+/*
+  * When play button is pressed and held, seek
+  */
+void BeagleMain::on_FWD_but_pressed()
+{
+
+    int curTime = ui->SEEK_slider->value();
+
+    int FutTime = curTime + 10;
+    widget.seek((double)FutTime, curTime);
+}
+
+/*
+  * When Play button clicked, play
+  */
+void BeagleMain::on_FWD_but_clicked()
+{
+    widget.play();
+}
+/*
+  * When Pause button clicked, pause
+  */
+void BeagleMain::on_PAUSE_but_clicked()
+{
+    widget.pause();
+}
+
+/*
+  * When preferences menu item selected, open preference window
+  */
+void BeagleMain::on_actionPreferences_2_activated()
+{
+    pref.readDB();
+    prefDg.setPref(pref);
+    prefDg.show();
+    if (prefDg.exec()==QDialog::Accepted) {
+        pref = prefDg.getPref();
+        //delete custom sql db
+      //  pref.deleteDB(pref.getSQL().c_str());
+        //create custom sql db
+      //  pref.createDB();
+        /// write preferences to sql db
+        pref.writeDB();
+    }
+}
+
+/*
+  * When About menu item selected, open about dialog
+  */
+void BeagleMain::on_actionAbout_activated()
+{
+    ab.show();
+    if(ab.exec()==QDialog::Accepted) {
+        ab.close();
+    }
+}
+
+/*
+  * When Sync Button is selected , sync
+  */
+void BeagleMain::on_actionSync_activated()
+{
+    Sync(1);
+}
+
+/*
+  * When Add button is selected, get selected item (depending on mode),
+  * add to list, refill list
+  */
+void BeagleMain::on_ADD_but_clicked()
+{
+    int selID = 0;
+    int selected = 0;
+    char * strBuffer;
+    strBuffer= new char[100];
+    selected = ui->TitleList->currentIndex().row();
+
+    if(MenuMode == 2 || MenuMode == 3){
+         selID = curSongID[selected];
+      strBuffer=checkSongObjByID(selID, Song);
+    }
+    else if(MenuMode == 4){
+         selID = curVidID[selected];
+       strBuffer=checkSongObjByID(selID, Video);
+    }
+    else{
+        selID = Song.getID(selected);
+        strBuffer=checkSongObjByID(selID, Song);
+    }
+    pl.AddTo(selID, strBuffer);
+    RefillMainPL();
+}
+
+
+/*
+  * when the playlist list is doubleclick get which item we've selected and play it
+  */
+void BeagleMain::on_PlayList_doubleClicked(QModelIndex index)
+{
+
+
+    int selected;
+    selected = ui->PlayList->currentIndex().row();
+    int selID = 0;
+    char *FinSong;
+
+       if(plMode == 1){
+           pl.readPLfile((pref.getPlaylistDir() + pl.getPLFolder(selected)).c_str());   /// edit with selected playlist currently defaulting
+            RefillMainPL();
+            playlistOpen = true;
+            plMode = 2;
+       }
+       else{
+           pl_selected = 0;
+           pl_selected = ui->PlayList->currentIndex().row();
+           selID = pl.getTrackID(pl_selected);
+           PlaylistPlay(selID);
+       }
+
+    /// thread adding future
+    /*
+    if(plMode == 1){
+        pl.readPLfile((pref.getPlaylistDir() + pl.getPLFolder(selected)).c_str());   /// edit with selected playlist currently defaulting
+         RefillMainPL();
+         playlistOpen = true;
+         plMode = 2;
+    }
+    else  if(plMode == 2){
+
+        pl_selected = 0;
+        pl_selected = ui->PlayList->currentIndex().row();
+        mplay.set(pl, pref, pl_selected);
+        mplay.run();
+        plMode = 3;
+    }
+    else if(plMode == 3){
+
+         pl_selected = 0;
+         pl_selected = ui->PlayList->currentIndex().row();
+         mplay.set(pl, pref, pl_selected);
+         mplay.run();
+         plMode = 2;
+     }*/
+}
+
+/*
+  * When Remove button is clicked
+  */
+void BeagleMain::on_REMOVE_but_clicked()
+{
+    int selected = 0;
+    pl.RemoveFrom(pl_selected);
+    RefillMainPL();
+}
+
+
+
+void BeagleMain::on_SAVE_but_clicked()
+{
+    string fileName, fileLocate;
+    newPL.show();
+    if(newPL.exec()==QDialog::Accepted){
+        if(newPL.plExists()){
+            fileName = newPL.getFile();
+             fileLocate = newPL.getLocate();
+             pl.setFullLocation(fileName, fileLocate);
+             pl.writePLfile();
+        }
+    }
+}
+
+void BeagleMain::on_OPEN_but_clicked()
+{
+    plMode = 0;
+    string fileName, fileLocate;
+    fileName = "";
+    fileLocate = "";
+
+        openPL.show();
+        if(openPL.exec()==QDialog::Accepted){
+           if(openPL.plExists()){
+               fileName = openPL.getFile();
+               fileLocate = openPL.getLocate();
+                 pl.setFullLocation(fileName, fileLocate);
+           }
+        }
+
+         /// list .pl files in preferreed directory
+        RefillPLFolder();
+        plMode = 1;
+
+}
+
+void BeagleMain::on_FFWD_but_clicked()
+{
+    int selID = 0;
+
+    pl_selected++;
+     selID = pl.getTrackID(pl_selected);
+    PlaylistPlay(selID);
+
+}
+
+
+void BeagleMain::on_RRWD_but_clicked()
+{
+       int selID = 0;
+    pl_selected--;
+     selID = pl.getTrackID(pl_selected);
+    PlaylistPlay(selID);
+}
+
+void BeagleMain::on_UP_but_clicked()
+{
+    pl.Move(2, pl_selected);
+    pl_selected--;
+    RefillMainPL();
+}
+
+void BeagleMain::on_DOWN_but_clicked()
+{
+    pl.Move(1, pl_selected);
+    pl_selected++;
+    RefillMainPL();
+}
+
+void BeagleMain::on_PlayList_clicked(QModelIndex index)
+{
+    pl_selected = ui->PlayList->currentIndex().row();
+}
+
+ void BeagleMain::closeEvent(QCloseEvent *event){
+
+     widget.close();
+ }
+
+void BeagleMain::on_actionDonate_2_triggered()
+{
+    QDesktopServices::openUrl(QUrl("https://flattr.com/profile/hutchgrant", QUrl::TolerantMode));
+}
+
+void BeagleMain::on_ADMIN_but_clicked()
+{
+    char mediatombAdd[100];
+    sprintf(mediatombAdd, "http://%s:%s", pref.getServ().c_str(), pref.getPort().c_str());
+    QDesktopServices::openUrl(QUrl(mediatombAdd, QUrl::TolerantMode));
+}
+
+void BeagleMain::on_but_RadAdd_clicked()
+{
+    QString Radio_url;
+    QString Radio_name;
+
+    Radio_url = ui->entry_radURL->text();
+    Radio_name = ui->entry_radName->text();
+
+    Radio.Add(Radio_name.toStdString(),Radio_url.toStdString());
+    radSize++;
+
+    Radio.writeDB();
+    RefillRadioPL();
+}
+
+void BeagleMain::on_but_RemRad_clicked()
+{
+    int pos = 0;
+    string pl_ItemName;
+    pos = ui->list_radio->currentIndex().row();
+    pl_ItemName = Radio.getName(pos);
+    Radio.Remove(pl_ItemName, pos);
+    readDB rDB(pref.getSQL().c_str());
+    Radio = rDB.RadioFill(&radSize);
+    RefillRadioPL();
+}
+
+void BeagleMain::on_list_radio_clicked(QModelIndex index)
+{
+
+}
+
+/*
+  * refill playlist list with playlist model from playlist object
+  */
+void BeagleMain::RefillRadioPL(){
+    QStringList updatedList;
+   r_Model = new QStringListModel(this);
+    updatedList = Radio.RefillPlaylist();
+    r_Model->setStringList(updatedList);
+    ui->list_radio->setModel(r_Model);
+
+}
+
+void BeagleMain::on_list_radio_doubleClicked(QModelIndex index)
+{
+    int pos =0;
+    pos = ui->list_radio->currentIndex().row();
+    string finalUrl, finalName;
+    finalUrl = Radio.getUrl(pos);
+    finalName = Radio.getName(pos);
+    ui->SONG_lbl->setText((QString)finalName.c_str());
+    widget.show();
+    widget.start(QStringList(finalUrl.c_str()));
+}
--- /dev/null
+++ beagletomb-0.1.6/src/sync.h.BASE
@@ -0,0 +1,78 @@
+/*
+ *  Written By: Grant Hutchinson
+ *  License: GPLv3.
+ *  h.g.utchinson@gmail.com
+ *  Copyright (C) 2012 by Grant Hutchinson
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#ifndef SYNCMe_H_
+#define SYNCMe_H_
+
+#include <QtSql>
+
+#include <iostream>
+#include <stdio.h>
+#include <iostream>
+#include <string>
+#include <stdlib.h>
+#include <algorithm>
+#include <sstream>
+#include <iostream>
+#include <fstream>
+
+#include "mysqlconn.h"
+#include "readDB.h"
+#include "songObj.h"
+#include "radioObj.h"
+#include "mysqlconn.h"
+
+#define TEMPSYNCPREF "/.BeagleTomb/BTmedia.db"
+
+using namespace std;
+
+class syncMe {
+
+public:
+        string DBLocation;
+        QSqlDatabase db;
+
+        syncMe(const char *server, const char *user, const char *pass, const char *table, const char *dbLocation);
+
+        void videoWrite(songObj* Song, int songSize);
+
+        void vidDirWrite(songObj* Song, int songSize);
+
+        void songWrite(songObj* Song, int songSize);
+
+        void albumWrite(songObj* Album, int albSize);
+
+        void artistWrite(songObj* Artist, int artSize);
+
+        void writeMe(string qry);;
+
+        int getMaxPos(int count);
+        void sendToShell();
+        void RemoveTMP();
+	void display(songObj* Artist, int *artSize, songObj* Album, int *albSize, songObj *Song, int *songSize);
+	void deleteDB(const char *dbLocation);
+	void createDB(const char *dbLocation);
+        void OpenDB();
+        int control(const char *server, const char *user, const char *pass, const char *table, const char *dbLocation);
+
+	virtual ~syncMe();
+};
+#endif /* SYNCMe_H_ */
--- /dev/null
+++ beagletomb-0.1.6/src/sync.cpp.BASE
@@ -0,0 +1,354 @@
+/*
+ *  Written By: Grant Hutchinson
+ *  License: GPLv3.
+ *  h.g.utchinson@gmail.com
+ *  Copyright (C) 2012 by Grant Hutchinson
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#include "sync.h"
+using namespace std;
+syncMe::syncMe(const char *server, const char *user, const char *pass,
+               const char *table, const char *dbLocation) {
+    string home = getenv("HOME");
+     string temp_pref = home + TEMPSYNCPREF;
+   db = QSqlDatabase::addDatabase("QSQLITE", "connection");
+   db.setDatabaseName(temp_pref.c_str());
+
+
+   if(control(server, user, pass, table, dbLocation)==0){
+        // future error popup
+   }
+
+
+}
+
+void syncMe::deleteDB(const char *dbLocation) {
+    char FinalLink[150];
+    sprintf(FinalLink, "rm %s ", dbLocation);
+    system(FinalLink);
+}
+
+void syncMe::OpenDB(){
+
+}
+
+void syncMe::createDB(const char *dbLocation) {
+    string finalQry[7];
+    finalQry[0] = "create table Artists(key INTEGER PRIMARY KEY,Artist TEXT,ArtistID integer, ArtistPar integer) ";
+    finalQry[1] = "create table Albums(key INTEGER PRIMARY KEY,Album TEXT,AlbumID integer, AlbumPar integer)";
+    finalQry[2] = "create table Songs(key INTEGER PRIMARY KEY,Song TEXT,SongID integer, SongPar integer)";
+    finalQry[3] = "create table Videos(key INTEGER PRIMARY KEY,Video TEXT,VideoID integer, VideoPar integer)";
+    finalQry[4] = "create table VidDirs(key INTEGER PRIMARY KEY,VidDir TEXT,VidDirID integer, VidDirPar integer)";
+    finalQry[5] = "create table pref(key INTEGER PRIMARY KEY,usr TEXT,PASS TEXT,SERVER TEXT,PRT TEXT,SQLTABLE TEXT,SQL TEXT,PLAYLISTDIR TEXT)";
+    finalQry[6] = "create table radio(id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL DEFAULT (0),name TEXT NOT NULL,url TEXT NOT NULL)";
+    for(int i=0; i<7; i++){
+        writeMe(finalQry[i]);
+    }
+}
+
+int syncMe::control(const char *server, const char *user, const char *pass,
+                    const char *table, const char *dbLocation) {
+    DBLocation = dbLocation;
+    int artMenu, vidDirMenu; /// main Artist Menu ID
+    int artSize, albSize, songSize, vidSize, vidDirSize; /// sizes of each Object array
+
+    artMenu = 0, artSize = 0, albSize = 0 ,songSize = 0;
+    vidSize = 0, vidDirSize = 0;
+
+    /// init Objects
+    songObj *Artist = NULL, *Album = NULL, *Song = NULL, *VidDir = NULL, *Video = NULL;
+    songObj *newSong, *newAlbum, *newArtist;
+    songObj *newVideo, *newVidDir;
+    //attempt to delete previous DB
+    deleteDB(dbLocation);
+
+    //create new DB
+    createDB(dbLocation);
+
+    /// init mysqlObject
+    mysqlconn ms(server, user, pass, table);
+
+    // get main artist menu
+    artMenu = ms.connectArtMenu();
+    vidDirMenu = ms.connectVidMenu();
+    // get from mysql each artist,album,song - store and return objects
+    newArtist = ms.connectArtist(Artist, artMenu, &artSize);
+    newAlbum = ms.connectAlbum(newArtist, &artSize, Album, &albSize);
+    newSong = ms.connectSong(newAlbum, &albSize, Song, &songSize);
+    newVidDir = ms.connectVidDir(VidDir, vidDirMenu, &vidDirSize);
+    newVideo = ms.connectVideo(newVidDir, &vidDirSize, Video, &vidSize);
+    if(artMenu ==0){
+        cout << "empty database or invalid login" << endl;
+        return 0;
+    }
+    else{
+    ///  sync artist,album,song objects to the local sql database
+    artistWrite(newArtist, artSize);
+    albumWrite(newAlbum, albSize);
+    songWrite(newSong, songSize);
+    vidDirWrite(newVidDir, vidDirSize);
+    videoWrite(newVideo, vidSize);
+    return 1;
+    }
+}
+
+void syncMe::artistWrite(songObj* Artist, int artSize){
+    int  pos = 0, posMax = 0, counter = 0, countRemind = 0;
+
+    string str2;
+    counter = getMaxPos(artSize);
+    posMax = counter;
+
+    for (int m = 0; m <= (artSize / counter); m++) {
+        countRemind = 0;
+        stringstream os;
+        for (int i = pos; i <= posMax; i++) {
+            str2 = Artist[i].getFile();
+
+            str2.erase(remove(str2.begin(), str2.end(), '\"'), str2.end());
+            Artist[i].setFile((char *)str2.c_str());
+            //           cout << str2 << endl;
+            if (i != posMax && countRemind == 0) {
+                os << " INSERT INTO artists (Artist,ArtistID,ArtistPar) " <<
+                      "SELECT \"" << Artist[i].getFile() << "\" AS \"" << "Artist" << "\", \""
+                   <<  Artist[i].getFileID() << "\" AS \"" << "ArtistID" << "\", \""
+                   << Artist[i].getFilePar() << "\" AS \"" << "ArtistPar" << "\"";
+                //             cout << os;
+                countRemind++;
+            }
+            if (i != posMax && countRemind != 0) {
+                os << " UNION SELECT \""<< Artist[i].getFile()<<"\",\""<< Artist[i].getFileID()<<"\",\""<<Artist[i].getFilePar()<<"\"";
+
+            } else if (i == posMax && countRemind != 0) {
+                os << ";";
+            }
+        }
+        str2 = os.str();
+        writeMe(str2);
+        posMax += counter;
+        pos += counter;
+
+        if (m == (artSize / counter) - 1) {
+            posMax = pos + artSize - ((artSize / counter)
+                                      * counter);
+        }
+    }
+}
+
+void syncMe::albumWrite(songObj* Album, int albSize){
+    int  pos = 0, posMax = 0, counter = 0, countRemind = 0;
+
+    string str2;
+    counter = getMaxPos(albSize);
+    posMax = counter;
+
+    for (int m = 0; m <= (albSize / counter); m++) {
+        countRemind = 0;
+        stringstream os;
+        for (int i = pos; i <= posMax; i++) {
+            str2 = Album[i].getFile();
+
+            str2.erase(remove(str2.begin(), str2.end(), '\"'), str2.end());
+            Album[i].setFile((char *)str2.c_str());
+            //         cout << str2 << endl;
+            if (i != posMax && countRemind == 0) {
+                os << " INSERT INTO albums (Album,AlbumID,AlbumPar) " <<
+                      "SELECT \"" << Album[i].getFile() << "\" AS \"" << "Album" << "\", \""
+                   <<  Album[i].getFileID() << "\" AS \"" << "AlbumID" << "\", \""
+                   << Album[i].getFilePar() << "\" AS \"" << "AlbumPar" << "\"";
+                //           cout << os;
+                countRemind++;
+            }
+            if (i != posMax && countRemind != 0) {
+                os << " UNION SELECT \""<< Album[i].getFile()<<"\",\""<< Album[i].getFileID()<<"\",\""<<Album[i].getFilePar()<<"\"";
+
+            } else if (i == posMax && countRemind != 0) {
+                os << ";";
+            }
+        }
+        str2 = os.str();
+        writeMe(str2);
+        posMax += counter;
+        pos += counter;
+
+        if (m == (albSize / counter) - 1) {
+            posMax = pos + albSize - ((albSize / counter)
+                                      * counter);
+        }
+    }
+}
+void syncMe::songWrite(songObj* Song, int songSize){
+    int  pos = 0, posMax = 0, counter = 0, countRemind = 0;
+
+    string str2;
+    counter = getMaxPos(songSize);
+    posMax = counter;
+
+    for (int m = 0; m <= (songSize / counter); m++) {
+        countRemind = 0;
+        stringstream os;
+        for (int i = pos; i <= posMax; i++) {
+            str2 = Song[i].getFile();
+
+            str2.erase(remove(str2.begin(), str2.end(), '\"'), str2.end());
+            Song[i].setFile((char *)str2.c_str());
+            //         cout << str2 << endl;
+            if (i != posMax && countRemind == 0) {
+                os << " INSERT INTO songs (Song,SongID,SongPar) " <<
+                      "SELECT \"" << Song[i].getFile() << "\" AS \"" << "Song" << "\", \""
+                   <<  Song[i].getFileID() << "\" AS \"" << "SongID" << "\", \""
+                   << Song[i].getFilePar() << "\" AS \"" << "SongPar" << "\"";
+                //           cout << os;
+                countRemind++;
+            }
+            if (i != posMax && countRemind != 0) {
+                os << " UNION SELECT \""<< Song[i].getFile()<<"\",\""<< Song[i].getFileID()<<"\",\""<<Song[i].getFilePar()<<"\"";
+
+            } else if (i == posMax && countRemind != 0) {
+                os << ";";
+            }
+        }
+        str2 = os.str();
+        writeMe(str2);
+        posMax += counter;
+        pos += counter;
+
+        if (m == (songSize / counter) - 1) {
+            posMax = pos + songSize - ((songSize / counter)
+                                       * counter);
+        }
+    }
+}
+
+void syncMe::vidDirWrite(songObj* vidDir, int vidDirSize){
+    int  pos = 0, posMax = 0, counter = 0, countRemind = 0;
+
+    string str2;
+    counter = getMaxPos(vidDirSize);
+    posMax = counter;
+
+    for (int m = 0; m <= (vidDirSize / counter); m++) {
+        countRemind = 0;
+        stringstream os;
+        for (int i = pos; i <= posMax; i++) {
+            str2 = vidDir[i].getFile();
+
+            str2.erase(remove(str2.begin(), str2.end(), '\"'), str2.end());
+            vidDir[i].setFile((char *)str2.c_str());
+            //       cout << str2 << endl;
+            if (i != posMax && countRemind == 0) {
+                os << " INSERT INTO viddirs (VidDir,VidDirID,VidDirPar) " <<
+                      "SELECT \"" << vidDir[i].getFile() << "\" AS \"" << "VidDir" << "\", \""
+                   <<  vidDir[i].getFileID() << "\" AS \"" << "VidDirID" << "\", \""
+                   << vidDir[i].getFilePar() << "\" AS \"" << "VidDirPar" << "\"";
+                //          cout << os;
+                countRemind++;
+            }
+            if (i != posMax && countRemind != 0) {
+                os << " UNION SELECT \""<< vidDir[i].getFile()<<"\",\""<< vidDir[i].getFileID()<<"\",\""<<vidDir[i].getFilePar()<<"\"";
+
+            } else if (i == posMax && countRemind != 0) {
+                os << ";";
+            }
+        }
+        str2 = os.str();
+        writeMe(str2);
+        posMax += counter;
+        pos += counter;
+
+        if (m == (vidDirSize / counter) - 1) {
+            posMax = pos + vidDirSize - ((vidDirSize / counter)
+                                         * counter);
+        }
+    }
+}
+
+
+void syncMe::videoWrite(songObj* Video, int vidSize){
+    int  pos = 0, posMax = 0, counter = 0, countRemind = 0;
+
+    string str2;
+    counter = getMaxPos(vidSize);
+    posMax = counter;
+
+    for (int m = 0; m <= (vidSize / counter); m++) {
+        countRemind = 0;
+        stringstream os;
+        for (int i = pos; i <= posMax; i++) {
+            str2 = Video[i].getFile();
+
+            str2.erase(remove(str2.begin(), str2.end(), '\"'), str2.end());
+            Video[i].setFile((char *)str2.c_str());
+            //        cout << str2 << endl;
+            if (i != posMax && countRemind == 0) {
+                os << " INSERT INTO videos (Video,VideoID,VideoPar) " <<
+                      "SELECT \"" << Video[i].getFile() << "\" AS \"" << "Video" << "\", \""
+                   <<  Video[i].getFileID() << "\" AS \"" << "VideoID" << "\", \""
+                   << Video[i].getFilePar() << "\" AS \"" << "VideoPar" << "\"";
+                //           cout << os;
+                countRemind++;
+            }
+            if (i != posMax && countRemind != 0) {
+                os << " UNION SELECT \""<< Video[i].getFile()<<"\",\""<< Video[i].getFileID()<<"\",\""<<Video[i].getFilePar()<<"\"";
+
+            } else if (i == posMax && countRemind != 0) {
+                os << ";";
+            }
+        }
+        str2 = os.str();
+        writeMe(str2);
+        posMax += counter;
+        pos += counter;
+
+        if (m == (vidSize / counter) - 1) {
+            posMax = pos + vidSize - ((vidSize / counter)
+                                      * counter);
+        }
+    }
+}
+
+void syncMe::writeMe(string qry){
+
+       if(db.open()){
+           QSqlQuery myQry(db);
+           myQry.prepare(qry.c_str());
+           myQry.exec();
+           db.close();
+       }
+}
+
+
+int syncMe::getMaxPos(int count) {
+    int posMax;
+
+    if (count < 400 && count > 100) {
+        posMax = 100;
+    } else if (count < 100 && count > 20) {
+        posMax = 10;
+    } else if (count < 20) {
+        posMax = 5;
+    } else if (count < 20 && count > 10) {
+        posMax = 1;
+    } else {
+        posMax = 200;
+    }
+    return posMax;
+}
+
+syncMe::~syncMe() {
+   // db.close();
+}
--- beagletomb-0.1.6.orig/src/fileobj.h
+++ beagletomb-0.1.6/src/fileobj.h
@@ -86,6 +86,12 @@ public:
         objSize = 0;
         delete [] fileName;
     }
+
+
 };
 
+char* checkSongObjByID(int id, fileObj& src);   // returns song name based on query by unique ID
+int checkSongObjIDByPar(int par, fileObj& src);   // returns song ID based on query by parent ID
+int checkSongObjParByID(int id, fileObj& src);   // returns song ParID based on query by ID
+
 #endif // FILEOBJ_H
--- /dev/null
+++ beagletomb-0.1.6/src/beaglemain.h.OTHER
@@ -0,0 +1,161 @@
+/*
+ *  Written By: Grant Hutchinson
+ *  License: GPLv3.
+ *  h.g.utchinson@gmail.com
+ *  Copyright (C) 2012 by Grant Hutchinson
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#ifndef BEAGLEMAIN_H
+#define BEAGLEMAIN_H
+
+#include <QMainWindow>
+#include <stdlib.h>
+#include <stdio.h>
+#include "sync.h"
+#include "songObj.h"
+#include "readDB.h"
+#include "mplaycon.h"
+#include "prefdialog.h"
+#include "qmpwidget.h"
+#include "preferences.h"
+#include "about.h"
+#include "playlistobj.h"
+#include "newplaylist.h"
+#include "openplaylist.h"
+#include "radioObj.h"
+namespace Ui {
+class BeagleMain;
+}
+
+class BeagleMain : public QMainWindow
+{
+    Q_OBJECT
+
+public:
+
+    int MenuMode, TitleMode;
+    int albCount, songCount, vidCount, vidDirCount, radCount; ///  count of each item in the list
+    int *curAlbID, *curSongID, *curVidID, *curVidDirID;       ///  unique identifier for current file
+    int plMode;        /// playlist mode : 1 playlist browsing and 2: browsing tracks within playlist
+    int pl_selected;  /// global playlist selection
+     int title_selected;  /// global title selection
+
+    About ab;
+    PrefDialog prefDg;
+    preferences pref, pref2;
+    playlistobj pl;
+    newplaylist newPL;
+    openplaylist openPL;
+    QMPwidget widget;
+    mplayCon mplay;
+    fileObj Artist, Song, Album, VidDir, Video;
+    radioObj Radio;
+    int artSize, albSize, songSize, vidSize, vidDirSize, radSize;
+
+    bool playlistOpen;
+
+    void RefillRadioPL();
+    QStringList RefillRadList();
+
+    explicit BeagleMain(QWidget *parent = 0);
+   ~BeagleMain();
+
+    void updateMenu(int type);
+
+    void updateTitle();
+
+    void updateAlbMenu(int select);
+    void updateTitle(int select);
+    void Sync(int type);
+
+    bool isRunning();
+
+    void setMainPref(preferences pref);
+    void RefillMainPL();
+    void RefillPLFolder();
+    void startSong(char *FinSong, int selID);
+    void PlaylistPlay(int selID);
+    void closeEvent(QCloseEvent *event);
+
+private slots:
+    void on_SYNC_but_clicked();
+
+    void on_MODE_combo_currentIndexChanged(int index);
+
+    void on_STOP_but_clicked();
+
+    void on_TitleList_doubleClicked(QModelIndex index);
+
+    void on_MenuList_clicked(QModelIndex index);
+
+    void on_VOL_dial_valueChanged(int value);
+
+    void on_SEEK_slider_sliderMoved(int position);
+
+    void on_FWD_but_pressed();
+
+    void on_FWD_but_clicked();
+
+    void on_PAUSE_but_clicked();
+
+
+    void on_actionPreferences_2_activated();
+
+    void on_actionAbout_activated();
+
+    void on_actionSync_activated();
+
+    void on_ADD_but_clicked();
+
+    void on_PlayList_doubleClicked(QModelIndex index);
+
+    void on_REMOVE_but_clicked();
+
+    void on_SAVE_but_clicked();
+
+    void on_OPEN_but_clicked();
+
+    void on_FFWD_but_clicked();
+
+    void on_RRWD_but_clicked();
+
+    void on_UP_but_clicked();
+
+    void on_DOWN_but_clicked();
+
+    void on_PlayList_clicked(QModelIndex index);
+
+    void on_actionDonate_2_triggered();
+
+    void on_ADMIN_but_clicked();
+
+    void on_but_RadAdd_clicked();
+
+    void on_but_RemRad_clicked();
+
+    void on_list_radio_clicked(QModelIndex index);
+
+    void on_list_radio_doubleClicked(QModelIndex index);
+
+private:
+    Ui::BeagleMain *ui;
+    QStringListModel *t_Model;
+    QStringListModel *m_Model;
+    QStringListModel *r_Model;
+};
+
+#endif // BEAGLEMAIN_H
--- beagletomb-0.1.6.orig/src/mysqlconn.h
+++ beagletomb-0.1.6/src/mysqlconn.h
@@ -28,16 +28,11 @@
 #include <iostream>
 #include <string>
 #include <string.h>
-#include "songObj.h"
 #include <QtSql>
 #include "fileobj.h"
 using namespace std;
 
-#define MAXART 1000
-#define MAXALB 1000
-#define MAXSONG 2000
-#define MAXVIDEO 1000
-#define MAXQRY 1000
+#define MAXQRY 100
 class mysqlconn {
 
 public:
--- /dev/null
+++ beagletomb-0.1.6/src/sync.h.THIS
@@ -0,0 +1,77 @@
+/*
+ *  Written By: Grant Hutchinson
+ *  License: GPLv3.
+ *  h.g.utchinson@gmail.com
+ *  Copyright (C) 2012 by Grant Hutchinson
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#ifndef SYNCMe_H_
+#define SYNCMe_H_
+
+#include <QtSql>
+
+#include <iostream>
+#include <stdio.h>
+#include <iostream>
+#include <string>
+#include <stdlib.h>
+#include <algorithm>
+#include <sstream>
+#include <iostream>
+#include <fstream>
+
+#include "mysqlconn.h"
+#include "readDB.h"
+#include "radioObj.h"
+#include "mysqlconn.h"
+#include "fileobj.h"
+
+#define TEMPSYNCPREF "/.BeagleTomb/BTmedia.db"
+
+using namespace std;
+
+class syncMe {
+
+public:
+        string DBLocation;
+        QSqlDatabase db;
+
+        syncMe(const char *server, const char *user, const char *pass, const char *table, const char *dbLocation);
+
+        void videoWrite(fileObj& Video);
+
+        void vidDirWrite(fileObj& VidDir);
+
+        void songWrite(fileObj& Song);
+
+        void albumWrite(fileObj& Album);
+
+        void artistWrite(fileObj& Artist);
+
+        void writeMe(string qry);;
+
+        int getMaxPos(int count);
+        void sendToShell();
+        void RemoveTMP();
+	void deleteDB(const char *dbLocation);
+	void createDB(const char *dbLocation);
+        void OpenDB();
+        int control(const char *server, const char *user, const char *pass, const char *table, const char *dbLocation);
+
+	virtual ~syncMe();
+};
+#endif /* SYNCMe_H_ */
--- beagletomb-0.1.6.orig/src/sync.h
+++ beagletomb-0.1.6/src/sync.h
@@ -36,7 +36,6 @@
 
 #include "mysqlconn.h"
 #include "readDB.h"
-#include "songObj.h"
 #include "radioObj.h"
 #include "mysqlconn.h"
 #include "fileobj.h"
@@ -68,7 +67,10 @@ public:
         int getMaxPos(int count);
         void sendToShell();
         void RemoveTMP();
+<<<<<<< TREE
+=======
         void display(songObj* Artist, int *artSize, songObj* Album, int *albSize, songObj *Song, int *songSize);
+>>>>>>> MERGE-SOURCE
 	void deleteDB(const char *dbLocation);
 	void createDB(const char *dbLocation);
         void OpenDB();
--- beagletomb-0.1.6.orig/src/beaglemain.cpp
+++ beagletomb-0.1.6/src/beaglemain.cpp
@@ -34,7 +34,7 @@ BeagleMain::BeagleMain(QWidget *parent)
     ui->list_radio->setEditTriggers(QAbstractItemView::NoEditTriggers);
     widget.setSeekSlider(ui->SEEK_slider);
     widget.setVolumeSlider(ui->VOL_dial);
-
+    CON_MODE = 0;
 }
 
 /*
@@ -73,11 +73,11 @@ void BeagleMain::Sync(int type){
         else{
             //// read from sql and fill songObjs
             readDB rDB(pref.getSQL().c_str());
-            Artist = rDB.ArtistFill(&artSize);
-            Album = rDB.AlbumFill(&albSize);
-            Song = rDB.SongFill(&songSize);
-            VidDir = rDB.VidDirFill(&vidDirSize);
-            Video = rDB.VideoFill(&vidSize);
+            Artist = rDB.ArtistFill(Artist);
+            Album = rDB.AlbumFill(Album);
+            Song = rDB.SongFill(Song);
+            VidDir = rDB.VidDirFill(VidDir);
+            Video = rDB.VideoFill(Video);
             /// read from sql and fill radio obj
             Radio = rDB.RadioFill(&radSize);
             Radio.setDB(pref.getSQL());
@@ -106,11 +106,11 @@ void BeagleMain::Sync(int type){
         pref.setInitDB();
         cout << "reading.... " << endl;
         /// read from sqlite to songObjs
-        Artist = rDB.ArtistFill(&artSize);
-        Album = rDB.AlbumFill(&albSize);
-        Song = rDB.SongFill(&songSize);
-        VidDir = rDB.VidDirFill(&vidDirSize);
-        Video = rDB.VideoFill(&vidSize);
+        Artist = rDB.ArtistFill(Artist);
+        Album = rDB.AlbumFill(Album);
+        Song = rDB.SongFill(Song);
+        VidDir = rDB.VidDirFill(VidDir);
+        Video = rDB.VideoFill(Video);
         /// read from sql and fill radio obj
         cout << "syncing radio" << endl;
         Radio = rDB.RadioFill(&radSize);
@@ -129,20 +129,20 @@ void BeagleMain::updateMenu(int type){
     m_Model = new QStringListModel(this);
     if(type == 1){
         /// update with artist
-        for(int i=0; i<= artSize; i++){
-            curMenu << Artist[i].getFile();
+        for(int i=0; i< Artist.getSize(); i++){
+            curMenu << Artist.getName(i);
         }
     }
     else if(type == 2){
         /// update with album
-        for(int i=0; i<= albSize; i++){
-            curMenu << Album[i].getFile();
+        for(int i=0; i< Album.getSize(); i++){
+            curMenu << Album.getName(i);
         }
     }
     else if(type == 3){
         /// update with directories
-        for(int i=0; i<=vidDirSize; i++){
-            curMenu << VidDir[i].getFile();
+        for(int i=0; i< VidDir.getSize(); i++){
+            curMenu << VidDir.getName(i);
         }
     }
 
@@ -164,12 +164,12 @@ void BeagleMain::updateAlbMenu(int selec
     QStringList curAlb;
     m_Model = new QStringListModel(this);
     curAlbID = new int[MAX];
-    selID = Artist[select].getFileID();    /// selected ID
+    selID = Artist.getID(select);    /// selected ID
 
-    for(int i=0; i<= albSize; i++){
-        if(Album[i].getFilePar() == selID ){
-            curAlb << Album[i].getFile();
-            curAlbID[albCount] = Album[i].getFileID();
+    for(int i=0; i< Album.getSize(); i++){
+        if(Album.getPar(i) == selID ){
+            curAlb << Album.getName(i);
+            curAlbID[albCount] = Album.getID(i);
             albCount++;
         }
     }
@@ -185,8 +185,8 @@ void BeagleMain::updateTitle(){
     t_Model = new QStringListModel(this);
     QStringList songList;
 
-    for(int i = 0; i<= songSize; i++){
-        songList << Song[i].getFile();
+    for(int i = 0; i<= Song.getSize(); i++){
+        songList << Song.getName(i);
     }
     t_Model->setStringList(songList);
     ui->TitleList->setModel(t_Model);
@@ -205,31 +205,31 @@ void BeagleMain::updateTitle(int selecte
     curSongID = new int[MAX];
     curVidID = new int[MAX];
     if(MenuMode == 3){     ///  if ALL ALBUM
-        selID = Album[selected].getFileID();
-        for(int i = 0; i<= songSize; i++){
-            if(Song[i].getFilePar() == selID){
-                curSong << Song[i].getFile();
-                curSongID[songCount] = Song[i].getFileID();
+        selID = Album.getID(selected);
+        for(int i = 0; i< Song.getSize(); i++){
+            if(Song.getPar(i) == selID){
+                curSong << Song.getName(i);
+                curSongID[songCount] = Song.getID(i);
                 songCount++;
             }
         }
     }
     else if(MenuMode == 4){    ////// if VIDEO DIR MODE
-        selID = VidDir[selected].getFileID();
-        for(int i = 0; i<= vidSize; i++){
-            if(Video[i].getFilePar() == selID){
-                curSong << Video[i].getFile();
-                curVidID[vidCount] = Video[i].getFileID();
+        selID = VidDir.getID(selected);
+        for(int i = 0; i<= Video.getSize(); i++){
+            if(Video.getPar(i) == selID){
+                curSong << Video.getName(i);
+                curVidID[vidCount] = Video.getID(i);
                 vidCount++;
             }
         }
     }
     else{   /// IF ALBUM DIR MODE
         selID = curAlbID[selected];
-        for(int i = 0; i<= songSize; i++){
-            if(Song[i].getFilePar() == selID){
-                curSong << Song[i].getFile();
-                curSongID[songCount] = Song[i].getFileID();
+        for(int i = 0; i<= Song.getSize(); i++){
+            if(Song.getPar(i) == selID){
+                curSong << Song.getName(i);
+                curSongID[songCount] = Song.getID(i);
                 songCount++;
             }
         }
@@ -239,6 +239,76 @@ void BeagleMain::updateTitle(int selecte
     ui->TitleList->setModel(t_Model);
 
 }
+
+/*
+  * UPDATE with LOCAL Video directories
+  */
+void BeagleMain::updateLclVidDirs(){
+
+    vidDirecLocal = SyncVideoLocal.readLocalDB(2, vidDirecLocal);
+    t_Model = new QStringListModel(this);
+    QStringList dirList;
+
+    for(int i = 0; i< vidDirecLocal.getSize(); i++){
+        dirList << QString::fromStdString(string(vidDirecLocal.getName(i)));
+    }
+
+
+    t_Model->setStringList(dirList);
+    ui->MenuList->setModel(t_Model);
+}
+
+/*
+  * UPDATE with Local Video Files
+  */
+
+void BeagleMain::updateLclVideos(){
+    VideoLocal = SyncVideoLocal.readLocalDB(3, VideoLocal);
+    t_Model = new QStringListModel(this);
+    QStringList songList;
+
+    for(int i = 0; i< VideoLocal.getSize(); i++){
+        songList << QString::fromStdString(string(VideoLocal.getName(i)));
+    }
+    t_Model->setStringList(songList);
+    ui->TitleList->setModel(t_Model);
+}
+
+/*
+  * UPDATE with LOCAL Audio directories
+  */
+void BeagleMain::updateLclSongDirs(){
+
+    DirecLocal = SyncAudioLocal.readLocalDB(0, DirecLocal);
+    t_Model = new QStringListModel(this);
+    QStringList dirList;
+
+    for(int i = 0; i< DirecLocal.getSize(); i++){
+        dirList << QString::fromStdString(string(DirecLocal.getName(i)));
+    }
+    t_Model->setStringList(dirList);
+    ui->MenuList->setModel(t_Model);
+}
+
+/*
+  * UPDATE with Local Audio Files
+  */
+
+void BeagleMain::updateLclSongs(){
+    SongLocal = SyncAudioLocal.readLocalDB(1, SongLocal);
+    t_Model = new QStringListModel(this);
+    QStringList songList;
+
+    for(int i = 0; i< SongLocal.getSize(); i++){
+        songList << QString::fromStdString(string(SongLocal.getName(i)));
+    }
+    t_Model->setStringList(songList);
+    ui->TitleList->setModel(t_Model);
+}
+
+/*
+  *  Control for Start of remote File
+  */
 void BeagleMain::startSong(char *FinSong, int selID){
 
     char * strBuffer;
@@ -248,6 +318,18 @@ void BeagleMain::startSong(char *FinSong
     widget.show();
     widget.start(QStringList(strBuffer));
 }
+
+void BeagleMain::startLocal(char *finSong, char *finPath){
+
+    char *final;
+    final = new char[sizeof(finPath) + 100];
+    sprintf(final, "%s", finPath);
+    cout << "Final File Playing: " << final << endl;
+    ui->SONG_lbl->setText((QString)finSong);
+    widget.show();
+    widget.start(QStringList(final));
+}
+
 /*
   * refill playlist list with playlist model from playlist object
   */
@@ -287,11 +369,6 @@ void BeagleMain::PlaylistPlay(int selID)
 BeagleMain::~BeagleMain()
 {
     delete ui;
-    delete [] Artist;
-    delete [] Album;
-    delete [] Song;
-    delete [] Video;
-    delete [] VidDir;
 }
 
 /*
@@ -308,20 +385,44 @@ void BeagleMain::on_SYNC_but_clicked()
 void BeagleMain::on_MODE_combo_currentIndexChanged(int index)
 {
     if(index == 1){   //  update lists with artists
-        updateMenu(1);
-        MenuMode=1;
+        if(CON_MODE == 1){
+            updateMenu(1);
+            MenuMode=1;
+        }
+        else{
+             MenuMode=1;
+            updateLclSongDirs();
+        }
     }
     else if(index == 2){  // update lists with albums
-        updateMenu(2);
-        MenuMode=3;
+        if(CON_MODE == 1){
+            updateMenu(2);
+            MenuMode=3;
+        }
+        else{
+       //      updateLclAlbumDir();  // need to detect albums first.
+        }
     }
     else if(index == 3){  // update lists with songs
-        updateTitle();
-        TitleMode = 1;
+        if(CON_MODE == 1){
+            updateTitle();
+            TitleMode = 1;
+        }
+        else{
+            updateLclSongs();
+        }
+
     }
     else if(index == 4){  // update lists with vid directories
-        MenuMode = 4;
-        updateMenu(3);
+        if(CON_MODE == 1){
+            MenuMode = 4;
+            updateMenu(3);
+        }
+        else{
+             MenuMode = 4;
+            updateLclVidDirs();
+            updateLclVideos();
+        }
     }
 }
 
@@ -342,6 +443,36 @@ void BeagleMain::on_TitleList_doubleClic
     int selected = 0;
     selected = ui->TitleList->currentIndex().row();
     int FinParentID = 0;
+<<<<<<< TREE
+
+    if(CON_MODE == 1) {
+
+        char *FinSong;
+        char *FinParent;
+        FinSong = new char[100];
+        FinParent = new char[100];
+
+        if(MenuMode == 2 || MenuMode == 3){
+            selID = curSongID[selected];
+            FinSong = checkSongObjByID(selID, Song);
+            FinParentID = checkSongObjParByID(selID,Song);
+            FinParent = checkSongObjByID(FinParentID, Song);
+        }
+        else if(MenuMode == 4){
+            selID = curVidID[selected];
+            FinSong = checkSongObjByID(selID, Video);
+            FinParentID = checkSongObjParByID(selID,Video);
+            FinParent = checkSongObjByID(FinParentID, Video);
+        }
+        else{
+            selID = Song.getID(selected);
+            FinSong = checkSongObjByID(selID, Song);
+            FinParentID = checkSongObjParByID(selID,Song);
+            FinParent = checkSongObjByID(FinParentID, Song);
+        }
+        // start song
+        startSong(FinSong, selID);
+=======
     char *FinSong;
     char *FinParent;
 
@@ -350,24 +481,44 @@ void BeagleMain::on_TitleList_doubleClic
 
     if(MenuMode == 2 || MenuMode == 3){
         selID = curSongID[selected];
-        FinSong = checkSongObjByID(selID, Song, songSize);
-        FinParentID = checkSongObjParByID(selID,Song, songSize);
-        FinParent = checkSongObjByID(FinParentID, Song, songSize);
+        FinSong = checkSongObjByID(selID, Song);
+        FinParentID = checkSongObjParByID(selID,Song);
+        FinParent = checkSongObjByID(FinParentID, Song);
     }
     else if(MenuMode == 4){
         selID = curVidID[selected];
-        FinSong = checkSongObjByID(selID, Video, vidSize);
-        FinParentID = checkSongObjParByID(selID,Video, vidSize);
-        FinParent = checkSongObjByID(FinParentID, Video, vidSize);
+        FinSong = checkSongObjByID(selID, Video);
+        FinParentID = checkSongObjParByID(selID,Video);
+        FinParent = checkSongObjByID(FinParentID, Video);
+>>>>>>> MERGE-SOURCE
     }
     else{
-        selID = Song[selected].getFileID();
-        FinSong = checkSongObjByID(selID, Song, songSize);
-        FinParentID = checkSongObjParByID(selID,Song, songSize);
-        FinParent = checkSongObjByID(FinParentID, Song, songSize);
+<<<<<<< TREE
+        char *finPath;
+        char *finSong;
+
+        if(MenuMode != 4){
+            finSong = new char[strlen(SongLocal.getName(selected))+10];
+            finPath = new char[strlen(SongLocal.getPath(selected))+10];
+            finSong = SongLocal.getName(selected);
+            finPath = SongLocal.getPath(selected);
+        }
+        else{
+            finSong = new char[strlen(VideoLocal.getName(selected))+10];
+            finPath = new char[strlen(VideoLocal.getPath(selected))+10];
+            finSong = VideoLocal.getName(selected);
+            finPath = VideoLocal.getPath(selected);
+        }
+        startLocal(finSong, finPath);
+=======
+        selID = Song.getID(selected);
+        FinSong = checkSongObjByID(selID, Song);
+        FinParentID = checkSongObjParByID(selID,Song);
+        FinParent = checkSongObjByID(FinParentID, Song);
+>>>>>>> MERGE-SOURCE
     }
-    // start song
-    startSong(FinSong, selID);
+
+
 }
 
 /*
@@ -483,15 +634,15 @@ void BeagleMain::on_ADD_but_clicked()
 
     if(MenuMode == 2 || MenuMode == 3){
          selID = curSongID[selected];
-      strBuffer=checkSongObjByID(selID, Song, songSize);
+      strBuffer=checkSongObjByID(selID, Song);
     }
     else if(MenuMode == 4){
          selID = curVidID[selected];
-       strBuffer=checkSongObjByID(selID, Video, vidSize);
+       strBuffer=checkSongObjByID(selID, Video);
     }
     else{
-        selID = Song[selected].getFileID();
-        strBuffer=checkSongObjByID(selID, Song, songSize);
+        selID = Song.getID(selected);
+        strBuffer=checkSongObjByID(selID, Song);
     }
     pl.AddTo(selID, strBuffer);
     RefillMainPL();
@@ -707,3 +858,43 @@ void BeagleMain::on_list_radio_doubleCli
     widget.show();
     widget.start(QStringList(finalUrl.c_str()));
 }
+
+/*
+  * Import Audio folder button
+  */
+void BeagleMain::on_but_import_aud_clicked()
+{
+    QDir usrDir = QFileDialog::getExistingDirectory(this, tr("Import a directory"), QDir::currentPath());  // get folder import directory
+    SyncAudioLocal.Sync(usrDir, 0);
+    updateLclSongDirs();
+    updateLclSongs();
+}
+
+/*
+  * Import Video folder button
+  */
+void BeagleMain::on_but_import_vid_clicked()
+{
+    QDir usrDir = QFileDialog::getExistingDirectory(this, tr("Import a directory"), QDir::currentPath());  // get folder import directory
+   SyncVideoLocal.Sync(usrDir, 1);
+   updateLclVidDirs();
+   updateLclVideos();
+}
+
+
+/*
+  *  Toggle button for remote / local
+  */
+void BeagleMain::on_but_remote_tog_clicked()
+{
+    if(CON_MODE == 1){
+        CON_MODE = 0;  // set connection mode local
+        cout << "viewing local library" << endl;
+    }
+    else{
+        CON_MODE = 1; // set connection mode remote
+        cout << "viewing remote library" << endl;
+    }
+}
+
+
--- /dev/null
+++ beagletomb-0.1.6/src/beaglemain.h.THIS
@@ -0,0 +1,173 @@
+/*
+ *  Written By: Grant Hutchinson
+ *  License: GPLv3.
+ *  h.g.utchinson@gmail.com
+ *  Copyright (C) 2012 by Grant Hutchinson
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#ifndef BEAGLEMAIN_H
+#define BEAGLEMAIN_H
+
+#include <QMainWindow>
+#include <stdlib.h>
+#include <stdio.h>
+#include "sync.h"
+#include "readDB.h"
+#include "mplaycon.h"
+#include "prefdialog.h"
+#include "qmpwidget.h"
+#include "preferences.h"
+#include "about.h"
+#include "playlistobj.h"
+#include "newplaylist.h"
+#include "openplaylist.h"
+#include "radioObj.h"
+#include "localsync.h"
+namespace Ui {
+class BeagleMain;
+}
+
+class BeagleMain : public QMainWindow
+{
+    Q_OBJECT
+
+public:
+
+    int MenuMode, TitleMode;
+    int albCount, songCount, vidCount, vidDirCount, radCount; ///  count of each item in the list
+    int *curAlbID, *curSongID, *curVidID, *curVidDirID;       ///  unique identifier for current file
+    int plMode;        /// playlist mode : 1 playlist browsing and 2: browsing tracks within playlist
+    int pl_selected;  /// global playlist selection
+     int title_selected;  /// global title selection
+    int CON_MODE;
+
+    About ab;
+    PrefDialog prefDg;
+    preferences pref, pref2;
+    playlistobj pl;
+    newplaylist newPL;
+    openplaylist openPL;
+    QMPwidget widget;
+    mplayCon mplay;
+    localsync SyncAudioLocal, SyncVideoLocal;
+    fileObj Artist, Song, Album, VidDir, Video, DirecLocal, SongLocal, vidDirecLocal, VideoLocal;
+    radioObj Radio;
+    int artSize, albSize, songSize, vidSize, vidDirSize, radSize;
+
+    bool playlistOpen;
+
+    void RefillRadioPL();
+    QStringList RefillRadList();
+
+    explicit BeagleMain(QWidget *parent = 0);
+   ~BeagleMain();
+
+    void updateMenu(int type);
+    void updateTitle();
+    void updateLclSongDirs();
+    void updateLclSongs();
+    void updateLclVidDirs();
+    void updateLclVideos();
+
+    void updateAlbMenu(int select);
+    void updateTitle(int select);
+    void Sync(int type);
+
+    bool isRunning();
+
+    void setMainPref(preferences pref);
+    void RefillMainPL();
+    void RefillPLFolder();
+    void startSong(char *FinSong, int selID);
+    void startLocal(char *finSong, char *finPath);
+    void PlaylistPlay(int selID);
+    void closeEvent(QCloseEvent *event);
+
+private slots:
+    void on_SYNC_but_clicked();
+
+    void on_MODE_combo_currentIndexChanged(int index);
+
+    void on_STOP_but_clicked();
+
+    void on_TitleList_doubleClicked(QModelIndex index);
+
+    void on_MenuList_clicked(QModelIndex index);
+
+    void on_VOL_dial_valueChanged(int value);
+
+    void on_SEEK_slider_sliderMoved(int position);
+
+    void on_FWD_but_pressed();
+
+    void on_FWD_but_clicked();
+
+    void on_PAUSE_but_clicked();
+
+
+    void on_actionPreferences_2_activated();
+
+    void on_actionAbout_activated();
+
+    void on_actionSync_activated();
+
+    void on_ADD_but_clicked();
+
+    void on_PlayList_doubleClicked(QModelIndex index);
+
+    void on_REMOVE_but_clicked();
+
+    void on_SAVE_but_clicked();
+
+    void on_OPEN_but_clicked();
+
+    void on_FFWD_but_clicked();
+
+    void on_RRWD_but_clicked();
+
+    void on_UP_but_clicked();
+
+    void on_DOWN_but_clicked();
+
+    void on_PlayList_clicked(QModelIndex index);
+
+    void on_actionDonate_2_triggered();
+
+    void on_ADMIN_but_clicked();
+
+    void on_but_RadAdd_clicked();
+
+    void on_but_RemRad_clicked();
+
+    void on_list_radio_clicked(QModelIndex index);
+
+    void on_list_radio_doubleClicked(QModelIndex index);
+
+    void on_but_import_aud_clicked();
+
+    void on_but_remote_tog_clicked();
+
+    void on_but_import_vid_clicked();
+
+private:
+    Ui::BeagleMain *ui;
+    QStringListModel *t_Model;
+    QStringListModel *m_Model;
+    QStringListModel *r_Model;
+};
+
+#endif // BEAGLEMAIN_H
--- /dev/null
+++ beagletomb-0.1.6/src/sync.cpp.OTHER
@@ -0,0 +1,360 @@
+/*
+ *  Written By: Grant Hutchinson
+ *  License: GPLv3.
+ *  h.g.utchinson@gmail.com
+ *  Copyright (C) 2012 by Grant Hutchinson
+ *
+ *  This program is free software: you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License as published by
+ *  the Free Software Foundation, either version 3 of the License, or
+ *  (at your option) any later version.
+ *
+ *  This program is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *  GNU General Public License for more details.
+ *
+ *  You should have received a copy of the GNU General Public License
+ *  along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+
+#include "sync.h"
+using namespace std;
+syncMe::syncMe(const char *server, const char *user, const char *pass,
+               const char *table, const char *dbLocation) {
+    string home = getenv("HOME");
+     string temp_pref = home + TEMPSYNCPREF;
+   db = QSqlDatabase::addDatabase("QSQLITE", "connection");
+   db.setDatabaseName(temp_pref.c_str());
+
+
+   if(control(server, user, pass, table, dbLocation)==0){
+        // future error popup
+   }
+
+
+}
+
+void syncMe::deleteDB(const char *dbLocation) {
+    char FinalLink[150];
+    sprintf(FinalLink, "rm %s ", dbLocation);
+    system(FinalLink);
+}
+
+void syncMe::OpenDB(){
+
+}
+
+void syncMe::createDB(const char *dbLocation) {
+    string finalQry[7];
+    finalQry[0] = "create table Artists(key INTEGER PRIMARY KEY,Artist TEXT,ArtistID integer, ArtistPar integer) ";
+    finalQry[1] = "create table Albums(key INTEGER PRIMARY KEY,Album TEXT,AlbumID integer, AlbumPar integer)";
+    finalQry[2] = "create table Songs(key INTEGER PRIMARY KEY,Song TEXT,SongID integer, SongPar integer)";
+    finalQry[3] = "create table Videos(key INTEGER PRIMARY KEY,Video TEXT,VideoID integer, VideoPar integer)";
+    finalQry[4] = "create table VidDirs(key INTEGER PRIMARY KEY,VidDir TEXT,VidDirID integer, VidDirPar integer)";
+    finalQry[5] = "create table pref(key INTEGER PRIMARY KEY,usr TEXT,PASS TEXT,SERVER TEXT,PRT TEXT,SQLTABLE TEXT,SQL TEXT,PLAYLISTDIR TEXT)";
+    finalQry[6] = "create table radio(id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL DEFAULT (0),name TEXT NOT NULL,url TEXT NOT NULL)";
+    for(int i=0; i<7; i++){
+        writeMe(finalQry[i]);
+    }
+}
+
+int syncMe::control(const char *server, const char *user, const char *pass,
+                    const char *table, const char *dbLocation) {
+    DBLocation = dbLocation;
+    int artMenu, vidDirMenu; /// main Artist Menu ID
+    int artSize, albSize, songSize, vidSize, vidDirSize; /// sizes of each Object array
+
+    artMenu = 0, artSize = 0, albSize = 0 ,songSize = 0;
+    vidSize = 0, vidDirSize = 0;
+
+    /// init Objects
+    fileObj Artist, Album, Song, VidDir, Video;
+    //attempt to delete previous DB
+    deleteDB(dbLocation);
+
+    //create new DB
+    createDB(dbLocation);
+
+    /// init mysqlObject
+    mysqlconn ms(server, user, pass, table);
+
+    // get main artist menu
+    artMenu = ms.connectArtMenu();
+    vidDirMenu = ms.connectVidMenu();
+    // query mysql each artist,album,song,vidDir,video - store and return objects
+    Artist = ms.connectArtist(artMenu, Artist);
+    Album = ms.connectAlbum(Artist, Album);
+  //  Album.display();
+    Song = ms.connectSong(Album,Song);
+    VidDir = ms.connectVidDir(vidDirMenu,VidDir);
+    Video = ms.connectVideo(VidDir,Video);
+
+    if(artMenu ==0){
+        cout << "empty database or invalid login" << endl;
+        return 0;
+    }
+    else{
+    ///  sync artist,album,song objects to the local sql database
+    artistWrite(Artist);
+    albumWrite(Album);
+    songWrite(Song);
+    vidDirWrite(VidDir);
+    videoWrite(Video);
+    return 1;
+    }
+}
+
+void syncMe::artistWrite(fileObj& Artist){
+    int  pos = 0, posMax = 0, counter = 0, countRemind = 0;
+    int artSize =0;
+    artSize = Artist.getSize();
+    string str2;
+    counter = getMaxPos(artSize);
+    posMax = counter;
+
+    for (int m = 0; m <= (artSize / counter); m++) {
+        countRemind = 0;
+        stringstream os;
+        for (int i = pos; i <= posMax; i++) {
+            str2 = Artist.getName(i);
+
+            str2.erase(remove(str2.begin(), str2.end(), '\"'), str2.end());
+            Artist.setName(i,(char *)str2.c_str());
+            //           cout << str2 << endl;
+            if (i != posMax && countRemind == 0) {
+                os << " INSERT INTO artists (Artist,ArtistID,ArtistPar) " <<
+                      "SELECT \"" << Artist.getName(i) << "\" AS \"" << "Artist" << "\", \""
+                   <<  Artist.getID(i) << "\" AS \"" << "ArtistID" << "\", \""
+                   << Artist.getPar(i) << "\" AS \"" << "ArtistPar" << "\"";
+                //             cout << os;
+                countRemind++;
+            }
+            if (i != posMax && countRemind != 0) {
+                os << " UNION SELECT \""<< Artist.getName(i)<<"\",\""<< Artist.getID(i)<<"\",\""<<Artist.getPar(i)<<"\"";
+
+            } else if (i == posMax && countRemind != 0) {
+                os << ";";
+            }
+        }
+        str2 = os.str();
+        writeMe(str2);
+        posMax += counter;
+        pos += counter;
+
+        if (m == (artSize / counter) - 1) {
+            posMax = pos + artSize - ((artSize / counter)
+                                      * counter);
+        }
+    }
+}
+
+void syncMe::albumWrite(fileObj& Album){
+    int  pos = 0, posMax = 0, counter = 0, countRemind = 0;
+    int albSize = 0;
+    albSize = Album.getSize();
+    string str2;
+
+    counter = getMaxPos(albSize);
+    posMax = counter;
+
+    for (int m = 0; m <= (albSize / counter); m++) {
+        countRemind = 0;
+        stringstream os;
+        for (int i = pos; i <= posMax; i++) {
+            str2 = Album.getName(i);
+
+            str2.erase(remove(str2.begin(), str2.end(), '\"'), str2.end());
+            Album.setName(i,(char *)str2.c_str());
+            //         cout << str2 << endl;
+            if (i != posMax && countRemind == 0) {
+                os << " INSERT INTO albums (Album,AlbumID,AlbumPar) " <<
+                      "SELECT \"" << Album.getName(i) << "\" AS \"" << "Album" << "\", \""
+                   <<  Album.getID(i) << "\" AS \"" << "AlbumID" << "\", \""
+                   << Album.getPar(i) << "\" AS \"" << "AlbumPar" << "\"";
+                //           cout << os;
+                countRemind++;
+            }
+            if (i != posMax && countRemind != 0) {
+                os << " UNION SELECT \""<< Album.getName(i)<<"\",\""<< Album.getID(i)<<"\",\""<<Album.getPar(i)<<"\"";
+
+            } else if (i == posMax && countRemind != 0) {
+                os << ";";
+            }
+        }
+        str2 = os.str();
+        writeMe(str2);
+        posMax += counter;
+        pos += counter;
+
+        if (m == (albSize / counter) - 1) {
+            posMax = pos + albSize - ((albSize / counter)
+                                      * counter);
+        }
+    }
+}
+void syncMe::songWrite(fileObj& Song){
+    int  pos = 0, posMax = 0, counter = 0, countRemind = 0;
+    int songSize = 0;
+    songSize = Song.getSize();
+    string str2;
+    counter = getMaxPos(songSize);
+    posMax = counter;
+
+    for (int m = 0; m <= (songSize / counter); m++) {
+        countRemind = 0;
+        stringstream os;
+        for (int i = pos; i <= posMax; i++) {
+            str2 = Song.getName(i);
+
+            str2.erase(remove(str2.begin(), str2.end(), '\"'), str2.end());
+            Song.setName(i,(char *)str2.c_str());
+            //         cout << str2 << endl;
+            if (i != posMax && countRemind == 0) {
+                os << " INSERT INTO songs (Song,SongID,SongPar) " <<
+                      "SELECT \"" << Song.getName(i) << "\" AS \"" << "Song" << "\", \""
+                   <<  Song.getID(i) << "\" AS \"" << "SongID" << "\", \""
+                   << Song.getPar(i) << "\" AS \"" << "SongPar" << "\"";
+                //           cout << os;
+                countRemind++;
+            }
+            if (i != posMax && countRemind != 0) {
+                os << " UNION SELECT \""<< Song.getName(i)<<"\",\""<< Song.getID(i)<<"\",\""<<Song.getPar(i)<<"\"";
+
+            } else if (i == posMax && countRemind != 0) {
+                os << ";";
+            }
+        }
+        str2 = os.str();
+        writeMe(str2);
+        posMax += counter;
+        pos += counter;
+
+        if (m == (songSize / counter) - 1) {
+            posMax = pos + songSize - ((songSize / counter)
+                                       * counter);
+        }
+    }
+}
+
+void syncMe::vidDirWrite(fileObj& vidDir){
+    int  pos = 0, posMax = 0, counter = 0, countRemind = 0;
+    int vidDirSize = 0;
+    vidDirSize = vidDir.getSize();
+    string str2;
+    counter = getMaxPos(vidDirSize);
+    posMax = counter;
+
+    for (int m = 0; m <= (vidDirSize / counter); m++) {
+        countRemind = 0;
+        stringstream os;
+        for (int i = pos; i <= posMax; i++) {
+            str2 = vidDir.getName(i);
+
+            str2.erase(remove(str2.begin(), str2.end(), '\"'), str2.end());
+            vidDir.setName(i,(char *)str2.c_str());
+            //       cout << str2 << endl;
+            if (i != posMax && countRemind == 0) {
+                os << " INSERT INTO viddirs (VidDir,VidDirID,VidDirPar) " <<
+                      "SELECT \"" << vidDir.getName(i) << "\" AS \"" << "VidDir" << "\", \""
+                   <<  vidDir.getID(i) << "\" AS \"" << "VidDirID" << "\", \""
+                   << vidDir.getPar(i) << "\" AS \"" << "VidDirPar" << "\"";
+                //          cout << os;
+                countRemind++;
+            }
+            if (i != posMax && countRemind != 0) {
+                os << " UNION SELECT \""<< vidDir.getName(i)<<"\",\""<< vidDir.getID(i)<<"\",\""<<vidDir.getPar(i)<<"\"";
+
+            } else if (i == posMax && countRemind != 0) {
+                os << ";";
+            }
+        }
+        str2 = os.str();
+        writeMe(str2);
+        posMax += counter;
+        pos += counter;
+
+        if (m == (vidDirSize / counter) - 1) {
+            posMax = pos + vidDirSize - ((vidDirSize / counter)
+                                         * counter);
+        }
+    }
+}
+
+
+void syncMe::videoWrite(fileObj& Video){
+    int  pos = 0, posMax = 0, counter = 0, countRemind = 0;
+    int vidSize = 0;
+    vidSize = Video.getSize();
+    string str2;
+    counter = getMaxPos(vidSize);
+    posMax = counter;
+
+    for (int m = 0; m <= (vidSize / counter); m++) {
+        countRemind = 0;
+        stringstream os;
+        for (int i = pos; i <= posMax; i++) {
+            str2 = Video.getName(i);
+
+            str2.erase(remove(str2.begin(), str2.end(), '\"'), str2.end());
+            Video.setName(i,(char *)str2.c_str());
+            //        cout << str2 << endl;
+            if (i != posMax && countRemind == 0) {
+                os << " INSERT INTO videos (Video,VideoID,VideoPar) " <<
+                      "SELECT \"" << Video.getName(i) << "\" AS \"" << "Video" << "\", \""
+                   <<  Video.getID(i) << "\" AS \"" << "VideoID" << "\", \""
+                   << Video.getPar(i) << "\" AS \"" << "VideoPar" << "\"";
+                //           cout << os;
+                countRemind++;
+            }
+            if (i != posMax && countRemind != 0) {
+                os << " UNION SELECT \""<< Video.getName(i)<<"\",\""<< Video.getID(i)<<"\",\""<<Video.getPar(i)<<"\"";
+
+            } else if (i == posMax && countRemind != 0) {
+                os << ";";
+            }
+        }
+        str2 = os.str();
+        writeMe(str2);
+        posMax += counter;
+        pos += counter;
+
+        if (m == (vidSize / counter) - 1) {
+            posMax = pos + vidSize - ((vidSize / counter)
+                                      * counter);
+        }
+    }
+}
+
+void syncMe::writeMe(string qry){
+
+       if(db.open()){
+           QSqlQuery myQry(db);
+           myQry.prepare(qry.c_str());
+           myQry.exec();
+           db.close();
+       }
+}
+
+
+int syncMe::getMaxPos(int count) {
+    int posMax;
+
+    if (count < 400 && count > 100) {
+        posMax = 100;
+    } else if (count < 100 && count > 20) {
+        posMax = 10;
+    } else if (count < 20) {
+        posMax = 5;
+    } else if (count < 20 && count > 10) {
+        posMax = 1;
+    } else {
+        posMax = 200;
+    }
+    return posMax;
+}
+
+syncMe::~syncMe() {
+   // db.close();
+}
--- /dev/null
+++ beagletomb-0.1.6/src/localsync.h
@@ -0,0 +1,125 @@
+#ifndef LOCALSYNC_H
+#define LOCALSYNC_H
+#include <QDir>
+#include <QStringListModel>
+#include <QDirIterator>
+#include <QtGui/QMainWindow>
+#include <qstringlist.h>
+#include <QMainWindow>
+#include <QFileDialog>
+#include <iostream>
+#include "fileobj.h"
+#include <QtSql>
+#include <sstream>
+
+#define LOCALSYNC "/.BeagleTomb/BTlocal.db"
+using namespace std;
+
+class localsync
+{
+
+   int dirCount;  // counter for directories
+   int fileCount; // counter for files
+
+   int dirINIT;   // allocated size for DIR array
+   int fileINIT;  // allocated size for FILE array
+
+   string *lclDir;   // local directory path array
+   string *lclDirName; // local directory name array
+   string *lclFiles;  // local files array
+   int *lclDirPar;   // parentID of each DIRECTORY
+   int *lclFilePar;  // parentID of each FILE
+   int *lclDirID;   //  ID for each directory;
+   int *lclFileID; // ID for each file;
+
+   int lastID;   // Last ID in database for next ID
+   int parentID;  // ParentID of current DIR
+   int folderAddCount; // counter for overal number folder imports
+
+   QSqlDatabase db;
+   string home, db_local;
+
+public:
+    localsync();
+    virtual ~localsync();
+    void initAll();
+    void initFiles(int beg, int end);
+    void initDirs(int beg, int end);
+    void scanFiles(int scanType);
+    void scanDir(QString dir);
+
+    void Sync(QDir usrDir, int syncType);
+    void Remove();
+
+    void openLocalDB();
+    void openLocalDB2();
+
+    void createLocalDB();
+    void writeDBFiles(char *dbTable);
+    void writeDBDirs(char *dbTable);
+    void writeMe(string qry);
+    void removeDir(int selected);
+//  void removeFile(int selected);
+
+
+    int getMaxPos(int count);
+   fileObj& readLocalDB(int type, fileObj &src);
+   void setLastID(int last){
+       lastID = last;
+   }
+
+   void addFile(int count, string name, int par){
+       lclFiles[count] = name;
+       lclFilePar[count] = par;
+       lclFileID[count] = generateID();
+       fileCount++;
+       if(fileCount >= fileINIT){
+           initFiles(fileCount, 100);
+       }
+   }
+   void addFolder(int count, string dir, string name){
+       if(dirCount == 0){
+
+           lclDir[count] = dir;     /// full path
+           lclDirName[count] = name;  /// folder name
+           lclDirID[count] = dirCount;     /// folder ID
+           lclDirPar[count] = 0; /// folder parent
+           parentID = 0;
+       }
+       else{
+           lclDir[count] = dir;         /// folder path
+           lclDirName[count] = name;    /// folder name
+           lclDirPar[count] = parentID; /// folder parent
+           lclDirID[count] = dirCount;     /// folder ID
+       }
+       dirCount++;                   /// dir count
+       if(dirCount >= dirINIT){
+           initDirs(dirCount, 100);
+       }
+
+   }
+
+   int generateID(){
+
+       const char alphagen[] = "0123456789";
+       int random[10];
+       char fin[10];
+       int final = 0;
+       for(int i=0; i<10; i++){
+           random[i] = rand() % 9;
+       }
+
+       for(int i =0; i<10; i++){
+           fin[i] = alphagen[random[i]];
+       }
+
+       final = atoi(fin);
+       return final;
+
+   }
+
+private:
+    QDir mydir;
+};
+
+#endif // LOCALSYNC_H
--- /dev/null
+++ beagletomb-0.1.6/src/localsync.cpp
@@ -0,0 +1,377 @@
+#include "localsync.h"
+
+
+localsync::localsync()
+{
+    dirCount = 0;
+    fileCount = 0;
+    fileINIT = 0;
+    dirINIT = 0;
+    lastID = 0;
+    parentID = 0;
+    folderAddCount = 0;
+    initDirs(0,5);
+    initFiles(0, 5);
+    home = getenv("HOME");
+    db_local = home + LOCALSYNC;
+    openLocalDB();
+}
+void localsync::openLocalDB(){
+    db = QSqlDatabase::addDatabase("QSQLITE", "connection");
+    db.setDatabaseName(db_local.c_str());
+}
+localsync::~localsync()
+{
+    delete [] lclFiles;
+    delete [] lclFilePar;
+    delete [] lclFileID;
+    delete [] lclDir;
+    delete [] lclDirName;
+    delete [] lclDirPar;
+    delete [] lclDirID;
+}
+
+/*
+  * When Add is clicked
+  */
+void localsync::Sync(QDir usrDir, int syncType)
+{
+
+    //  QDir usrDir = QFileDialog::getExistingDirectory(this, tr("Import a directory"), QDir::currentPath());  // get folder import directory
+    int lclSyncExit = 0;                    // loop check if db was created properly
+    QString curDir = usrDir.absolutePath();  // get chosen path
+
+    if(curDir != NULL){
+        // add main import folder
+        addFolder(dirCount, curDir.toStdString(), usrDir.dirName().toStdString());
+        // scan main for directories
+        scanDir(curDir);
+        // scan for files in directories and main.
+
+
+        //sync to db
+        if(syncType == 0){  /// sync Audio
+            scanFiles(0);
+            while(!lclSyncExit){
+                if(!QFile::exists(db_local.c_str())){
+                    createLocalDB();
+                }
+                else{
+                    /// fill query
+                    writeDBDirs("lcl_songdirs");
+                    writeDBFiles("lcl_songs");
+                    lclSyncExit = 1;
+                }
+            }
+        }
+        else{
+            scanFiles(1);
+            while(!lclSyncExit){
+                if(!QFile::exists(db_local.c_str())){
+                    createLocalDB();
+                }
+                else{
+                    /// fill query
+                    writeDBDirs("lcl_viddirs");
+                    writeDBFiles("lcl_videos");
+                    lclSyncExit = 1;
+                }
+            }
+        }
+    }
+}
+
+/*
+  * Remove Directory from DB
+  */
+void localsync::removeDir(int selected){
+    char *myQry;
+    if(selected >= 0){
+        if(selected < dirCount){
+            myQry = new char[lclDirName[selected].length()+100];
+            cout << "selected = " << lclDirName[selected].c_str() << endl;
+            sprintf(myQry, "DELETE from lcl_dirs WHERE lcl_dir_name='%s'", lclDirName[selected].c_str());
+            string finQry = string(myQry);
+            writeMe(finQry);
+        }
+    }
+}
+
+void localsync::initDirs(int beg, int end){
+    string *dirCopy, *dirNameCopy;
+    int *dirParCopy, *dirIDCopy;
+    if(beg !=0){    // if not the inital allocation
+        ///allocate copy
+        dirCopy = new string[dirCount];
+        dirNameCopy = new string[dirCount];
+        dirParCopy = new int[dirCount];
+        dirIDCopy = new int[dirCount];
+        for(int i=0; i<dirCount; i++){
+            dirCopy[i] = "-"; dirNameCopy[i] = "-";
+            dirParCopy[i] = 0; dirIDCopy[i] = 0;
+        }
+        /// copy from resideFiles to resideCopy
+        for(int i=0; i<dirCount; i++){
+            dirCopy[i] = lclDir[i]; dirNameCopy[i] = lclDirName[i];
+            dirParCopy[i] = lclDirPar[i];dirIDCopy[i] = lclDirID[i];
+        }
+        delete [] lclDir; delete [] lclDirName;
+        delete [] lclDirPar; delete [] lclDirID;
+    }
+    /// initialize new resideFileArray
+    lclDir = new string[dirCount+end];
+    lclDirName = new string[dirCount+end];
+    lclDirPar = new int[dirCount+end];
+    lclDirID = new int[dirCount+end];
+    for(int i=0; i<end; i++){
+        lclDir[i] = "-"; lclDirName[i] = "-";
+        lclDirPar[i] = 0; lclDirID[i] = 0;
+    }
+
+    if(beg != 0){    // if not the inital allocation
+        /// fill with contents of copy
+        for(int i=0; i<dirCount; i++){
+            lclDir[i] = dirCopy[i];
+            lclDirName[i] = dirNameCopy[i];
+            lclDirPar[i] = dirParCopy[i];
+            lclDirID[i] = dirIDCopy[i];
+        }
+    }
+    dirINIT = end;
+}
+
+void localsync::initFiles(int beg, int end){
+    string *fileCopy;
+    int *fileIDCopy, *fileParCopy;
+    if(beg !=0){    // if not the inital allocation
+        ///allocate copy
+        fileCopy = new string[fileCount];
+        fileIDCopy = new int[fileCount];
+        fileParCopy = new int[fileCount];
+        for(int i=0; i<fileCount; i++){
+            fileCopy[i] = "-";
+            fileIDCopy[i] = 0; fileParCopy[i] = 0;
+        }
+        /// copy from resideFiles to resideCopy
+        for(int i=0; i<fileCount; i++){
+            fileCopy[i] = lclFiles[i];
+            fileParCopy[i] = lclFilePar[i];
+            fileIDCopy[i] = lclFileID[i];
+        }
+        delete [] lclFiles;
+        delete [] lclFilePar; delete [] lclFileID;
+    }
+    /// initialize new resideFileArray
+    lclFiles = new string[fileCount+end];
+    lclFilePar = new int[fileCount+end];
+    lclFileID = new int[fileCount+end];
+    for(int i=0; i<end; i++){
+        lclFiles[i] = "-";
+        lclFilePar[i] = 0;  lclFileID[i] = 0;
+    }
+
+    if(beg != 0){    // if not the inital allocation
+        /// fill with contents of copy
+        for(int i=0; i<fileCount; i++){
+            lclFiles[i] = fileCopy[i];
+            lclFilePar[i] = fileParCopy[i];
+            lclFileID[i] = fileIDCopy[i];
+        }
+    }
+    fileINIT = end;
+}
+
+void localsync::scanDir(QString dir){
+    QDirIterator directories(dir, QDir::Dirs | QDir::NoDotAndDotDot);
+    int count = dirCount;
+    while(directories.hasNext()){
+        directories.next();
+        addFolder(count, directories.filePath().toStdString(), directories.fileName().toStdString());
+        count++;
+    }
+}
+
+void localsync::scanFiles(int scanType){
+    int count = fileCount;
+    for(int i=0; i<dirCount; i++){
+
+        QDirIterator dirWalk(QString::fromStdString(lclDir[i]), QDir::Files | QDir::NoSymLinks);
+
+        while(dirWalk.hasNext())
+        {
+            dirWalk.next();
+            if(scanType == 0){  // if scanning audio
+                if(dirWalk.fileInfo().completeSuffix() == "mp3" || dirWalk.fileInfo().completeSuffix() == "flac"){
+                    addFile(count, dirWalk.fileName().toStdString(), lclDirID[i]);
+                    count++;
+                }
+            }
+            else{   // if scanning video
+                if(dirWalk.fileInfo().suffix() == "avi"){
+                    addFile(count, dirWalk.fileName().toStdString(), lclDirID[i]);
+                    count++;
+                }
+            }
+        }
+    }
+
+}
+
+fileObj& localsync::readLocalDB(int type, fileObj &src){
+
+    db = QSqlDatabase::addDatabase("QSQLITE");
+    db.setDatabaseName(db_local.c_str());
+
+    int count = 0;
+    if(db.open()){
+        QSqlQuery query(db);
+        if(type == 0){
+            query = QString("SELECT * FROM lcl_songdirs");
+        }
+        else if(type == 1){
+            query = QString("SELECT * FROM lcl_songs");
+        }
+        else if(type == 2){
+            query = QString("SELECT * FROM lcl_viddirs");
+        }
+        else{
+            query = QString("SELECT * FROM lcl_videos");
+        }
+        while (query.next()){
+            QString QVal1 = query.value(1).toString();
+            QString QVal2 = query.value(2).toString();
+            QString QVal3 = query.value(3).toString();
+            QString QVal4 = query.value(4).toString();
+
+            cout << QVal1.toStdString() << QVal2.toStdString() << QVal3.toStdString() << QVal4.toStdString() << endl;
+
+            if(QVal1.toStdString() != "-"){
+                src.set(count, QVal3.toInt(), QVal4.toInt(), QVal1.toStdString().c_str(), QVal2.toStdString().c_str());
+                count++;
+            }
+        }
+        db.close();
+    }
+    return src;
+}
+void localsync::writeDBFiles(char *dbTable){
+    int  pos = 0, posMax = 0, counter = 0, countRemind = 0;
+    string str2;
+    counter = getMaxPos(fileCount);
+    posMax = counter;
+
+    for (int m = 0; m <= (fileCount / counter); m++) {
+        countRemind = 0;
+        stringstream os;
+        for (int i = pos; i <= posMax; i++) {
+            if (i<fileCount){
+                if (i != posMax && countRemind == 0) {
+                    os << " INSERT INTO "<< dbTable << " (lcl_dir_path,lcl_dir_name,lcl_dir_id, lcl_dir_par,lcl_dir_type) " <<
+                          "SELECT \"" << lclDir[lclFilePar[i]] << lclFiles[i] << "\" AS \"" << "lcl_dir_path" << "\", \""
+                       <<  lclFiles[i] << "\" AS \"" << "lcl_dir_name" << "\", \""
+                       <<  lclFileID[i] << "\" AS \"" << "lcl_dir_id" << "\", \""
+                       <<  lclFilePar[i] << "\" AS \"" << "lcl_dir_par" << "\", \""
+                       <<  "songs" << "\" AS \"" << "lcl_dir_type" << "\"";
+                    cout << os;
+                    countRemind++;
+                }
+                if (i != posMax && countRemind != 0 ) {
+                    os << " UNION SELECT \"" <<  lclDir[lclFilePar[i]] << "/" << lclFiles[i] << "\",\""<< lclFiles[i] << "\",\"" << lclFileID[i] <<"\",\""<< lclFilePar[i]<<"\",\""<< "song" << "\"";
+
+                } else if (i == posMax && countRemind != 0) {
+                    os << ";";
+                }
+            }
+        }
+        str2 = os.str();
+        writeMe(str2);
+        posMax += counter;
+        pos += counter;
+
+        if (m == (fileCount / counter) - 1) {
+            posMax = pos + fileCount - ((fileCount / counter)
+                                        * counter);
+        }
+    }
+}
+void localsync::writeDBDirs(char *dbTable){
+    int  pos = 0, posMax = 0, counter = 0, countRemind = 0;
+    string str2;
+    counter = getMaxPos(dirCount);
+    posMax = counter;
+    /// reminder to get previous import folder position on second import
+    for (int m = 0; m <= (dirCount / counter); m++) {
+        countRemind = 0;
+        stringstream os;
+        for (int i = pos; i <= posMax; i++) {
+            //   string strFin = lclD
+            //            str2.erase(remove(str2.begin(), str2.end(), '\"'), str2.end());
+            if (i != posMax && countRemind == 0) {
+                os << " INSERT INTO "<< dbTable << " (lcl_dir_name,lcl_dir_path,lcl_dir_id,lcl_dir_par,lcl_dir_type) "
+                   <<  "SELECT \"" << lclDirName[i] << "\" AS \"" << "lcl_dir_name" << "\", \""
+                   <<  lclDir[i] << "\" AS \"" << "lcl_dir_path" << "\", \""
+                   <<  lclDirID[i] << "\" AS \"" << "lcl_dir_id" << "\", \""
+                   <<  lclDirPar[i] << "\" AS \"" << "lcl_dir_par" << "\", \""
+                   <<  "folder" << "\" AS \"" << "lcl_dir_type" << "\"";
+                countRemind++;
+            }
+            if (i != posMax && countRemind != 0) {
+                os << " UNION SELECT \""<< lclDirName[i] <<"\",\""<< lclDir[i] << "\",\"" << lclDirID[i] << "\",\""<< lclDirPar[i] << "\",\""<< "folder" << "\"";
+
+            } else if (i == posMax && countRemind != 0) {
+                os << ";";
+            }
+        }
+        str2 = os.str();
+        writeMe(str2);
+        posMax += counter;
+        pos += counter;
+
+        if (m == (dirCount / counter) - 1) {
+            posMax = pos + dirCount - ((dirCount / counter)
+                                       * counter);
+        }
+    }
+}
+
+int localsync::getMaxPos(int count) {
+    int posMax;
+
+    if (count < 400 && count > 100) {
+        posMax = 100;
+    } else if (count < 100 && count > 20) {
+        posMax = 10;
+    } else if (count < 20) {
+        posMax = 5;
+    } else if (count < 20 && count > 10) {
+        posMax = 1;
+    } else {
+        posMax = 200;
+    }
+    return posMax;
+}
+
+void localsync::createLocalDB() {
+    string finalQry[4];
+    // string create = "create table ";
+    finalQry[0] = "create table lcl_songdirs (key INTEGER PRIMARY KEY,lcl_dir_name TEXT,lcl_dir_path TEXT,lcl_dir_id integer,lcl_dir_par integer,lcl_dir_type TEXT)";
+    finalQry[1] = "create table lcl_songs (key INTEGER PRIMARY KEY,lcl_dir_name TEXT,lcl_dir_path TEXT,lcl_dir_id integer,lcl_dir_par integer,lcl_dir_type TEXT)";
+    finalQry[2] = "create table lcl_viddirs (key INTEGER PRIMARY KEY,lcl_dir_name TEXT,lcl_dir_path TEXT,lcl_dir_id integer,lcl_dir_par integer,lcl_dir_type TEXT)";
+    finalQry[3] = "create table lcl_videos (key INTEGER PRIMARY KEY,lcl_dir_name TEXT,lcl_dir_path TEXT,lcl_dir_id integer,lcl_dir_par integer,lcl_dir_type TEXT)";
+    for(int i=0; i<4; i++){
+        writeMe(finalQry[i]);
+    }
+}
+
+void localsync::writeMe(string qry){
+    openLocalDB();
+    if(db.open()){
+        //    cout << qry << endl;
+        QSqlQuery myQry(db);
+        myQry.prepare(qry.c_str());
+        myQry.exec();
+
+        db.close();
+    }
+
+}
